{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/parcoords/axisbrush.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/parcoords/axisbrush.js","mtime":1529418310726},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar c = require('./constants');\nvar d3 = require('d3');\nvar keyFun = require('../../lib/gup').keyFun;\nvar repeat = require('../../lib/gup').repeat;\nvar sortAsc = require('../../lib').sorterAsc;\n\nvar snapRatio = c.bar.snapRatio;\nfunction snapOvershoot(v, vAdjacent) { return v * (1 - snapRatio) + vAdjacent * snapRatio; }\n\nvar snapClose = c.bar.snapClose;\nfunction closeToCovering(v, vAdjacent) { return v * (1 - snapClose) + vAdjacent * snapClose; }\n\n// snap for the low end of a range on an ordinal scale\n// on an ordinal scale, always show some overshoot from the exact value,\n// so it's clear we're covering it\n// find the interval we're in, and snap to 1/4 the distance to the next\n// these two could be unified at a slight loss of readability / perf\nfunction ordinalScaleSnapLo(a, v, existingRanges) {\n    if(overlappingExisting(v, existingRanges)) return v;\n\n    var aPrev = a[0];\n    var aPrevPrev = aPrev;\n    for(var i = 1; i < a.length; i++) {\n        var aNext = a[i];\n\n        // very close to the previous - snap down to it\n        if(v < closeToCovering(aPrev, aNext)) return snapOvershoot(aPrev, aPrevPrev);\n        if(v < aNext || i === a.length - 1) return snapOvershoot(aNext, aPrev);\n\n        aPrevPrev = aPrev;\n        aPrev = aNext;\n    }\n}\n\nfunction ordinalScaleSnapHi(a, v, existingRanges) {\n    if(overlappingExisting(v, existingRanges)) return v;\n\n    var aPrev = a[a.length - 1];\n    var aPrevPrev = aPrev;\n    for(var i = a.length - 2; i >= 0; i--) {\n        var aNext = a[i];\n\n        // very close to the previous - snap down to it\n        if(v > closeToCovering(aPrev, aNext)) return snapOvershoot(aPrev, aPrevPrev);\n        if(v > aNext || i === a.length - 1) return snapOvershoot(aNext, aPrev);\n\n        aPrevPrev = aPrev;\n        aPrev = aNext;\n    }\n}\n\nfunction overlappingExisting(v, existingRanges) {\n    for(var i = 0; i < existingRanges.length; i++) {\n        if(v >= existingRanges[i][0] && v <= existingRanges[i][1]) return true;\n    }\n    return false;\n}\n\nfunction barHorizontalSetup(selection) {\n    selection\n        .attr('x', -c.bar.captureWidth / 2)\n        .attr('width', c.bar.captureWidth);\n}\n\nfunction backgroundBarHorizontalSetup(selection) {\n    selection\n        .attr('visibility', 'visible')\n        .style('visibility', 'visible')\n        .attr('fill', 'yellow')\n        .attr('opacity', 0);\n}\n\nfunction setHighlight(d) {\n    if(!d.brush.filterSpecified) {\n        return '0,' + d.height;\n    }\n    var pixelRanges = unitToPx(d.brush.filter.getConsolidated(), d.height);\n    var dashArray = [0]; // we start with a 0 length selection as filter ranges are inclusive, not exclusive\n    var p, sectionHeight, iNext;\n    var currentGap = pixelRanges.length ? pixelRanges[0][0] : null;\n    for(var i = 0; i < pixelRanges.length; i++) {\n        p = pixelRanges[i];\n        sectionHeight = p[1] - p[0];\n        dashArray.push(currentGap);\n        dashArray.push(sectionHeight);\n        iNext = i + 1;\n        if(iNext < pixelRanges.length) {\n            currentGap = pixelRanges[iNext][0] - p[1];\n        }\n    }\n    dashArray.push(d.height);\n    // d.height is added at the end to ensure that (1) we have an even number of dasharray points, MDN page says\n    // \"If an odd number of values is provided, then the list of values is repeated to yield an even number of values.\"\n    // and (2) it's _at least_ as long as the full height (even if range is minuscule and at the bottom) though this\n    // may not be necessary, maybe duplicating the last point would do too. But no harm in a longer dasharray than line.\n    return dashArray;\n}\n\nfunction unitToPx(unitRanges, height) {\n    return unitRanges.map(function(pr) {\n        return pr.map(function(v) { return v * height; }).sort(sortAsc);\n    });\n}\n\n// is the cursor over the north, middle, or south of a bar?\n// the end handles extend over the last 10% of the bar\nfunction getRegion(fPix, y) {\n    var pad = c.bar.handleHeight;\n    if(y > fPix[1] + pad || y < fPix[0] - pad) return;\n    if(y >= 0.9 * fPix[1] + 0.1 * fPix[0]) return 'n';\n    if(y <= 0.9 * fPix[0] + 0.1 * fPix[1]) return 's';\n    return 'ns';\n}\n\nfunction clearCursor() {\n    d3.select(document.body)\n        .style('cursor', null);\n}\n\nfunction styleHighlight(selection) {\n    // stroke-dasharray is used to minimize the number of created DOM nodes, because the requirement calls for up to\n    // 1000 individual selections on an axis, and there can be 60 axes per parcoords, and multiple parcoords per\n    // dashboard. The technique is similar to https://codepen.io/monfera/pen/rLYqWR and using a `polyline` with\n    // multiple sections, or a `path` element via its `d` attribute would also be DOM-sparing alternatives.\n    selection.attr('stroke-dasharray', setHighlight);\n}\n\nfunction renderHighlight(root, tweenCallback) {\n    var bar = d3.select(root).selectAll('.highlight, .highlight-shadow');\n    var barToStyle = tweenCallback ? bar.transition().duration(c.bar.snapDuration).each('end', tweenCallback) : bar;\n    styleHighlight(barToStyle);\n}\n\nfunction getInterval(d, y) {\n    var b = d.brush;\n    var active = b.filterSpecified;\n    var closestInterval = NaN;\n    var out = {};\n    var i;\n\n    if(active) {\n        var height = d.height;\n        var intervals = b.filter.getConsolidated();\n        var pixIntervals = unitToPx(intervals, height);\n        var hoveredInterval = NaN;\n        var previousInterval = NaN;\n        var nextInterval = NaN;\n        for(i = 0; i <= pixIntervals.length; i++) {\n            var p = pixIntervals[i];\n            if(p && p[0] <= y && y <= p[1]) {\n                // over a bar\n                hoveredInterval = i;\n                break;\n            } else {\n                // between bars, or before/after the first/last bar\n                previousInterval = i ? i - 1 : NaN;\n                if(p && p[0] > y) {\n                    nextInterval = i;\n                    break; // no point continuing as intervals are non-overlapping and sorted; could use log search\n                }\n            }\n        }\n\n        closestInterval = hoveredInterval;\n        if(isNaN(closestInterval)) {\n            if(isNaN(previousInterval) || isNaN(nextInterval)) {\n                closestInterval = isNaN(previousInterval) ? nextInterval : previousInterval;\n            }\n            else {\n                closestInterval = (y - pixIntervals[previousInterval][1] < pixIntervals[nextInterval][0] - y) ?\n                    previousInterval : nextInterval;\n            }\n        }\n\n        if(!isNaN(closestInterval)) {\n            var fPix = pixIntervals[closestInterval];\n            var region = getRegion(fPix, y);\n\n            if(region) {\n                out.interval = intervals[closestInterval];\n                out.intervalPix = fPix;\n                out.region = region;\n            }\n        }\n    }\n\n    if(d.ordinal && !out.region) {\n        var a = d.unitTickvals;\n        var unitLocation = d.unitToPaddedPx.invert(y);\n        for(i = 0; i < a.length; i++) {\n            var rangei = [\n                a[Math.max(i - 1, 0)] * 0.25 + a[i] * 0.75,\n                a[Math.min(i + 1, a.length - 1)] * 0.25 + a[i] * 0.75\n            ];\n            if(unitLocation >= rangei[0] && unitLocation <= rangei[1]) {\n                out.clickableOrdinalRange = rangei;\n                break;\n            }\n        }\n    }\n\n    return out;\n}\n\nfunction attachDragBehavior(selection) {\n    // There's some fiddling with pointer cursor styling so that the cursor preserves its shape while dragging a brush\n    // even if the cursor strays from the interacting bar, which is bound to happen as bars are thin and the user\n    // will inevitably leave the hotspot strip. In this regard, it does something similar to what the D3 brush would do.\n    selection\n        .on('mousemove', function(d) {\n            d3.event.preventDefault();\n            if(!d.parent.inBrushDrag) {\n                var y = d.height - d3.mouse(this)[1] - 2 * c.verticalPadding;\n                var interval = getInterval(d, y);\n\n                var cursor = 'crosshair';\n                if(interval.clickableOrdinalRange) cursor = 'pointer';\n                else if(interval.region) cursor = interval.region + '-resize';\n                d3.select(document.body)\n                    .style('cursor', cursor);\n            }\n        })\n        .on('mouseleave', function(d) {\n            if(!d.parent.inBrushDrag) clearCursor();\n        })\n        .call(d3.behavior.drag()\n            .on('dragstart', function(d) {\n                d3.event.sourceEvent.stopPropagation();\n                var y = d.height - d3.mouse(this)[1] - 2 * c.verticalPadding;\n                var unitLocation = d.unitToPaddedPx.invert(y);\n                var b = d.brush;\n                var interval = getInterval(d, y);\n                var unitRange = interval.interval;\n                var s = b.svgBrush;\n                s.wasDragged = false; // we start assuming there won't be a drag - useful for reset\n                s.grabbingBar = interval.region === 'ns';\n                if(s.grabbingBar) {\n                    var pixelRange = unitRange.map(d.unitToPaddedPx);\n                    s.grabPoint = y - pixelRange[0] - c.verticalPadding;\n                    s.barLength = pixelRange[1] - pixelRange[0];\n                }\n                s.clickableOrdinalRange = interval.clickableOrdinalRange;\n                s.stayingIntervals = (d.multiselect && b.filterSpecified) ? b.filter.getConsolidated() : [];\n                if(unitRange) {\n                    s.stayingIntervals = s.stayingIntervals.filter(function(int2) {\n                        return int2[0] !== unitRange[0] && int2[1] !== unitRange[1];\n                    });\n                }\n                s.startExtent = interval.region ? unitRange[interval.region === 's' ? 1 : 0] : unitLocation;\n                d.parent.inBrushDrag = true;\n                s.brushStartCallback();\n            })\n            .on('drag', function(d) {\n                d3.event.sourceEvent.stopPropagation();\n                var y = d.height - d3.mouse(this)[1] - 2 * c.verticalPadding;\n                var s = d.brush.svgBrush;\n                s.wasDragged = true;\n\n                if(s.grabbingBar) { // moving the bar\n                    s.newExtent = [y - s.grabPoint, y + s.barLength - s.grabPoint].map(d.unitToPaddedPx.invert);\n                } else { // south/north drag or new bar creation\n                    s.newExtent = [s.startExtent, d.unitToPaddedPx.invert(y)].sort(sortAsc);\n                }\n\n                // take care of the parcoords axis height constraint: bar can't breach it\n                var bottomViolation = Math.max(0, -s.newExtent[0]);\n                var topViolation = Math.max(0, s.newExtent[1] - 1);\n                s.newExtent[0] += bottomViolation;\n                s.newExtent[1] -= topViolation;\n                if(s.grabbingBar) {\n                    // in case of bar dragging (non-resizing interaction, unlike north/south resize or new bar creation)\n                    // the constraint adjustment must apply to the other end of the bar as well, otherwise it'd\n                    // shorten or lengthen\n                    s.newExtent[1] += bottomViolation;\n                    s.newExtent[0] -= topViolation;\n                }\n\n                d.brush.filterSpecified = true;\n                s.extent = s.stayingIntervals.concat([s.newExtent]);\n                s.brushCallback(d);\n                renderHighlight(this.parentNode);\n            })\n            .on('dragend', function(d) {\n                var e = d3.event;\n                e.sourceEvent.stopPropagation();\n                var brush = d.brush;\n                var filter = brush.filter;\n                var s = brush.svgBrush;\n                var grabbingBar = s.grabbingBar;\n                s.grabbingBar = false;\n                s.grabLocation = undefined;\n                d.parent.inBrushDrag = false;\n                clearCursor(); // instead of clearing, a nicer thing would be to set it according to current location\n                if(!s.wasDragged) { // a click+release on the same spot (ie. w/o dragging) means a bar or full reset\n                    s.wasDragged = undefined; // logic-wise unneeded, just shows `wasDragged` has no longer a meaning\n                    if(s.clickableOrdinalRange) {\n                        if(brush.filterSpecified && d.multiselect) {\n                            s.extent.push(s.clickableOrdinalRange);\n                        }\n                        else {\n                            s.extent = [s.clickableOrdinalRange];\n                            brush.filterSpecified = true;\n                        }\n                    }\n                    else if(grabbingBar) {\n                        s.extent = s.stayingIntervals;\n                        if(s.extent.length === 0) {\n                            brushClear(brush);\n                        }\n                    } else {\n                        brushClear(brush);\n                    }\n                    s.brushCallback(d);\n                    renderHighlight(this.parentNode);\n                    s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n                    return; // no need to fuse intervals or snap to ordinals, so we can bail early\n                }\n\n                var mergeIntervals = function() {\n                    // Key piece of logic: once the button is released, possibly overlapping intervals will be fused:\n                    // Here it's done immediately on click release while on ordinal snap transition it's done at the end\n                    filter.set(filter.getConsolidated());\n                };\n\n                if(d.ordinal) {\n                    var a = d.unitTickvals;\n                    if(a[a.length - 1] < a[0]) a.reverse();\n                    s.newExtent = [\n                        ordinalScaleSnapLo(a, s.newExtent[0], s.stayingIntervals),\n                        ordinalScaleSnapHi(a, s.newExtent[1], s.stayingIntervals)\n                    ];\n                    var hasNewExtent = s.newExtent[1] > s.newExtent[0];\n                    s.extent = s.stayingIntervals.concat(hasNewExtent ? [s.newExtent] : []);\n                    if(!s.extent.length) {\n                        brushClear(brush);\n                    }\n                    s.brushCallback(d);\n                    if(hasNewExtent) {\n                        // merging intervals post the snap tween\n                        renderHighlight(this.parentNode, mergeIntervals);\n                    }\n                    else {\n                        // if no new interval, don't animate, just redraw the highlight immediately\n                        mergeIntervals();\n                        renderHighlight(this.parentNode);\n                    }\n                } else {\n                    mergeIntervals(); // merging intervals immediately\n                }\n                s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n            })\n        );\n}\n\nfunction startAsc(a, b) { return a[0] - b[0]; }\n\nfunction renderAxisBrush(axisBrush) {\n\n    var background = axisBrush.selectAll('.background').data(repeat);\n\n    background.enter()\n        .append('rect')\n        .classed('background', true)\n        .call(barHorizontalSetup)\n        .call(backgroundBarHorizontalSetup)\n        .style('pointer-events', 'auto') // parent pointer events are disabled; we must have it to register events\n        .attr('transform', 'translate(0 ' + c.verticalPadding + ')');\n\n    background\n        .call(attachDragBehavior)\n        .attr('height', function(d) {\n            return d.height - c.verticalPadding;\n        });\n\n    var highlightShadow = axisBrush.selectAll('.highlight-shadow').data(repeat); // we have a set here, can't call it `extent`\n\n    highlightShadow.enter()\n        .append('line')\n        .classed('highlight-shadow', true)\n        .attr('x', -c.bar.width / 2)\n        .attr('stroke-width', c.bar.width + c.bar.strokeWidth)\n        .attr('stroke', c.bar.strokeColor)\n        .attr('opacity', c.bar.strokeOpacity)\n        .attr('stroke-linecap', 'butt');\n\n    highlightShadow\n        .attr('y1', function(d) { return d.height; })\n        .call(styleHighlight);\n\n    var highlight = axisBrush.selectAll('.highlight').data(repeat); // we have a set here, can't call it `extent`\n\n    highlight.enter()\n        .append('line')\n        .classed('highlight', true)\n        .attr('x', -c.bar.width / 2)\n        .attr('stroke-width', c.bar.width - c.bar.strokeWidth)\n        .attr('stroke', c.bar.fillColor)\n        .attr('opacity', c.bar.fillOpacity)\n        .attr('stroke-linecap', 'butt');\n\n    highlight\n        .attr('y1', function(d) { return d.height; })\n        .call(styleHighlight);\n}\n\nfunction ensureAxisBrush(axisOverlays) {\n    var axisBrush = axisOverlays.selectAll('.' + c.cn.axisBrush)\n        .data(repeat, keyFun);\n\n    axisBrush.enter()\n        .append('g')\n        .classed(c.cn.axisBrush, true);\n\n    renderAxisBrush(axisBrush);\n}\n\nfunction getBrushExtent(brush) {\n    return brush.svgBrush.extent.map(function(e) {return e.slice();});\n}\n\nfunction brushClear(brush) {\n    brush.filterSpecified = false;\n    brush.svgBrush.extent = [[0, 1]];\n}\n\nfunction axisBrushMoved(callback) {\n    return function axisBrushMoved(dimension) {\n        var brush = dimension.brush;\n        var extent = getBrushExtent(brush);\n        var newExtent = extent.slice();\n        brush.filter.set(newExtent);\n        callback();\n    };\n}\n\nfunction dedupeRealRanges(intervals) {\n    // Fuses elements of intervals if they overlap, yielding discontiguous intervals, results.length <= intervals.length\n    // Currently uses closed intervals, ie. dedupeRealRanges([[400, 800], [300, 400]]) -> [300, 800]\n    var queue = intervals.slice();\n    var result = [];\n    var currentInterval;\n    var current = queue.shift();\n    while(current) { // [].shift === undefined, so we don't descend into an empty array\n        currentInterval = current.slice();\n        while((current = queue.shift()) && current[0] <= /* right-open interval would need `<` */ currentInterval[1]) {\n            currentInterval[1] = Math.max(currentInterval[1], current[1]);\n        }\n        result.push(currentInterval);\n    }\n    return result;\n}\n\nfunction makeFilter() {\n    var filter = [];\n    var consolidated;\n    var bounds;\n    return {\n        set: function(a) {\n            filter = a\n                .map(function(d) { return d.slice().sort(sortAsc); })\n                .sort(startAsc);\n            consolidated = dedupeRealRanges(filter);\n            bounds = filter.reduce(function(p, n) {\n                return [Math.min(p[0], n[0]), Math.max(p[1], n[1])];\n            }, [Infinity, -Infinity]);\n        },\n        get: function() { return filter.slice(); },\n        getConsolidated: function() { return consolidated; },\n        getBounds: function() { return bounds; }\n    };\n}\n\nfunction makeBrush(state, rangeSpecified, initialRange, brushStartCallback, brushCallback, brushEndCallback) {\n    var filter = makeFilter();\n    filter.set(initialRange);\n    return {\n        filter: filter,\n        filterSpecified: rangeSpecified, // there's a difference between not filtering and filtering a non-proper subset\n        svgBrush: {\n            extent: [], // this is where the svgBrush writes contents into\n            brushStartCallback: brushStartCallback,\n            brushCallback: axisBrushMoved(brushCallback),\n            brushEndCallback: brushEndCallback\n        }\n    };\n}\n\n// for use by supplyDefaults, but it needed tons of pieces from here so\n// seemed to make more sense just to put the whole routine here\nfunction cleanRanges(ranges, dimension) {\n    if(Array.isArray(ranges[0])) {\n        ranges = ranges.map(function(ri) { return ri.sort(sortAsc); });\n\n        if(!dimension.multiselect) ranges = [ranges[0]];\n        else ranges = dedupeRealRanges(ranges.sort(startAsc));\n    }\n    else ranges = [ranges.sort(sortAsc)];\n\n    // ordinal snapping\n    if(dimension.tickvals) {\n        var sortedTickVals = dimension.tickvals.slice().sort(sortAsc);\n        ranges = ranges.map(function(ri) {\n            var rSnapped = [\n                ordinalScaleSnapLo(sortedTickVals, ri[0], []),\n                ordinalScaleSnapHi(sortedTickVals, ri[1], [])\n            ];\n            if(rSnapped[1] > rSnapped[0]) return rSnapped;\n        })\n        .filter(function(ri) { return ri; });\n\n        if(!ranges.length) return;\n    }\n    return ranges.length > 1 ? ranges : ranges[0];\n}\n\nmodule.exports = {\n    makeBrush: makeBrush,\n    ensureAxisBrush: ensureAxisBrush,\n    cleanRanges: cleanRanges\n};\n",null]}