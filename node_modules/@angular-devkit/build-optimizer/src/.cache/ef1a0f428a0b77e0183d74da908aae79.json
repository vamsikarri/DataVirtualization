{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/choropleth/plot.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/choropleth/plot.js","mtime":1529418310709},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar polygon = require('../../lib/polygon');\n\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\nvar locationToFeature = require('../../lib/geo_location_utils').locationToFeature;\nvar style = require('./style').style;\n\nmodule.exports = function plot(gd, geo, calcData) {\n    for(var i = 0; i < calcData.length; i++) {\n        calcGeoJSON(calcData[i], geo.topojson);\n    }\n\n    function keyFunc(d) { return d[0].trace.uid; }\n\n    var gTraces = geo.layers.backplot.select('.choroplethlayer')\n        .selectAll('g.trace.choropleth')\n        .data(calcData, keyFunc);\n\n    gTraces.enter().append('g')\n        .attr('class', 'trace choropleth');\n\n    gTraces.exit().remove();\n\n    gTraces.each(function(calcTrace) {\n        var sel = calcTrace[0].node3 = d3.select(this);\n\n        var paths = sel.selectAll('path.choroplethlocation')\n            .data(Lib.identity);\n\n        paths.enter().append('path')\n            .classed('choroplethlocation', true);\n\n        paths.exit().remove();\n\n        // call style here within topojson request callback\n        style(gd, calcTrace);\n    });\n};\n\nfunction calcGeoJSON(calcTrace, topojson) {\n    var trace = calcTrace[0].trace;\n    var len = calcTrace.length;\n    var features = getTopojsonFeatures(trace, topojson);\n\n    for(var i = 0; i < len; i++) {\n        var calcPt = calcTrace[i];\n        var feature = locationToFeature(trace.locationmode, calcPt.loc, features);\n\n        if(!feature) {\n            calcPt.geojson = null;\n            continue;\n        }\n\n\n        calcPt.geojson = feature;\n        calcPt.ct = feature.properties.ct;\n        calcPt.index = i;\n        calcPt._polygons = feature2polygons(feature);\n    }\n}\n\nfunction feature2polygons(feature) {\n    var geometry = feature.geometry;\n    var coords = geometry.coordinates;\n    var loc = feature.id;\n\n    var polygons = [];\n    var appendPolygon, j, k, m;\n\n    function doesCrossAntiMerdian(pts) {\n        for(var l = 0; l < pts.length - 1; l++) {\n            if(pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n        }\n        return null;\n    }\n\n    if(loc === 'RUS' || loc === 'FJI') {\n        // Russia and Fiji have landmasses that cross the antimeridian,\n        // we need to add +360 to their longitude coordinates, so that\n        // polygon 'contains' doesn't get confused when crossing the antimeridian.\n        //\n        // Note that other countries have polygons on either side of the antimeridian\n        // (e.g. some Aleutian island for the USA), but those don't confuse\n        // the 'contains' method; these are skipped here.\n        appendPolygon = function(_pts) {\n            var pts;\n\n            if(doesCrossAntiMerdian(_pts) === null) {\n                pts = _pts;\n            } else {\n                pts = new Array(_pts.length);\n                for(m = 0; m < _pts.length; m++) {\n                    // do nut mutate calcdata[i][j].geojson !!\n                    pts[m] = [\n                        _pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0],\n                        _pts[m][1]\n                    ];\n                }\n            }\n\n            polygons.push(polygon.tester(pts));\n        };\n    } else if(loc === 'ATA') {\n        // Antarctica has a landmass that wraps around every longitudes which\n        // confuses the 'contains' methods.\n        appendPolygon = function(pts) {\n            var crossAntiMeridianIndex = doesCrossAntiMerdian(pts);\n\n            // polygon that do not cross anti-meridian need no special handling\n            if(crossAntiMeridianIndex === null) {\n                return polygons.push(polygon.tester(pts));\n            }\n\n            // stitch polygon by adding pt over South Pole,\n            // so that it covers the projected region covers all latitudes\n            //\n            // Note that the algorithm below only works for polygons that\n            // start and end on longitude -180 (like the ones built by\n            // https://github.com/etpinard/sane-topojson).\n            var stitch = new Array(pts.length + 1);\n            var si = 0;\n\n            for(m = 0; m < pts.length; m++) {\n                if(m > crossAntiMeridianIndex) {\n                    stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n                } else if(m === crossAntiMeridianIndex) {\n                    stitch[si++] = pts[m];\n                    stitch[si++] = [pts[m][0], -90];\n                } else {\n                    stitch[si++] = pts[m];\n                }\n            }\n\n            // polygon.tester by default appends pt[0] to the points list,\n            // we must remove it here, to avoid a jump in longitude from 180 to -180,\n            // that would confuse the 'contains' method\n            var tester = polygon.tester(stitch);\n            tester.pts.pop();\n            polygons.push(tester);\n        };\n    } else {\n        // otherwise using same array ref is fine\n        appendPolygon = function(pts) {\n            polygons.push(polygon.tester(pts));\n        };\n    }\n\n    switch(geometry.type) {\n        case 'MultiPolygon':\n            for(j = 0; j < coords.length; j++) {\n                for(k = 0; k < coords[j].length; k++) {\n                    appendPolygon(coords[j][k]);\n                }\n            }\n            break;\n        case 'Polygon':\n            for(j = 0; j < coords.length; j++) {\n                appendPolygon(coords[j]);\n            }\n            break;\n    }\n\n    return polygons;\n}\n",null]}