{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/transforms/sort.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/transforms/sort.js","mtime":1529418310751},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Axes = require('../plots/cartesian/axes');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nexports.moduleType = 'transform';\n\nexports.name = 'sort';\n\nexports.attributes = {\n    enabled: {\n        valType: 'boolean',\n        dflt: true,\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Determines whether this sort transform is enabled or disabled.'\n        ].join(' ')\n    },\n    target: {\n        valType: 'string',\n        strict: true,\n        noBlank: true,\n        arrayOk: true,\n        dflt: 'x',\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Sets the target by which the sort transform is applied.',\n\n            'If a string, *target* is assumed to be a reference to a data array',\n            'in the parent trace object.',\n            'To sort about nested variables, use *.* to access them.',\n            'For example, set `target` to *marker.size* to sort',\n            'about the marker size array.',\n\n            'If an array, *target* is then the data array by which',\n            'the sort transform is applied.'\n        ].join(' ')\n    },\n    order: {\n        valType: 'enumerated',\n        values: ['ascending', 'descending'],\n        dflt: 'ascending',\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Sets the sort transform order.'\n        ].join(' ')\n    },\n    editType: 'calc'\n};\n\nexports.supplyDefaults = function(transformIn) {\n    var transformOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n    }\n\n    var enabled = coerce('enabled');\n\n    if(enabled) {\n        coerce('target');\n        coerce('order');\n    }\n\n    return transformOut;\n};\n\nexports.calcTransform = function(gd, trace, opts) {\n    if(!opts.enabled) return;\n\n    var targetArray = Lib.getTargetArray(trace, opts);\n    if(!targetArray) return;\n\n    var target = opts.target;\n\n    var len = targetArray.length;\n    if(trace._length) len = Math.min(len, trace._length);\n\n    var arrayAttrs = trace._arrayAttrs;\n    var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n    var indices = getIndices(opts, targetArray, d2c, len);\n    var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n    var indexToPoints = {};\n    var i, j;\n\n    for(i = 0; i < arrayAttrs.length; i++) {\n        var np = Lib.nestedProperty(trace, arrayAttrs[i]);\n        var arrayOld = np.get();\n        var arrayNew = new Array(len);\n\n        for(j = 0; j < len; j++) {\n            arrayNew[j] = arrayOld[indices[j]];\n        }\n\n        np.set(arrayNew);\n    }\n\n    for(j = 0; j < len; j++) {\n        indexToPoints[j] = originalPointsAccessor(indices[j]);\n    }\n\n    opts._indexToPoints = indexToPoints;\n    trace._length = len;\n};\n\nfunction getIndices(opts, targetArray, d2c, len) {\n    var sortedArray = new Array(len);\n    var indices = new Array(len);\n    var i;\n\n    for(i = 0; i < len; i++) {\n        sortedArray[i] = {v: targetArray[i], i: i};\n    }\n\n    sortedArray.sort(getSortFunc(opts, d2c));\n\n    for(i = 0; i < len; i++) {\n        indices[i] = sortedArray[i].i;\n    }\n\n    return indices;\n}\n\nfunction getSortFunc(opts, d2c) {\n    switch(opts.order) {\n        case 'ascending':\n            return function(a, b) { return d2c(a.v) - d2c(b.v); };\n        case 'descending':\n            return function(a, b) { return d2c(b.v) - d2c(a.v); };\n    }\n}\n",null]}