{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-scatter3d/pointcloud.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-scatter3d/pointcloud.js","mtime":1529418308683},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\r\n\r\nvar createBuffer  = require('gl-buffer')\r\nvar createVAO     = require('gl-vao')\r\nvar pool          = require('typedarray-pool')\r\nvar mat4mult      = require('gl-mat4/multiply')\r\nvar shaders       = require('./lib/shaders')\r\nvar getGlyph      = require('./lib/glyphs')\r\n\r\nvar IDENTITY = [1,0,0,0,\r\n                0,1,0,0,\r\n                0,0,1,0,\r\n                0,0,0,1]\r\n\r\nmodule.exports = createPointCloud\r\n\r\nfunction transformMat4(x, m) {\r\n  var x0 = x[0]\r\n  var x1 = x[1]\r\n  var x2 = x[2]\r\n  var x3 = x[3]\r\n  x[0] = m[0] * x0 + m[4] * x1 + m[8]  * x2 + m[12] * x3\r\n  x[1] = m[1] * x0 + m[5] * x1 + m[9]  * x2 + m[13] * x3\r\n  x[2] = m[2] * x0 + m[6] * x1 + m[10] * x2 + m[14] * x3\r\n  x[3] = m[3] * x0 + m[7] * x1 + m[11] * x2 + m[15] * x3\r\n  return x\r\n}\r\n\r\nfunction project(p, v, m, x) {\r\n  transformMat4(x, x, m)\r\n  transformMat4(x, x, v)\r\n  return transformMat4(x, x, p)\r\n}\r\n\r\nfunction clampVec(v) {\r\n  var result = new Array(3)\r\n  for(var i=0; i<3; ++i) {\r\n    result[i] = Math.min(Math.max(v[i], -1e8), 1e8)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction ScatterPlotPickResult(index, position) {\r\n  this.index = index\r\n  this.dataCoordinate = this.position = position\r\n}\r\n\r\nfunction PointCloud(\r\n  gl,\r\n  shader,\r\n  orthoShader,\r\n  projectShader,\r\n  pointBuffer,\r\n  colorBuffer,\r\n  glyphBuffer,\r\n  idBuffer,\r\n  vao,\r\n  pickPerspectiveShader,\r\n  pickOrthoShader,\r\n  pickProjectShader) {\r\n\r\n  this.gl              = gl\r\n\r\n  this.pixelRatio      = 1\r\n\r\n  this.shader          = shader\r\n  this.orthoShader     = orthoShader\r\n  this.projectShader   = projectShader\r\n\r\n  this.pointBuffer     = pointBuffer\r\n  this.colorBuffer     = colorBuffer\r\n  this.glyphBuffer     = glyphBuffer\r\n  this.idBuffer        = idBuffer\r\n  this.vao             = vao\r\n  this.vertexCount     = 0\r\n  this.lineVertexCount = 0\r\n\r\n  this.opacity         = 1.0\r\n\r\n  this.lineWidth       = 0\r\n  this.projectScale    = [2.0/3.0, 2.0/3.0, 2.0/3.0]\r\n  this.projectOpacity  = [1,1,1]\r\n\r\n  this.pickId                = 0\r\n  this.pickPerspectiveShader = pickPerspectiveShader\r\n  this.pickOrthoShader       = pickOrthoShader\r\n  this.pickProjectShader     = pickProjectShader\r\n  this.points                = []\r\n\r\n  this._selectResult = new ScatterPlotPickResult(0, [0,0,0])\r\n\r\n  this.useOrtho = true\r\n  this.bounds   = [[ Infinity,Infinity,Infinity],\r\n                   [-Infinity,-Infinity,-Infinity]]\r\n\r\n  //Axes projections\r\n  this.axesProject = [ true, true, true ]\r\n  this.axesBounds = [[-Infinity,-Infinity,-Infinity],\r\n                     [ Infinity, Infinity, Infinity]]\r\n\r\n  this.highlightId    = [1,1,1,1]\r\n  this.highlightScale = 2\r\n\r\n  this.clipBounds = [[-Infinity,-Infinity,-Infinity],\r\n                     [ Infinity, Infinity, Infinity]]\r\n\r\n  this.dirty = true\r\n}\r\n\r\nvar proto = PointCloud.prototype\r\n\r\nproto.pickSlots = 1\r\n\r\nproto.setPickBase = function(pickBase) {\r\n  this.pickId = pickBase\r\n}\r\n\r\nproto.isTransparent = function() {\r\n  if(this.opacity < 1)  {\r\n    return true\r\n  }\r\n  for(var i=0; i<3; ++i) {\r\n    if(this.axesProject[i] && this.projectOpacity[i] < 1) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nproto.isOpaque = function() {\r\n  if(this.opacity >= 1)  {\r\n    return true\r\n  }\r\n  for(var i=0; i<3; ++i) {\r\n    if(this.axesProject[i] && this.projectOpacity[i] >= 1) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nvar VIEW_SHAPE = [0,0]\r\nvar U_VEC = [0,0,0]\r\nvar V_VEC = [0,0,0]\r\nvar MU_VEC = [0,0,0,1]\r\nvar MV_VEC = [0,0,0,1]\r\nvar SCRATCH_MATRIX = IDENTITY.slice()\r\nvar SCRATCH_VEC = [0,0,0]\r\nvar CLIP_BOUNDS = [[0,0,0], [0,0,0]]\r\n\r\nfunction zeroVec(a) {\r\n  a[0] = a[1] = a[2] = 0\r\n  return a\r\n}\r\n\r\nfunction augment(hg, af) {\r\n  hg[0] = af[0]\r\n  hg[1] = af[1]\r\n  hg[2] = af[2]\r\n  hg[3] = 1\r\n  return hg\r\n}\r\n\r\nfunction setComponent(out, v, i, x) {\r\n  out[0] = v[0]\r\n  out[1] = v[1]\r\n  out[2] = v[2]\r\n  out[i] = x\r\n  return out\r\n}\r\n\r\nfunction getClipBounds(bounds) {\r\n  var result = CLIP_BOUNDS\r\n  for(var i=0; i<2; ++i) {\r\n    for(var j=0; j<3; ++j) {\r\n      result[i][j] = Math.max(Math.min(bounds[i][j], 1e8), -1e8)\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\nfunction drawProject(shader, points, camera, transparent, forceDraw) {\r\n  var axesProject = points.axesProject\r\n\r\n  var gl         = points.gl\r\n  var uniforms   = shader.uniforms\r\n  var model      = camera.model      || IDENTITY\r\n  var view       = camera.view       || IDENTITY\r\n  var projection = camera.projection || IDENTITY\r\n  var bounds     = points.axesBounds\r\n  var clipBounds = getClipBounds(points.clipBounds)\r\n\r\n  var cubeAxis\r\n  if(points.axes && points.axes.lastCubeProps) {\r\n    cubeAxis = points.axes.lastCubeProps.axis\r\n  } else {\r\n    cubeAxis = [1,1,1]\r\n  }\r\n\r\n  VIEW_SHAPE[0] = 2.0/gl.drawingBufferWidth\r\n  VIEW_SHAPE[1] = 2.0/gl.drawingBufferHeight\r\n\r\n  shader.bind()\r\n  uniforms.view           = view\r\n  uniforms.projection     = projection\r\n  uniforms.screenSize     = VIEW_SHAPE\r\n  uniforms.highlightId    = points.highlightId\r\n  uniforms.highlightScale = points.highlightScale\r\n  uniforms.clipBounds     = clipBounds\r\n  uniforms.pickGroup      = points.pickId / 255.0\r\n  uniforms.pixelRatio     = points.pixelRatio\r\n\r\n  for(var i=0; i<3; ++i) {\r\n    if(!axesProject[i]) {\r\n      continue\r\n    }\r\n    if((points.projectOpacity[i] < 1) !== transparent) {\r\n      continue\r\n    }\r\n\r\n    uniforms.scale          = points.projectScale[i]\r\n    uniforms.opacity        = points.projectOpacity[i]\r\n\r\n    //Project model matrix\r\n    var pmodel = SCRATCH_MATRIX\r\n    for(var j=0; j<16; ++j) {\r\n      pmodel[j] = 0\r\n    }\r\n    for(var j=0; j<4; ++j) {\r\n      pmodel[5*j] = 1\r\n    }\r\n    pmodel[5*i] = 0\r\n    if(cubeAxis[i] < 0) {\r\n      pmodel[12+i] = bounds[0][i]\r\n    } else {\r\n      pmodel[12+i] = bounds[1][i]\r\n    }\r\n    mat4mult(pmodel, model, pmodel)\r\n    uniforms.model = pmodel\r\n\r\n    //Compute initial axes\r\n    var u = (i+1)%3\r\n    var v = (i+2)%3\r\n    var du = zeroVec(U_VEC)\r\n    var dv = zeroVec(V_VEC)\r\n    du[u] = 1\r\n    dv[v] = 1\r\n\r\n    //Align orientation relative to viewer\r\n    var mdu = project(projection, view, model, augment(MU_VEC, du))\r\n    var mdv = project(projection, view, model, augment(MV_VEC, dv))\r\n    if(Math.abs(mdu[1]) > Math.abs(mdv[1])) {\r\n      var tmp = mdu\r\n      mdu = mdv\r\n      mdv = tmp\r\n      tmp = du\r\n      du = dv\r\n      dv = tmp\r\n      var t = u\r\n      u = v\r\n      v = t\r\n    }\r\n    if(mdu[0] < 0) {\r\n      du[u] = -1\r\n    }\r\n    if(mdv[1] > 0) {\r\n      dv[v] = -1\r\n    }\r\n    var su = 0.0\r\n    var sv = 0.0\r\n    for(var j=0; j<4; ++j) {\r\n      su += Math.pow(model[4*u+j], 2)\r\n      sv += Math.pow(model[4*v+j], 2)\r\n    }\r\n    du[u] /= Math.sqrt(su)\r\n    dv[v] /= Math.sqrt(sv)\r\n    uniforms.axes[0] = du\r\n    uniforms.axes[1] = dv\r\n\r\n    //Update fragment clip bounds\r\n    uniforms.fragClipBounds[0] = setComponent(SCRATCH_VEC, clipBounds[0], i, -1e8)\r\n    uniforms.fragClipBounds[1] = setComponent(SCRATCH_VEC, clipBounds[1], i, 1e8)\r\n\r\n    //Draw interior\r\n    points.vao.draw(gl.TRIANGLES, points.vertexCount)\r\n\r\n    //Draw edges\r\n    if(points.lineWidth > 0) {\r\n      gl.lineWidth(points.lineWidth)\r\n      points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount)\r\n    }\r\n  }\r\n}\r\n\r\n\r\nvar NEG_INFINITY3 = [-1e8, -1e8, -1e8]\r\nvar POS_INFINITY3 = [1e8, 1e8, 1e8]\r\nvar CLIP_GROUP    = [NEG_INFINITY3, POS_INFINITY3]\r\n\r\nfunction drawFull(shader, pshader, points, camera, transparent, forceDraw) {\r\n  var gl = points.gl\r\n\r\n  points.vao.bind()\r\n\r\n  if(transparent === (points.opacity < 1) || forceDraw) {\r\n    shader.bind()\r\n    var uniforms = shader.uniforms\r\n\r\n    uniforms.model      = camera.model      || IDENTITY\r\n    uniforms.view       = camera.view       || IDENTITY\r\n    uniforms.projection = camera.projection || IDENTITY\r\n\r\n    VIEW_SHAPE[0]       = 2.0/gl.drawingBufferWidth\r\n    VIEW_SHAPE[1]       = 2.0/gl.drawingBufferHeight\r\n    uniforms.screenSize = VIEW_SHAPE\r\n\r\n    uniforms.highlightId    = points.highlightId\r\n    uniforms.highlightScale = points.highlightScale\r\n\r\n    uniforms.fragClipBounds = CLIP_GROUP\r\n    uniforms.clipBounds     = points.axes.bounds\r\n\r\n    uniforms.opacity    = points.opacity\r\n    uniforms.pickGroup  = points.pickId / 255.0\r\n\r\n    uniforms.pixelRatio = points.pixelRatio\r\n\r\n    //Draw interior\r\n    points.vao.draw(gl.TRIANGLES, points.vertexCount)\r\n\r\n    //Draw edges\r\n    if(points.lineWidth > 0) {\r\n      gl.lineWidth(points.lineWidth)\r\n      points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount)\r\n    }\r\n  }\r\n\r\n  drawProject(pshader, points, camera, transparent, forceDraw)\r\n\r\n  points.vao.unbind()\r\n}\r\n\r\nproto.draw = function(camera) {\r\n  var shader = this.useOrtho ? this.orthoShader : this.shader\r\n  drawFull(shader, this.projectShader, this, camera, false, false)\r\n}\r\n\r\nproto.drawTransparent = function(camera) {\r\n  var shader = this.useOrtho ? this.orthoShader : this.shader\r\n  drawFull(shader, this.projectShader, this, camera, true, false)\r\n}\r\n\r\nproto.drawPick = function(camera) {\r\n  var shader = this.useOrtho ? this.pickOrthoShader : this.pickPerspectiveShader\r\n  drawFull(shader, this.pickProjectShader, this, camera, false, true)\r\n}\r\n\r\nproto.pick = function(selected) {\r\n  if(!selected) {\r\n    return null\r\n  }\r\n  if(selected.id !== this.pickId) {\r\n    return null\r\n  }\r\n  var x = selected.value[2] + (selected.value[1]<<8) + (selected.value[0]<<16)\r\n  if(x >= this.pointCount || x < 0) {\r\n    return null\r\n  }\r\n\r\n  //Unpack result\r\n  var coord = this.points[x]\r\n  var result = this._selectResult\r\n  result.index = x\r\n  for(var i=0; i<3; ++i) {\r\n    result.position[i] = result.dataCoordinate[i] = coord[i]\r\n  }\r\n  return result\r\n}\r\n\r\nproto.highlight = function(selection) {\r\n  if(!selection) {\r\n    this.highlightId = [1,1,1,1]\r\n  } else {\r\n    var pointId = selection.index\r\n    var a0 =  pointId     &0xff\r\n    var a1 = (pointId>>8) &0xff\r\n    var a2 = (pointId>>16)&0xff\r\n    this.highlightId = [a0/255.0, a1/255.0, a2/255.0, 0]\r\n  }\r\n}\r\n\r\nproto.update = function(options) {\r\n\r\n  options = options || {}\r\n\r\n  if('perspective' in options) {\r\n    this.useOrtho = !options.perspective\r\n  }\r\n  if('orthographic' in options) {\r\n    this.useOrtho = !!options.orthographic\r\n  }\r\n  if('lineWidth' in options) {\r\n    this.lineWidth = options.lineWidth\r\n  }\r\n  if('project' in options) {\r\n    if(Array.isArray(options.project)) {\r\n      this.axesProject = options.project\r\n    } else {\r\n      var v = !!options.project\r\n      this.axesProject = [v,v,v]\r\n    }\r\n  }\r\n  if('projectScale' in options) {\r\n    if(Array.isArray(options.projectScale)) {\r\n      this.projectScale = options.projectScale.slice()\r\n    } else {\r\n      var s = +options.projectScale\r\n      this.projectScale = [s,s,s]\r\n    }\r\n  }\r\n  if('projectOpacity' in options) {\r\n    if(Array.isArray(options.projectOpacity)) {\r\n      this.projectOpacity = options.projectOpacity.slice()\r\n    } else {\r\n      var s = +options.projectOpacity\r\n      this.projectOpacity = [s,s,s]\r\n    }\r\n  }\r\n  if('opacity' in options) {\r\n    this.opacity = options.opacity\r\n  }\r\n\r\n  //Set dirty flag\r\n  this.dirty = true\r\n\r\n  //Create new buffers\r\n  var points = options.position\r\n  if(!points) {\r\n    return\r\n  }\r\n\r\n  //Text font\r\n  var font      = options.font      || 'normal'\r\n  var alignment = options.alignment || [0,0]\r\n\r\n  //Bounds\r\n  var lowerBound = [ Infinity, Infinity, Infinity]\r\n  var upperBound = [-Infinity,-Infinity,-Infinity]\r\n\r\n  //Unpack options\r\n  var glyphs     = options.glyph\r\n  var colors     = options.color\r\n  var sizes      = options.size\r\n  var angles     = options.angle\r\n  var lineColors = options.lineColor\r\n\r\n  //Picking geometry\r\n  var pickCounter = 0\r\n\r\n  //First do pass to compute buffer sizes\r\n  var triVertexCount     = 0\r\n  var lineVertexCount = 0\r\n\r\n  //Count number of points and buffer size\r\n  var numPoints   = points.length\r\n\r\ncount_loop:\r\n  for(var i=0; i<numPoints; ++i) {\r\n    var x = points[i]\r\n    for(var j=0; j<3; ++j) {\r\n      if(isNaN(x[j]) || !isFinite(x[j])) {\r\n        continue count_loop\r\n      }\r\n    }\r\n\r\n    var glyphData\r\n    if(Array.isArray(glyphs)) {\r\n      glyphData = getGlyph(glyphs[i], font)\r\n    } else if(glyphs) {\r\n      glyphData = getGlyph(glyphs, font)\r\n    } else {\r\n      glyphData = getGlyph('●', font)\r\n    }\r\n    var glyphMesh   = glyphData[0]\r\n    var glyphLines  = glyphData[1]\r\n    var glyphBounds = glyphData[2]\r\n\r\n    triVertexCount  += glyphMesh.cells.length * 3\r\n    lineVertexCount += glyphLines.edges.length * 2\r\n  }\r\n\r\n\r\n  //Preallocate data\r\n  var vertexCount   = triVertexCount + lineVertexCount\r\n  var positionArray = pool.mallocFloat(3*vertexCount)\r\n  var colorArray    = pool.mallocFloat(4*vertexCount)\r\n  var glyphArray    = pool.mallocFloat(2*vertexCount)\r\n  var idArray       = pool.mallocUint32(vertexCount)\r\n\r\n  var textOffset = [0,alignment[1]]\r\n\r\n  var triOffset  = 0\r\n  var lineOffset = triVertexCount\r\n  var color      = [0,0,0,1]\r\n  var lineColor  = [0,0,0,1]\r\n\r\n  var isColorArray      = Array.isArray(colors)     && Array.isArray(colors[0])\r\n  var isLineColorArray  = Array.isArray(lineColors) && Array.isArray(lineColors[0])\r\n\r\nfill_loop:\r\n  for(var i=0; i<numPoints; ++i) {\r\n    var x = points[i]\r\n    for(var j=0; j<3; ++j) {\r\n      if(isNaN(x[j]) || !isFinite(x[j])) {\r\n        pickCounter += 1\r\n        continue fill_loop\r\n      }\r\n\r\n      upperBound[j] = Math.max(upperBound[j], x[j])\r\n      lowerBound[j] = Math.min(lowerBound[j], x[j])\r\n    }\r\n\r\n    var glyphData\r\n    if(Array.isArray(glyphs)) {\r\n      glyphData = getGlyph(glyphs[i], font)\r\n    } else if(glyphs) {\r\n      glyphData = getGlyph(glyphs, font)\r\n    } else {\r\n      glyphData = getGlyph('●', font)\r\n    }\r\n    var glyphMesh   = glyphData[0]\r\n    var glyphLines  = glyphData[1]\r\n    var glyphBounds = glyphData[2]\r\n\r\n\r\n    //Get color\r\n    if(Array.isArray(colors)) {\r\n      var c\r\n      if(isColorArray) {\r\n        c = colors[i]\r\n      } else {\r\n        c = colors\r\n      }\r\n      if(c.length === 3) {\r\n        for(var j=0; j<3; ++j) {\r\n          color[j] = c[j]\r\n        }\r\n        color[3] = 1\r\n      } else if(c.length === 4) {\r\n        for(var j=0; j<4; ++j) {\r\n          color[j] = c[j]\r\n        }\r\n      }\r\n    } else {\r\n      color[0] = color[1] = color[2] = 0\r\n      color[3] = 1\r\n    }\r\n\r\n    //Get lineColor\r\n    if(Array.isArray(lineColors)) {\r\n      var c\r\n      if(isLineColorArray) {\r\n        c = lineColors[i]\r\n      } else {\r\n        c = lineColors\r\n      }\r\n      if(c.length === 3) {\r\n        for(var j=0; j<3; ++j) {\r\n          lineColor[j] = c[j]\r\n        }\r\n        lineColor[j] = 1\r\n      } else if(c.length === 4) {\r\n        for(var j=0; j<4; ++j) {\r\n          lineColor[j] = c[j]\r\n        }\r\n      }\r\n    } else {\r\n      lineColor[0] = lineColor[1] = lineColor[2] = 0\r\n      lineColor[3] = 1\r\n    }\r\n\r\n    var size = 0.5\r\n    if(Array.isArray(sizes)) {\r\n      size = +sizes[i]\r\n    } else if(sizes) {\r\n      size = +sizes\r\n    } else if(this.useOrtho) {\r\n      size = 12\r\n    }\r\n\r\n    var angle = 0\r\n    if(Array.isArray(angles)) {\r\n      angle = +angles[i]\r\n    } else if(angles) {\r\n      angle = +angles\r\n    }\r\n\r\n    //Loop through markers and append to buffers\r\n    var cos = Math.cos(angle)\r\n    var sin = Math.sin(angle)\r\n\r\n    var x = points[i]\r\n    for(var j=0; j<3; ++j) {\r\n      upperBound[j] = Math.max(upperBound[j], x[j])\r\n      lowerBound[j] = Math.min(lowerBound[j], x[j])\r\n    }\r\n\r\n    //Calculate text offset\r\n    if(alignment[0] < 0) {\r\n      textOffset[0] = alignment[0]  * (1+glyphBounds[1][0])\r\n    } else if(alignment[0] > 0) {\r\n      textOffset[0] = -alignment[0] * (1+glyphBounds[0][0])\r\n    }\r\n\r\n    //Write out inner marker\r\n    var cells = glyphMesh.cells\r\n    var verts = glyphMesh.positions\r\n\r\n    for(var j=0; j<cells.length; ++j) {\r\n      var cell = cells[j]\r\n      for(var k=0; k<3; ++k) {\r\n        for(var l=0; l<3; ++l) {\r\n          positionArray[3*triOffset+l] = x[l]\r\n        }\r\n        for(var l=0; l<4; ++l) {\r\n          colorArray[4*triOffset+l] = color[l]\r\n        }\r\n        idArray[triOffset] = pickCounter\r\n        var p = verts[cell[k]]\r\n        glyphArray[2*triOffset]   = size * (cos*p[0] - sin*p[1] + textOffset[0])\r\n        glyphArray[2*triOffset+1] = size * (sin*p[0] + cos*p[1] + textOffset[1])\r\n        triOffset += 1\r\n      }\r\n    }\r\n\r\n    var cells = glyphLines.edges\r\n    var verts = glyphLines.positions\r\n\r\n    for(var j=0; j<cells.length; ++j) {\r\n      var cell = cells[j]\r\n      for(var k=0; k<2; ++k) {\r\n        for(var l=0; l<3; ++l) {\r\n          positionArray[3*lineOffset+l] = x[l]\r\n        }\r\n        for(var l=0; l<4; ++l) {\r\n          colorArray[4*lineOffset+l] = lineColor[l]\r\n        }\r\n        idArray[lineOffset] = pickCounter\r\n        var p = verts[cell[k]]\r\n        glyphArray[2*lineOffset]   = size * (cos*p[0] - sin*p[1] + textOffset[0])\r\n        glyphArray[2*lineOffset+1] = size * (sin*p[0] + cos*p[1] + textOffset[1])\r\n        lineOffset += 1\r\n      }\r\n    }\r\n\r\n    //Increment pickCounter\r\n    pickCounter += 1\r\n  }\r\n\r\n\r\n  //Update vertex counts\r\n  this.vertexCount      = triVertexCount\r\n  this.lineVertexCount  = lineVertexCount\r\n\r\n  //Update buffers\r\n  this.pointBuffer.update(positionArray)\r\n  this.colorBuffer.update(colorArray)\r\n  this.glyphBuffer.update(glyphArray)\r\n  this.idBuffer.update(new Uint32Array(idArray))\r\n\r\n  pool.free(positionArray)\r\n  pool.free(colorArray)\r\n  pool.free(glyphArray)\r\n  pool.free(idArray)\r\n\r\n  //Update bounds\r\n  this.bounds = [lowerBound, upperBound]\r\n\r\n  //Save points\r\n  this.points = points\r\n\r\n  //Save number of points\r\n  this.pointCount = points.length\r\n}\r\n\r\nproto.dispose = function() {\r\n  //Shaders\r\n  this.shader.dispose()\r\n  this.orthoShader.dispose()\r\n  this.pickPerspectiveShader.dispose()\r\n  this.pickOrthoShader.dispose()\r\n\r\n  //Vertex array\r\n  this.vao.dispose()\r\n\r\n  //Buffers\r\n  this.pointBuffer.dispose()\r\n  this.colorBuffer.dispose()\r\n  this.glyphBuffer.dispose()\r\n  this.idBuffer.dispose()\r\n}\r\n\r\nfunction createPointCloud(options) {\r\n  var gl = options.gl\r\n\r\n  var shader                = shaders.createPerspective(gl)\r\n  var orthoShader           = shaders.createOrtho(gl)\r\n  var projectShader         = shaders.createProject(gl)\r\n  var pickPerspectiveShader = shaders.createPickPerspective(gl)\r\n  var pickOrthoShader       = shaders.createPickOrtho(gl)\r\n  var pickProjectShader     = shaders.createPickProject(gl)\r\n\r\n  var pointBuffer = createBuffer(gl)\r\n  var colorBuffer = createBuffer(gl)\r\n  var glyphBuffer = createBuffer(gl)\r\n  var idBuffer    = createBuffer(gl)\r\n  var vao = createVAO(gl, [\r\n    {\r\n      buffer: pointBuffer,\r\n      size: 3,\r\n      type: gl.FLOAT\r\n    },\r\n    {\r\n      buffer: colorBuffer,\r\n      size: 4,\r\n      type: gl.FLOAT\r\n    },\r\n    {\r\n      buffer: glyphBuffer,\r\n      size: 2,\r\n      type: gl.FLOAT\r\n    },\r\n    {\r\n      buffer: idBuffer,\r\n      size: 4,\r\n      type: gl.UNSIGNED_BYTE,\r\n      normalized: true\r\n    }\r\n  ])\r\n\r\n  var pointCloud = new PointCloud(\r\n    gl,\r\n    shader,\r\n    orthoShader,\r\n    projectShader,\r\n    pointBuffer,\r\n    colorBuffer,\r\n    glyphBuffer,\r\n    idBuffer,\r\n    vao,\r\n    pickPerspectiveShader,\r\n    pickOrthoShader,\r\n    pickProjectShader)\r\n\r\n  pointCloud.update(options)\r\n\r\n  return pointCloud\r\n}\r\n",null]}