{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/parcoords/lines.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/parcoords/lines.js","mtime":1529418310727},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar glslify = require('glslify');\nvar vertexShaderSource = glslify('./shaders/vertex.glsl');\nvar contextShaderSource = glslify('./shaders/context_vertex.glsl');\nvar pickVertexShaderSource = glslify('./shaders/pick_vertex.glsl');\nvar fragmentShaderSource = glslify('./shaders/fragment.glsl');\n\nvar Lib = require('../../lib');\n\n// don't change; otherwise near/far plane lines are lost\nvar depthLimitEpsilon = 1e-6;\n// just enough buffer for an extra bit at single-precision floating point\n// which on [0, 1] is 6e-8 (1/2^24)\nvar filterEpsilon = 1e-7;\n\n// precision of multiselect is the full range divided into this many parts\nvar maskHeight = 2048;\n\nvar gpuDimensionCount = 64;\nvar sectionVertexCount = 2;\nvar vec4NumberCount = 4;\nvar bitsPerByte = 8;\nvar channelCount = gpuDimensionCount / bitsPerByte; // == 8 bytes needed to have 64 bits\n\nvar contextColor = [119, 119, 119]; // middle gray to not drawn the focus; looks good on a black or white background\n\nvar dummyPixel = new Uint8Array(4);\nvar pickPixel = new Uint8Array(4);\n\nvar paletteTextureConfig = {\n    shape: [256, 1],\n    format: 'rgba',\n    type: 'uint8',\n    mag: 'nearest',\n    min: 'nearest'\n};\n\nfunction ensureDraw(regl) {\n    regl.read({\n        x: 0,\n        y: 0,\n        width: 1,\n        height: 1,\n        data: dummyPixel\n    });\n}\n\nfunction clear(regl, x, y, width, height) {\n    var gl = regl._gl;\n    gl.enable(gl.SCISSOR_TEST);\n    gl.scissor(x, y, width, height);\n    regl.clear({color: [0, 0, 0, 0], depth: 1}); // clearing is done in scissored panel only\n}\n\nfunction renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item) {\n\n    var rafKey = item.key;\n\n    function render(blockNumber) {\n\n        var count;\n\n        count = Math.min(blockLineCount, sampleCount - blockNumber * blockLineCount);\n\n        item.offset = sectionVertexCount * blockNumber * blockLineCount;\n        item.count = sectionVertexCount * count;\n        if(blockNumber === 0) {\n            // stop drawing possibly stale glyphs before clearing\n            window.cancelAnimationFrame(renderState.currentRafs[rafKey]);\n            delete renderState.currentRafs[rafKey];\n            clear(regl, item.scissorX, item.scissorY, item.scissorWidth, item.viewBoxSize[1]);\n        }\n\n        if(renderState.clearOnly) {\n            return;\n        }\n\n        glAes(item);\n\n        if(blockNumber * blockLineCount + count < sampleCount) {\n            renderState.currentRafs[rafKey] = window.requestAnimationFrame(function() {\n                render(blockNumber + 1);\n            });\n        }\n\n        renderState.drawCompleted = false;\n    }\n\n    if(!renderState.drawCompleted) {\n        ensureDraw(regl);\n        renderState.drawCompleted = true;\n    }\n\n    // start with rendering item 0; recursion handles the rest\n    render(0);\n}\n\nfunction adjustDepth(d) {\n    // WebGL matrix operations use floats with limited precision, potentially causing a number near a border of [0, 1]\n    // to end up slightly outside the border. With an epsilon, we reduce the chance that a line gets clipped by the\n    // near or the far plane.\n    return Math.max(depthLimitEpsilon, Math.min(1 - depthLimitEpsilon, d));\n}\n\nfunction palette(unitToColor, context, opacity) {\n    var result = [];\n    for(var j = 0; j < 256; j++) {\n        var c = unitToColor(j / 255);\n        result.push((context ? contextColor : c).concat(opacity));\n    }\n\n    return result;\n}\n\n// Maps the sample index [0...sampleCount - 1] to a range of [0, 1] as the shader expects colors in the [0, 1] range.\n// but first it shifts the sample index by 0, 8 or 16 bits depending on rgbIndex [0..2]\n// with the end result that each line will be of a unique color, making it possible for the pick handler\n// to uniquely identify which line is hovered over (bijective mapping).\n// The inverse, i.e. readPixel is invoked from 'parcoords.js'\nfunction calcPickColor(j, rgbIndex) {\n    return (j >>> 8 * rgbIndex) % 256 / 255;\n}\n\nfunction makePoints(sampleCount, dimensions, color) {\n    var dimensionCount = dimensions.length;\n\n    var points = [];\n    for(var j = 0; j < sampleCount; j++) {\n        for(var i = 0; i < gpuDimensionCount; i++) {\n            points.push(i < dimensionCount ?\n                dimensions[i].paddedUnitValues[j] :\n                i === (gpuDimensionCount - 1) ?\n                    adjustDepth(color[j]) :\n                    i >= gpuDimensionCount - 4 ?\n                        calcPickColor(j, gpuDimensionCount - 2 - i) :\n                        0.5);\n        }\n    }\n\n    return points;\n}\n\nfunction makeVecAttr(sampleCount, points, vecIndex) {\n    var i, j, k;\n    var pointPairs = [];\n\n    for(j = 0; j < sampleCount; j++) {\n        for(k = 0; k < sectionVertexCount; k++) {\n            for(i = 0; i < vec4NumberCount; i++) {\n                pointPairs.push(points[j * gpuDimensionCount + vecIndex * vec4NumberCount + i]);\n                if(vecIndex * vec4NumberCount + i === gpuDimensionCount - 1 && k % 2 === 0) {\n                    pointPairs[pointPairs.length - 1] *= -1;\n                }\n            }\n        }\n    }\n\n    return pointPairs;\n}\n\nfunction setAttributes(attributes, sampleCount, points) {\n    for(var i = 0; i < 16; i++) {\n        attributes['p' + i.toString(16)](makeVecAttr(sampleCount, points, i));\n    }\n}\n\nfunction emptyAttributes(regl) {\n    var attributes = {};\n    for(var i = 0; i < 16; i++) {\n        attributes['p' + i.toString(16)] = regl.buffer({usage: 'dynamic', type: 'float', data: new Uint8Array(0)});\n    }\n    return attributes;\n}\n\nmodule.exports = function(canvasGL, d) {\n    // context & pick describe which canvas we're talking about - won't change with new data\n    var context = d.context;\n    var pick = d.pick;\n\n    var regl = d.regl;\n\n    var renderState = {\n        currentRafs: {},\n        drawCompleted: true,\n        clearOnly: false\n    };\n\n    // state to be set by update and used later\n    var model;\n    var vm;\n    var initialDims;\n    var sampleCount;\n    var attributes = emptyAttributes(regl);\n    var maskTexture;\n    var paletteTexture = regl.texture(paletteTextureConfig);\n\n    update(d);\n\n    var glAes = regl({\n\n        profile: false,\n\n        blend: {\n            enable: context,\n            func: {\n                srcRGB: 'src alpha',\n                dstRGB: 'one minus src alpha',\n                srcAlpha: 1,\n                dstAlpha: 1 // 'one minus src alpha'\n            },\n            equation: {\n                rgb: 'add',\n                alpha: 'add'\n            },\n            color: [0, 0, 0, 0]\n        },\n\n        depth: {\n            enable: !context,\n            mask: true,\n            func: 'less',\n            range: [0, 1]\n        },\n\n        // for polygons\n        cull: {\n            enable: true,\n            face: 'back'\n        },\n\n        scissor: {\n            enable: true,\n            box: {\n                x: regl.prop('scissorX'),\n                y: regl.prop('scissorY'),\n                width: regl.prop('scissorWidth'),\n                height: regl.prop('scissorHeight')\n            }\n        },\n\n        viewport: {\n            x: regl.prop('viewportX'),\n            y: regl.prop('viewportY'),\n            width: regl.prop('viewportWidth'),\n            height: regl.prop('viewportHeight')\n        },\n\n        dither: false,\n\n        vert: pick ? pickVertexShaderSource : context ? contextShaderSource : vertexShaderSource,\n\n        frag: fragmentShaderSource,\n\n        primitive: 'lines',\n        lineWidth: 1,\n        attributes: attributes,\n        uniforms: {\n            resolution: regl.prop('resolution'),\n            viewBoxPosition: regl.prop('viewBoxPosition'),\n            viewBoxSize: regl.prop('viewBoxSize'),\n            dim1A: regl.prop('dim1A'),\n            dim2A: regl.prop('dim2A'),\n            dim1B: regl.prop('dim1B'),\n            dim2B: regl.prop('dim2B'),\n            dim1C: regl.prop('dim1C'),\n            dim2C: regl.prop('dim2C'),\n            dim1D: regl.prop('dim1D'),\n            dim2D: regl.prop('dim2D'),\n            loA: regl.prop('loA'),\n            hiA: regl.prop('hiA'),\n            loB: regl.prop('loB'),\n            hiB: regl.prop('hiB'),\n            loC: regl.prop('loC'),\n            hiC: regl.prop('hiC'),\n            loD: regl.prop('loD'),\n            hiD: regl.prop('hiD'),\n            palette: paletteTexture,\n            mask: regl.prop('maskTexture'),\n            maskHeight: regl.prop('maskHeight'),\n            colorClamp: regl.prop('colorClamp')\n        },\n        offset: regl.prop('offset'),\n        count: regl.prop('count')\n    });\n\n    function update(dNew) {\n        model = dNew.model;\n        vm = dNew.viewModel;\n        initialDims = vm.dimensions.slice();\n        sampleCount = initialDims[0] ? initialDims[0].values.length : 0;\n\n        var lines = model.lines;\n        var color = pick ? lines.color.map(function(_, i) {return i / lines.color.length;}) : lines.color;\n        var contextOpacity = Math.max(1 / 255, Math.pow(1 / color.length, 1 / 3));\n\n        var points = makePoints(sampleCount, initialDims, color);\n        setAttributes(attributes, sampleCount, points);\n\n        paletteTexture = regl.texture(Lib.extendFlat({\n            data: palette(model.unitToColor, context, Math.round((context ? contextOpacity : 1) * 255))\n        }, paletteTextureConfig));\n    }\n\n    var colorClamp = [0, 1];\n\n    function setColorDomain(unitDomain) {\n        colorClamp[0] = unitDomain[0];\n        colorClamp[1] = unitDomain[1];\n    }\n\n    var previousAxisOrder = [];\n\n    function makeItem(i, ii, x, y, panelSizeX, canvasPanelSizeY, crossfilterDimensionIndex, I, leftmost, rightmost, constraints) {\n        var loHi, abcd, d, index;\n        var leftRight = [i, ii];\n\n        var dims = [0, 1].map(function() {return [0, 1, 2, 3].map(function() {return new Float32Array(16);});});\n\n        for(loHi = 0; loHi < 2; loHi++) {\n            index = leftRight[loHi];\n            for(abcd = 0; abcd < 4; abcd++) {\n                for(d = 0; d < 16; d++) {\n                    dims[loHi][abcd][d] = d + 16 * abcd === index ? 1 : 0;\n                }\n            }\n        }\n\n        var overdrag = model.lines.canvasOverdrag;\n        var domain = model.domain;\n        var canvasWidth = model.canvasWidth;\n        var canvasHeight = model.canvasHeight;\n\n        var itemModel = Lib.extendFlat({\n            key: crossfilterDimensionIndex,\n            resolution: [canvasWidth, canvasHeight],\n            viewBoxPosition: [x + overdrag, y],\n            viewBoxSize: [panelSizeX, canvasPanelSizeY],\n            i: i,\n            ii: ii,\n\n            dim1A: dims[0][0],\n            dim1B: dims[0][1],\n            dim1C: dims[0][2],\n            dim1D: dims[0][3],\n            dim2A: dims[1][0],\n            dim2B: dims[1][1],\n            dim2C: dims[1][2],\n            dim2D: dims[1][3],\n\n            colorClamp: colorClamp,\n\n            scissorX: (I === leftmost ? 0 : x + overdrag) + (model.pad.l - overdrag) + model.layoutWidth * domain.x[0],\n            scissorWidth: (I === rightmost ? canvasWidth - x + overdrag : panelSizeX + 0.5) + (I === leftmost ? x + overdrag : 0),\n            scissorY: y + model.pad.b + model.layoutHeight * domain.y[0],\n            scissorHeight: canvasPanelSizeY,\n\n            viewportX: model.pad.l - overdrag + model.layoutWidth * domain.x[0],\n            viewportY: model.pad.b + model.layoutHeight * domain.y[0],\n            viewportWidth: canvasWidth,\n            viewportHeight: canvasHeight\n        }, constraints);\n\n        return itemModel;\n    }\n\n    function makeConstraints() {\n        var loHi, abcd, d;\n\n        var lims = [0, 1].map(function() {return [0, 1, 2, 3].map(function() {return new Float32Array(16);});});\n\n        for(loHi = 0; loHi < 2; loHi++) {\n            for(abcd = 0; abcd < 4; abcd++) {\n                for(d = 0; d < 16; d++) {\n                    var dimP = d + 16 * abcd;\n                    var lim;\n                    if(dimP < initialDims.length) {\n                        lim = initialDims[dimP].brush.filter.getBounds()[loHi];\n                    }\n                    else lim = loHi;\n                    lims[loHi][abcd][d] = lim + (2 * loHi - 1) * filterEpsilon;\n                }\n            }\n        }\n\n        function expandedPixelRange(dim, bounds) {\n            var maskHMinus = maskHeight - 1;\n            return [\n                Math.max(0, Math.floor(bounds[0] * maskHMinus)),\n                Math.min(maskHMinus, Math.ceil(bounds[1] * maskHMinus))\n            ];\n        }\n\n        var mask = Array.apply(null, new Array(maskHeight * channelCount)).map(function() {\n            return 255;\n        });\n        for(var dimIndex = 0; dimIndex < initialDims.length; dimIndex++) {\n            var bitIndex = dimIndex % bitsPerByte;\n            var byteIndex = (dimIndex - bitIndex) / bitsPerByte;\n            var bitMask = Math.pow(2, bitIndex);\n            var dim = initialDims[dimIndex];\n            var ranges = dim.brush.filter.get();\n            if(ranges.length < 2) continue; // bail if the bounding box based filter is sufficient\n\n            var prevEnd = expandedPixelRange(dim, ranges[0])[1];\n            for(var ri = 1; ri < ranges.length; ri++) {\n                var nextRange = expandedPixelRange(dim, ranges[ri]);\n                for(var pi = prevEnd + 1; pi < nextRange[0]; pi++) {\n                    mask[pi * channelCount + byteIndex] &= ~bitMask;\n                }\n                prevEnd = Math.max(prevEnd, nextRange[1]);\n            }\n        }\n\n        var textureData = {\n            // 8 units x 8 bits = 64 bits, just sufficient for the almost 64 dimensions we support\n            shape: [channelCount, maskHeight],\n            format: 'alpha',\n            type: 'uint8',\n            mag: 'nearest',\n            min: 'nearest',\n            data: mask\n        };\n        if(maskTexture) maskTexture(textureData);\n        else maskTexture = regl.texture(textureData);\n\n        return {\n            maskTexture: maskTexture,\n            maskHeight: maskHeight,\n            loA: lims[0][0],\n            loB: lims[0][1],\n            loC: lims[0][2],\n            loD: lims[0][3],\n            hiA: lims[1][0],\n            hiB: lims[1][1],\n            hiC: lims[1][2],\n            hiD: lims[1][3]\n        };\n    }\n\n    function renderGLParcoords(panels, setChanged, clearOnly) {\n        var panelCount = panels.length;\n        var I;\n\n        var leftmost, rightmost, lowestX = Infinity, highestX = -Infinity;\n\n        for(I = 0; I < panelCount; I++) {\n            if(panels[I].dim2.canvasX > highestX) {\n                highestX = panels[I].dim2.canvasX;\n                rightmost = I;\n            }\n            if(panels[I].dim1.canvasX < lowestX) {\n                lowestX = panels[I].dim1.canvasX;\n                leftmost = I;\n            }\n        }\n\n        if(panelCount === 0) {\n            // clear canvas here, as the panel iteration below will not enter the loop body\n            clear(regl, 0, 0, model.canvasWidth, model.canvasHeight);\n        }\n        var constraints = context ? {} : makeConstraints();\n\n        for(I = 0; I < panelCount; I++) {\n            var panel = panels[I];\n            var dim1 = panel.dim1;\n            var i = dim1.crossfilterDimensionIndex;\n            var x = panel.canvasX;\n            var y = panel.canvasY;\n            var dim2 = panel.dim2;\n            var ii = dim2.crossfilterDimensionIndex;\n            var panelSizeX = panel.panelSizeX;\n            var panelSizeY = panel.panelSizeY;\n            var xTo = x + panelSizeX;\n            if(setChanged || !previousAxisOrder[i] || previousAxisOrder[i][0] !== x || previousAxisOrder[i][1] !== xTo) {\n                previousAxisOrder[i] = [x, xTo];\n                var item = makeItem(i, ii, x, y, panelSizeX, panelSizeY, dim1.crossfilterDimensionIndex, I, leftmost, rightmost, constraints);\n                renderState.clearOnly = clearOnly;\n                renderBlock(regl, glAes, renderState, setChanged ? model.lines.blockLineCount : sampleCount, sampleCount, item);\n            }\n        }\n    }\n\n    function readPixel(canvasX, canvasY) {\n        regl.read({\n            x: canvasX,\n            y: canvasY,\n            width: 1,\n            height: 1,\n            data: pickPixel\n        });\n        return pickPixel;\n    }\n\n    function readPixels(canvasX, canvasY, width, height) {\n        var pixelArray = new Uint8Array(4 * width * height);\n        regl.read({\n            x: canvasX,\n            y: canvasY,\n            width: width,\n            height: height,\n            data: pixelArray\n        });\n        return pixelArray;\n    }\n\n    function destroy() {\n        canvasGL.style['pointer-events'] = 'none';\n        paletteTexture.destroy();\n        if(maskTexture) maskTexture.destroy();\n        for(var k in attributes) attributes[k].destroy();\n    }\n\n    return {\n        setColorDomain: setColorDomain,\n        render: renderGLParcoords,\n        readPixel: readPixel,\n        readPixels: readPixels,\n        destroy: destroy,\n        update: update\n    };\n};\n",null]}