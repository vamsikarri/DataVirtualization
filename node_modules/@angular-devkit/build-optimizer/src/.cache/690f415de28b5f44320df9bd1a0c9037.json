{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scattermapbox/convert.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scattermapbox/convert.js","mtime":1529418310742},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar geoJsonUtils = require('../../lib/geojson_utils');\n\nvar Colorscale = require('../../components/colorscale');\nvar Drawing = require('../../components/drawing');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\nvar subTypes = require('../scatter/subtypes');\nvar convertTextOpts = require('../../plots/mapbox/convert_text_opts');\n\nmodule.exports = function convert(calcTrace) {\n    var trace = calcTrace[0].trace;\n\n    var isVisible = (trace.visible === true);\n    var hasFill = (trace.fill !== 'none');\n    var hasLines = subTypes.hasLines(trace);\n    var hasMarkers = subTypes.hasMarkers(trace);\n    var hasText = subTypes.hasText(trace);\n    var hasCircles = (hasMarkers && trace.marker.symbol === 'circle');\n    var hasSymbols = (hasMarkers && trace.marker.symbol !== 'circle');\n\n    var fill = initContainer();\n    var line = initContainer();\n    var circle = initContainer();\n    var symbol = initContainer();\n\n    var opts = {\n        fill: fill,\n        line: line,\n        circle: circle,\n        symbol: symbol\n    };\n\n    // early return if not visible or placeholder\n    if(!isVisible) return opts;\n\n    // fill layer and line layer use the same coords\n    var lineCoords;\n    if(hasFill || hasLines) {\n        lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n    }\n\n    if(hasFill) {\n        fill.geojson = geoJsonUtils.makePolygon(lineCoords);\n        fill.layout.visibility = 'visible';\n\n        Lib.extendFlat(fill.paint, {\n            'fill-color': trace.fillcolor\n        });\n    }\n\n    if(hasLines) {\n        line.geojson = geoJsonUtils.makeLine(lineCoords);\n        line.layout.visibility = 'visible';\n\n        Lib.extendFlat(line.paint, {\n            'line-width': trace.line.width,\n            'line-color': trace.line.color,\n            'line-opacity': trace.opacity\n        });\n\n        // TODO convert line.dash into line-dasharray\n    }\n\n    if(hasCircles) {\n        var circleOpts = makeCircleOpts(calcTrace);\n        circle.geojson = circleOpts.geojson;\n        circle.layout.visibility = 'visible';\n\n        Lib.extendFlat(circle.paint, {\n            'circle-color': circleOpts.mcc,\n            'circle-radius': circleOpts.mrc,\n            'circle-opacity': circleOpts.mo\n        });\n    }\n\n    if(hasSymbols || hasText) {\n        symbol.geojson = makeSymbolGeoJSON(calcTrace);\n\n        Lib.extendFlat(symbol.layout, {\n            visibility: 'visible',\n            'icon-image': '{symbol}-15',\n            'text-field': '{text}'\n        });\n\n        if(hasSymbols) {\n            Lib.extendFlat(symbol.layout, {\n                'icon-size': trace.marker.size / 10\n            });\n\n            Lib.extendFlat(symbol.paint, {\n                'icon-opacity': trace.opacity * trace.marker.opacity,\n\n                // TODO does not work ??\n                'icon-color': trace.marker.color\n            });\n        }\n\n        if(hasText) {\n            var iconSize = (trace.marker || {}).size,\n                textOpts = convertTextOpts(trace.textposition, iconSize);\n\n            // all data-driven below !!\n\n            Lib.extendFlat(symbol.layout, {\n                'text-size': trace.textfont.size,\n                'text-anchor': textOpts.anchor,\n                'text-offset': textOpts.offset\n\n                // TODO font family\n                // 'text-font': symbol.textfont.family.split(', '),\n            });\n\n            Lib.extendFlat(symbol.paint, {\n                'text-color': trace.textfont.color,\n                'text-opacity': trace.opacity\n            });\n        }\n    }\n\n    return opts;\n};\n\nfunction initContainer() {\n    return {\n        geojson: geoJsonUtils.makeBlank(),\n        layout: { visibility: 'none' },\n        paint: {}\n    };\n}\n\nfunction makeCircleOpts(calcTrace) {\n    var trace = calcTrace[0].trace;\n    var marker = trace.marker;\n    var selectedpoints = trace.selectedpoints;\n    var arrayColor = Lib.isArrayOrTypedArray(marker.color);\n    var arraySize = Lib.isArrayOrTypedArray(marker.size);\n    var arrayOpacity = Lib.isArrayOrTypedArray(marker.opacity);\n    var i;\n\n    function addTraceOpacity(o) { return trace.opacity * o; }\n\n    function size2radius(s) { return s / 2; }\n\n    var colorFn;\n    if(arrayColor) {\n        if(Colorscale.hasColorscale(trace, 'marker')) {\n            colorFn = Colorscale.makeColorScaleFunc(\n                 Colorscale.extractScale(marker.colorscale, marker.cmin, marker.cmax)\n             );\n        } else {\n            colorFn = Lib.identity;\n        }\n    }\n\n    var sizeFn;\n    if(arraySize) {\n        sizeFn = makeBubbleSizeFn(trace);\n    }\n\n    var opacityFn;\n    if(arrayOpacity) {\n        opacityFn = function(mo) {\n            var mo2 = isNumeric(mo) ? +Lib.constrain(mo, 0, 1) : 0;\n            return addTraceOpacity(mo2);\n        };\n    }\n\n    var features = [];\n    for(i = 0; i < calcTrace.length; i++) {\n        var calcPt = calcTrace[i];\n        var lonlat = calcPt.lonlat;\n\n        if(isBADNUM(lonlat)) continue;\n\n        var props = {};\n        if(colorFn) props.mcc = calcPt.mcc = colorFn(calcPt.mc);\n        if(sizeFn) props.mrc = calcPt.mrc = sizeFn(calcPt.ms);\n        if(opacityFn) props.mo = opacityFn(calcPt.mo);\n        if(selectedpoints) props.selected = calcPt.selected || 0;\n\n        features.push({\n            type: 'Feature',\n            geometry: {type: 'Point', coordinates: lonlat},\n            properties: props\n        });\n    }\n\n    var fns;\n    if(selectedpoints) {\n        fns = Drawing.makeSelectedPointStyleFns(trace);\n\n        for(i = 0; i < features.length; i++) {\n            var d = features[i].properties;\n\n            if(fns.selectedOpacityFn) {\n                d.mo = addTraceOpacity(fns.selectedOpacityFn(d));\n            }\n            if(fns.selectedColorFn) {\n                d.mcc = fns.selectedColorFn(d);\n            }\n            if(fns.selectedSizeFn) {\n                d.mrc = fns.selectedSizeFn(d);\n            }\n        }\n    }\n\n    return {\n        geojson: {type: 'FeatureCollection', features: features},\n        mcc: arrayColor || (fns && fns.selectedColorFn) ?\n            {type: 'identity', property: 'mcc'} :\n            marker.color,\n        mrc: arraySize || (fns && fns.selectedSizeFn) ?\n            {type: 'identity', property: 'mrc'} :\n            size2radius(marker.size),\n        mo: arrayOpacity || (fns && fns.selectedOpacityFn) ?\n            {type: 'identity', property: 'mo'} :\n            addTraceOpacity(marker.opacity)\n    };\n}\n\nfunction makeSymbolGeoJSON(calcTrace) {\n    var trace = calcTrace[0].trace;\n\n    var marker = trace.marker || {},\n        symbol = marker.symbol,\n        text = trace.text;\n\n    var fillSymbol = (symbol !== 'circle') ?\n            getFillFunc(symbol) :\n            blankFillFunc;\n\n    var fillText = subTypes.hasText(trace) ?\n            getFillFunc(text) :\n            blankFillFunc;\n\n    var features = [];\n\n    for(var i = 0; i < calcTrace.length; i++) {\n        var calcPt = calcTrace[i];\n\n        if(isBADNUM(calcPt.lonlat)) continue;\n\n        features.push({\n            type: 'Feature',\n            geometry: {\n                type: 'Point',\n                coordinates: calcPt.lonlat\n            },\n            properties: {\n                symbol: fillSymbol(calcPt.mx),\n                text: fillText(calcPt.tx)\n            }\n        });\n    }\n\n    return {\n        type: 'FeatureCollection',\n        features: features\n    };\n}\n\nfunction getFillFunc(attr) {\n    if(Lib.isArrayOrTypedArray(attr)) {\n        return function(v) { return v; };\n    }\n    else if(attr) {\n        return function() { return attr; };\n    }\n    else {\n        return blankFillFunc;\n    }\n}\n\nfunction blankFillFunc() { return ''; }\n\n// only need to check lon (OR lat)\nfunction isBADNUM(lonlat) {\n    return lonlat[0] === BADNUM;\n}\n",null]}