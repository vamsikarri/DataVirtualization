{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/strongly-connected-components/scc.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/strongly-connected-components/scc.js","mtime":1529418312102},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["\"use strict\"\n\nmodule.exports = stronglyConnectedComponents\n\nfunction stronglyConnectedComponents(adjList) {\n  var numVertices = adjList.length;\n  var index = new Array(numVertices)\n  var lowValue = new Array(numVertices)\n  var active = new Array(numVertices)\n  var child = new Array(numVertices)\n  var scc = new Array(numVertices)\n  var sccLinks = new Array(numVertices)\n  \n  //Initialize tables\n  for(var i=0; i<numVertices; ++i) {\n    index[i] = -1\n    lowValue[i] = 0\n    active[i] = false\n    child[i] = 0\n    scc[i] = -1\n    sccLinks[i] = []\n  }\n\n  // The strongConnect function\n  var count = 0\n  var components = []\n  var sccAdjList = []\n\n  function strongConnect(v) {\n    // To avoid running out of stack space, this emulates the recursive behaviour of the normal algorithm, effectively using T as the call stack.\n    var S = [v], T = [v]\n    index[v] = lowValue[v] = count\n    active[v] = true\n    count += 1\n    while(T.length > 0) {\n      v = T[T.length-1]\n      var e = adjList[v]\n      if (child[v] < e.length) { // If we're not done iterating over the children, first try finishing that.\n        for(var i=child[v]; i<e.length; ++i) { // Start where we left off.\n          var u = e[i]\n          if(index[u] < 0) {\n            index[u] = lowValue[u] = count\n            active[u] = true\n            count += 1\n            S.push(u)\n            T.push(u)\n            break // First recurse, then continue here (with the same child!).\n            // There is a slight change to Tarjan's algorithm here.\n            // Normally, after having recursed, we set lowValue like we do for an active child (although some variants of the algorithm do it slightly differently).\n            // Here, we only do so if the child we recursed on is still active.\n            // The reasoning is that if it is no longer active, it must have had a lowValue equal to its own index, which means that it is necessarily higher than our lowValue.\n          } else if (active[u]) {\n            lowValue[v] = Math.min(lowValue[v], lowValue[u])|0\n          }\n          if (scc[u] >= 0) {\n            // Node v is not yet assigned an scc, but once it is that scc can apparently reach scc[u].\n            sccLinks[v].push(scc[u])\n          }\n        }\n        child[v] = i // Remember where we left off.\n      } else { // If we're done iterating over the children, check whether we have an scc.\n        if(lowValue[v] === index[v]) { // TODO: It /might/ be true that T is always a prefix of S (at this point!!!), and if so, this could be used here.\n          var component = []\n          var links = [], linkCount = 0\n          for(var i=S.length-1; i>=0; --i) {\n            var w = S[i]\n            active[w] = false\n            component.push(w)\n            links.push(sccLinks[w])\n            linkCount += sccLinks[w].length\n            scc[w] = components.length\n            if(w === v) {\n              S.length = i\n              break\n            }\n          }\n          components.push(component)\n          var allLinks = new Array(linkCount)\n          for(var i=0; i<links.length; i++) {\n            for(var j=0; j<links[i].length; j++) {\n              allLinks[--linkCount] = links[i][j]\n            }\n          }\n          sccAdjList.push(allLinks)\n        }\n        T.pop() // Now we're finished exploring this particular node (normally corresponds to the return statement)\n      }\n    }\n  }\n\n  //Run strong connect starting from each vertex\n  for(var i=0; i<numVertices; ++i) {\n    if(index[i] < 0) {\n      strongConnect(i)\n    }\n  }\n  \n  // Compact sccAdjList\n  var newE\n  for(var i=0; i<sccAdjList.length; i++) {\n    var e = sccAdjList[i]\n    if (e.length === 0) continue\n    e.sort(function (a,b) { return a-b; })\n    newE = [e[0]]\n    for(var j=1; j<e.length; j++) {\n      if (e[j] !== e[j-1]) {\n        newE.push(e[j])\n      }\n    }\n    sccAdjList[i] = newE\n  }  \n\n  return {components: components, adjacencyList: sccAdjList}\n}\n",null]}