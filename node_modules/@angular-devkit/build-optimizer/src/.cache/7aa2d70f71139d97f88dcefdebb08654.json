{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/bar/set_positions.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/bar/set_positions.js","mtime":1529418310701},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nmodule.exports = function setPositions(gd, plotinfo) {\n    var xa = plotinfo.xaxis,\n        ya = plotinfo.yaxis;\n\n    var fullTraces = gd._fullData,\n        calcTraces = gd.calcdata,\n        calcTracesHorizontal = [],\n        calcTracesVertical = [],\n        i;\n    for(i = 0; i < fullTraces.length; i++) {\n        var fullTrace = fullTraces[i];\n        if(\n            fullTrace.visible === true &&\n            Registry.traceIs(fullTrace, 'bar') &&\n            fullTrace.xaxis === xa._id &&\n            fullTrace.yaxis === ya._id\n        ) {\n            if(fullTrace.orientation === 'h') {\n                calcTracesHorizontal.push(calcTraces[i]);\n            }\n            else {\n                calcTracesVertical.push(calcTraces[i]);\n            }\n        }\n    }\n\n    setGroupPositions(gd, xa, ya, calcTracesVertical);\n    setGroupPositions(gd, ya, xa, calcTracesHorizontal);\n};\n\n\nfunction setGroupPositions(gd, pa, sa, calcTraces) {\n    if(!calcTraces.length) return;\n\n    var barmode = gd._fullLayout.barmode,\n        overlay = (barmode === 'overlay'),\n        group = (barmode === 'group'),\n        excluded,\n        included,\n        i, calcTrace, fullTrace;\n\n    if(overlay) {\n        setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces);\n    }\n    else if(group) {\n        // exclude from the group those traces for which the user set an offset\n        excluded = [];\n        included = [];\n        for(i = 0; i < calcTraces.length; i++) {\n            calcTrace = calcTraces[i];\n            fullTrace = calcTrace[0].trace;\n\n            if(fullTrace.offset === undefined) included.push(calcTrace);\n            else excluded.push(calcTrace);\n        }\n\n        if(included.length) {\n            setGroupPositionsInGroupMode(gd, pa, sa, included);\n        }\n        if(excluded.length) {\n            setGroupPositionsInOverlayMode(gd, pa, sa, excluded);\n        }\n    }\n    else {\n        // exclude from the stack those traces for which the user set a base\n        excluded = [];\n        included = [];\n        for(i = 0; i < calcTraces.length; i++) {\n            calcTrace = calcTraces[i];\n            fullTrace = calcTrace[0].trace;\n\n            if(fullTrace.base === undefined) included.push(calcTrace);\n            else excluded.push(calcTrace);\n        }\n\n        if(included.length) {\n            setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included);\n        }\n        if(excluded.length) {\n            setGroupPositionsInOverlayMode(gd, pa, sa, excluded);\n        }\n    }\n\n    collectExtents(calcTraces, pa);\n}\n\n\nfunction setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces) {\n    var barnorm = gd._fullLayout.barnorm,\n        separateNegativeValues = false,\n        dontMergeOverlappingData = !barnorm;\n\n    // update position axis and set bar offsets and widths\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        var sieve = new Sieve(\n            [calcTrace], separateNegativeValues, dontMergeOverlappingData\n        );\n\n        // set bar offsets and widths, and update position axis\n        setOffsetAndWidth(gd, pa, sieve);\n\n        // set bar bases and sizes, and update size axis\n        //\n        // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n        // is defined, because this function is also invoked for traces that\n        // can't be grouped or stacked)\n        if(barnorm) {\n            sieveBars(gd, sa, sieve);\n            normalizeBars(gd, sa, sieve);\n        }\n        else {\n            setBaseAndTop(gd, sa, sieve);\n        }\n    }\n}\n\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces) {\n    var fullLayout = gd._fullLayout,\n        barnorm = fullLayout.barnorm,\n        separateNegativeValues = false,\n        dontMergeOverlappingData = !barnorm,\n        sieve = new Sieve(\n                calcTraces, separateNegativeValues, dontMergeOverlappingData\n            );\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidthInGroupMode(gd, pa, sieve);\n\n    // set bar bases and sizes, and update size axis\n    if(barnorm) {\n        sieveBars(gd, sa, sieve);\n        normalizeBars(gd, sa, sieve);\n    }\n    else {\n        setBaseAndTop(gd, sa, sieve);\n    }\n}\n\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces) {\n    var fullLayout = gd._fullLayout,\n        barmode = fullLayout.barmode,\n        stack = (barmode === 'stack'),\n        relative = (barmode === 'relative'),\n        barnorm = gd._fullLayout.barnorm,\n        separateNegativeValues = relative,\n        dontMergeOverlappingData = !(barnorm || stack || relative),\n        sieve = new Sieve(\n                calcTraces, separateNegativeValues, dontMergeOverlappingData\n            );\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(gd, pa, sieve);\n\n    // set bar bases and sizes, and update size axis\n    stackBars(gd, sa, sieve);\n\n    // flag the outmost bar (for text display purposes)\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s === BADNUM) continue;\n\n            var isOutmostBar = ((bar.b + bar.s) === sieve.get(bar.p, bar.s));\n            if(isOutmostBar) bar._outmost = true;\n        }\n    }\n\n    // Note that marking the outmost bars has to be done\n    // before `normalizeBars` changes `bar.b` and `bar.s`.\n    if(barnorm) normalizeBars(gd, sa, sieve);\n}\n\n\nfunction setOffsetAndWidth(gd, pa, sieve) {\n    var fullLayout = gd._fullLayout,\n        bargap = fullLayout.bargap,\n        bargroupgap = fullLayout.bargroupgap,\n        minDiff = sieve.minDiff,\n        calcTraces = sieve.traces,\n        i, calcTrace, calcTrace0,\n        t;\n\n    // set bar offsets and widths\n    var barGroupWidth = minDiff * (1 - bargap),\n        barWidthPlusGap = barGroupWidth,\n        barWidth = barWidthPlusGap * (1 - bargroupgap);\n\n    // computer bar group center and bar offset\n    var offsetFromCenter = -barWidth / 2;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        calcTrace0 = calcTrace[0];\n\n        // store bar width and offset for this trace\n        t = calcTrace0.t;\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace offset and width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(gd, pa, sieve);\n\n    // update position axes\n    updatePositionAxis(gd, pa, sieve);\n}\n\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve) {\n    var fullLayout = gd._fullLayout,\n        bargap = fullLayout.bargap,\n        bargroupgap = fullLayout.bargroupgap,\n        positions = sieve.positions,\n        distinctPositions = sieve.distinctPositions,\n        minDiff = sieve.minDiff,\n        calcTraces = sieve.traces,\n        i, calcTrace, calcTrace0,\n        t;\n\n    // if there aren't any overlapping positions,\n    // let them have full width even if mode is group\n    var overlap = (positions.length !== distinctPositions.length);\n\n    var nTraces = calcTraces.length,\n        barGroupWidth = minDiff * (1 - bargap),\n        barWidthPlusGap = (overlap) ? barGroupWidth / nTraces : barGroupWidth,\n        barWidth = barWidthPlusGap * (1 - bargroupgap);\n\n    for(i = 0; i < nTraces; i++) {\n        calcTrace = calcTraces[i];\n        calcTrace0 = calcTrace[0];\n\n        // computer bar group center and bar offset\n        var offsetFromCenter = (overlap) ?\n                ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 :\n                -barWidth / 2;\n\n        // store bar width and offset for this trace\n        t = calcTrace0.t;\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(gd, pa, sieve);\n\n    // update position axes\n    updatePositionAxis(gd, pa, sieve, overlap);\n}\n\n\nfunction applyAttributes(sieve) {\n    var calcTraces = sieve.traces,\n        i, calcTrace, calcTrace0, fullTrace,\n        j,\n        t;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        calcTrace0 = calcTrace[0];\n        fullTrace = calcTrace0.trace;\n        t = calcTrace0.t;\n\n        var offset = fullTrace.offset,\n            initialPoffset = t.poffset,\n            newPoffset;\n\n        if(isArrayOrTypedArray(offset)) {\n            // if offset is an array, then clone it into t.poffset.\n            newPoffset = offset.slice(0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newPoffset.length; j++) {\n                if(!isNumeric(newPoffset[j])) {\n                    newPoffset[j] = initialPoffset;\n                }\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.poffset\n            for(j = newPoffset.length; j < calcTrace.length; j++) {\n                newPoffset.push(initialPoffset);\n            }\n\n            t.poffset = newPoffset;\n        }\n        else if(offset !== undefined) {\n            t.poffset = offset;\n        }\n\n        var width = fullTrace.width,\n            initialBarwidth = t.barwidth;\n\n        if(isArrayOrTypedArray(width)) {\n            // if width is an array, then clone it into t.barwidth.\n            var newBarwidth = width.slice(0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newBarwidth.length; j++) {\n                if(!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.barwidth\n            for(j = newBarwidth.length; j < calcTrace.length; j++) {\n                newBarwidth.push(initialBarwidth);\n            }\n\n            t.barwidth = newBarwidth;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                newPoffset = [];\n                for(j = 0; j < calcTrace.length; j++) {\n                    newPoffset.push(\n                        initialPoffset + (initialBarwidth - newBarwidth[j]) / 2\n                    );\n                }\n                t.poffset = newPoffset;\n            }\n        }\n        else if(width !== undefined) {\n            t.barwidth = width;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n            }\n        }\n    }\n}\n\n\nfunction setBarCenterAndWidth(gd, pa, sieve) {\n    var calcTraces = sieve.traces,\n        pLetter = getAxisLetter(pa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i],\n            t = calcTrace[0].t,\n            poffset = t.poffset,\n            poffsetIsArray = Array.isArray(poffset),\n            barwidth = t.barwidth,\n            barwidthIsArray = Array.isArray(barwidth);\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var calcBar = calcTrace[j];\n\n            // store the actual bar width and position, for use by hover\n            var width = calcBar.w = (barwidthIsArray) ? barwidth[j] : barwidth;\n            calcBar[pLetter] = calcBar.p +\n                ((poffsetIsArray) ? poffset[j] : poffset) +\n                width / 2;\n\n\n        }\n    }\n}\n\n\nfunction updatePositionAxis(gd, pa, sieve, allowMinDtick) {\n    var calcTraces = sieve.traces,\n        distinctPositions = sieve.distinctPositions,\n        distinctPositions0 = distinctPositions[0],\n        minDiff = sieve.minDiff,\n        vpad = minDiff / 2;\n\n    Axes.minDtick(pa, minDiff, distinctPositions0, allowMinDtick);\n\n    // If the user set the bar width or the offset,\n    // then bars can be shifted away from their positions\n    // and widths can be larger than minDiff.\n    //\n    // Here, we compute pMin and pMax to expand the position axis,\n    // so that all bars are fully within the axis range.\n    var pMin = Math.min.apply(Math, distinctPositions) - vpad,\n        pMax = Math.max.apply(Math, distinctPositions) + vpad;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i],\n            calcTrace0 = calcTrace[0],\n            fullTrace = calcTrace0.trace;\n\n        if(fullTrace.width === undefined && fullTrace.offset === undefined) {\n            continue;\n        }\n\n        var t = calcTrace0.t,\n            poffset = t.poffset,\n            barwidth = t.barwidth,\n            poffsetIsArray = Array.isArray(poffset),\n            barwidthIsArray = Array.isArray(barwidth);\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var calcBar = calcTrace[j],\n                calcBarOffset = (poffsetIsArray) ? poffset[j] : poffset,\n                calcBarWidth = (barwidthIsArray) ? barwidth[j] : barwidth,\n                p = calcBar.p,\n                l = p + calcBarOffset,\n                r = l + calcBarWidth;\n\n            pMin = Math.min(pMin, l);\n            pMax = Math.max(pMax, r);\n        }\n    }\n\n    Axes.expand(pa, [pMin, pMax], {padded: false});\n}\n\nfunction expandRange(range, newValue) {\n    if(isNumeric(range[0])) range[0] = Math.min(range[0], newValue);\n    else range[0] = newValue;\n\n    if(isNumeric(range[1])) range[1] = Math.max(range[1], newValue);\n    else range[1] = newValue;\n}\n\nfunction setBaseAndTop(gd, sa, sieve) {\n    // store these bar bases and tops in calcdata\n    // and make sure the size axis includes zero,\n    // along with the bases and tops of each bar.\n    var traces = sieve.traces,\n        sLetter = getAxisLetter(sa),\n        sRange = [null, null];\n\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j],\n                barBase = bar.b,\n                barTop = barBase + bar.s;\n\n            bar[sLetter] = barTop;\n\n            if(isNumeric(sa.c2l(barTop))) expandRange(sRange, barTop);\n            if(bar.hasB && isNumeric(sa.c2l(barBase))) expandRange(sRange, barBase);\n        }\n    }\n\n    Axes.expand(sa, sRange, {tozero: true, padded: true});\n}\n\n\nfunction stackBars(gd, sa, sieve) {\n    var fullLayout = gd._fullLayout,\n        barnorm = fullLayout.barnorm,\n        sLetter = getAxisLetter(sa),\n        traces = sieve.traces,\n        i, trace,\n        j, bar;\n\n    var sRange = [null, null];\n\n    for(i = 0; i < traces.length; i++) {\n        trace = traces[i];\n\n        for(j = 0; j < trace.length; j++) {\n            bar = trace[j];\n\n            if(bar.s === BADNUM) continue;\n\n            // stack current bar and get previous sum\n            var barBase = sieve.put(bar.p, bar.b + bar.s),\n                barTop = barBase + bar.b + bar.s;\n\n            // store the bar base and top in each calcdata item\n            bar.b = barBase;\n            bar[sLetter] = barTop;\n\n            if(!barnorm) {\n                if(isNumeric(sa.c2l(barTop))) expandRange(sRange, barTop);\n                if(bar.hasB && isNumeric(sa.c2l(barBase))) expandRange(sRange, barBase);\n            }\n        }\n    }\n\n    // if barnorm is set, let normalizeBars update the axis range\n    if(!barnorm) Axes.expand(sa, sRange, {tozero: true, padded: true});\n}\n\n\nfunction sieveBars(gd, sa, sieve) {\n    var traces = sieve.traces;\n\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j];\n\n            if(bar.s !== BADNUM) sieve.put(bar.p, bar.b + bar.s);\n        }\n    }\n}\n\n\nfunction normalizeBars(gd, sa, sieve) {\n    // Note:\n    //\n    // normalizeBars requires that either sieveBars or stackBars has been\n    // previously invoked.\n\n    var traces = sieve.traces,\n        sLetter = getAxisLetter(sa),\n        sTop = (gd._fullLayout.barnorm === 'fraction') ? 1 : 100,\n        sTiny = sTop / 1e9, // in case of rounding error in sum\n        sMin = sa.l2c(sa.c2l(0)),\n        sMax = (gd._fullLayout.barmode === 'stack') ? sTop : sMin,\n        sRange = [sMin, sMax],\n        padded = false;\n\n    function maybeExpand(newValue) {\n        if(isNumeric(sa.c2l(newValue)) &&\n            ((newValue < sMin - sTiny) || (newValue > sMax + sTiny) || !isNumeric(sMin))\n        ) {\n            padded = true;\n            expandRange(sRange, newValue);\n        }\n    }\n\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j];\n\n            if(bar.s === BADNUM) continue;\n\n            var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n            bar.b *= scale;\n            bar.s *= scale;\n\n            var barBase = bar.b,\n                barTop = barBase + bar.s;\n            bar[sLetter] = barTop;\n\n            maybeExpand(barTop);\n            if(bar.hasB) maybeExpand(barBase);\n        }\n    }\n\n    // update range of size axis\n    Axes.expand(sa, sRange, {tozero: true, padded: padded});\n}\n\n\nfunction getAxisLetter(ax) {\n    return ax._id.charAt(0);\n}\n\n// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces, pa) {\n    var posLetter = pa._id.charAt(0);\n    var extents = {};\n    var pMin = Infinity;\n    var pMax = -Infinity;\n\n    var i, j, cd;\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        for(j = 0; j < cd.length; j++) {\n            var p = cd[j].p;\n            if(isNumeric(p)) {\n                pMin = Math.min(pMin, p);\n                pMax = Math.max(pMax, p);\n            }\n        }\n    }\n\n    // this is just for positioning of hover labels, and nobody will care if\n    // the label is 1px too far out; so round positions to 1/10K in case\n    // position values don't exactly match from trace to trace\n    var roundFactor = 10000 / (pMax - pMin);\n    var round = extents.round = function(p) {\n        return String(Math.round(roundFactor * (p - pMin)));\n    };\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        cd[0].t.extents = extents;\n        for(j = 0; j < cd.length; j++) {\n            var di = cd[j];\n            var p0 = di[posLetter] - di.w / 2;\n            if(isNumeric(p0)) {\n                var p1 = di[posLetter] + di.w / 2;\n                var pVal = round(di.p);\n                if(extents[pVal]) {\n                    extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n                }\n                else {\n                    extents[pVal] = [p0, p1];\n                }\n            }\n        }\n    }\n}\n",null]}