{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cdt2d/cdt2d.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cdt2d/cdt2d.js","mtime":1529418307098},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\n\nvar monotoneTriangulate = require('./lib/monotone')\nvar makeIndex = require('./lib/triangulation')\nvar delaunayFlip = require('./lib/delaunay')\nvar filterTriangulation = require('./lib/filter')\n\nmodule.exports = cdt2d\n\nfunction canonicalizeEdge(e) {\n  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])]\n}\n\nfunction compareEdge(a, b) {\n  return a[0]-b[0] || a[1]-b[1]\n}\n\nfunction canonicalizeEdges(edges) {\n  return edges.map(canonicalizeEdge).sort(compareEdge)\n}\n\nfunction getDefault(options, property, dflt) {\n  if(property in options) {\n    return options[property]\n  }\n  return dflt\n}\n\nfunction cdt2d(points, edges, options) {\n\n  if(!Array.isArray(edges)) {\n    options = edges || {}\n    edges = []\n  } else {\n    options = options || {}\n    edges = edges || []\n  }\n\n  //Parse out options\n  var delaunay = !!getDefault(options, 'delaunay', true)\n  var interior = !!getDefault(options, 'interior', true)\n  var exterior = !!getDefault(options, 'exterior', true)\n  var infinity = !!getDefault(options, 'infinity', false)\n\n  //Handle trivial case\n  if((!interior && !exterior) || points.length === 0) {\n    return []\n  }\n\n  //Construct initial triangulation\n  var cells = monotoneTriangulate(points, edges)\n\n  //If delaunay refinement needed, then improve quality by edge flipping\n  if(delaunay || interior !== exterior || infinity) {\n\n    //Index all of the cells to support fast neighborhood queries\n    var triangulation = makeIndex(points.length, canonicalizeEdges(edges))\n    for(var i=0; i<cells.length; ++i) {\n      var f = cells[i]\n      triangulation.addTriangle(f[0], f[1], f[2])\n    }\n\n    //Run edge flipping\n    if(delaunay) {\n      delaunayFlip(points, triangulation)\n    }\n\n    //Filter points\n    if(!exterior) {\n      return filterTriangulation(triangulation, -1)\n    } else if(!interior) {\n      return filterTriangulation(triangulation,  1, infinity)\n    } else if(infinity) {\n      return filterTriangulation(triangulation, 0, infinity)\n    } else {\n      return triangulation.cells()\n    }\n    \n  } else {\n    return cells\n  }\n}\n",null]}