{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plot_api/subroutines.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plot_api/subroutines.js","mtime":1529418310680},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Registry = require('../registry');\nvar Plots = require('../plots/plots');\n\nvar Lib = require('../lib');\nvar clearGlCanvases = require('../lib/clear_gl_canvases');\n\nvar Color = require('../components/color');\nvar Drawing = require('../components/drawing');\nvar Titles = require('../components/titles');\nvar ModeBar = require('../components/modebar');\n\nvar Axes = require('../plots/cartesian/axes');\nvar alignmentConstants = require('../constants/alignment');\nvar axisConstraints = require('../plots/cartesian/constraints');\nvar enforceAxisConstraints = axisConstraints.enforce;\nvar cleanAxisConstraints = axisConstraints.clean;\nvar doAutoRange = require('../plots/cartesian/autorange').doAutoRange;\n\nexports.layoutStyles = function(gd) {\n    return Lib.syncOrAsync([Plots.doAutoMargin, exports.lsInner], gd);\n};\n\nfunction overlappingDomain(xDomain, yDomain, domains) {\n    for(var i = 0; i < domains.length; i++) {\n        var existingX = domains[i][0],\n            existingY = domains[i][1];\n\n        if(existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {\n            continue;\n        }\n        if(existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexports.lsInner = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var gs = fullLayout._size;\n    var pad = gs.p;\n    var axList = Axes.list(gd, '', true);\n\n    // _has('cartesian') means SVG specifically, not GL2D - but GL2D\n    // can still get here because it makes some of the SVG structure\n    // for shared features like selections.\n    var hasSVGCartesian = fullLayout._has('cartesian');\n    var i;\n\n    function getLinePosition(ax, counterAx, side) {\n        var lwHalf = ax._lw / 2;\n\n        if(ax._id.charAt(0) === 'x') {\n            if(!counterAx) return gs.t + gs.h * (1 - (ax.position || 0)) + (lwHalf % 1);\n            else if(side === 'top') return counterAx._offset - pad - lwHalf;\n            return counterAx._offset + counterAx._length + pad + lwHalf;\n        }\n\n        if(!counterAx) return gs.l + gs.w * (ax.position || 0) + (lwHalf % 1);\n        else if(side === 'right') return counterAx._offset + counterAx._length + pad + lwHalf;\n        return counterAx._offset - pad - lwHalf;\n    }\n\n    // some preparation of axis position info\n    for(i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n\n        // reset scale in case the margins have changed\n        ax.setScale();\n\n        var counterAx = ax._anchorAxis;\n\n        // clear axis line positions, to be set in the subplot loop below\n        ax._linepositions = {};\n\n        // stash crispRounded linewidth so we don't need to pass gd all over the place\n        ax._lw = Drawing.crispRound(gd, ax.linewidth, 1);\n\n        // figure out the main axis line and main mirror line position.\n        // it's easier to follow the logic if we handle these separately from\n        // ax._linepositions, which are really only used by mirror=allticks\n        // for the non-main-subplot ticks.\n        ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);\n        ax._mainMirrorPosition = (ax.mirror && counterAx) ?\n            getLinePosition(ax, counterAx,\n                alignmentConstants.OPPOSITE_SIDE[ax.side]) : null;\n\n        // Figure out which subplot to draw ticks, labels, & axis lines on\n        // do this as a separate loop so we already have all the\n        // _mainAxis and _anchorAxis links set\n        ax._mainSubplot = findMainSubplot(ax, fullLayout);\n    }\n\n    fullLayout._paperdiv\n        .style({\n            width: fullLayout.width + 'px',\n            height: fullLayout.height + 'px'\n        })\n        .selectAll('.main-svg')\n            .call(Drawing.setSize, fullLayout.width, fullLayout.height);\n\n    gd._context.setBackground(gd, fullLayout.paper_bgcolor);\n\n    var subplotSelection = fullLayout._paper.selectAll('g.subplot');\n\n    // figure out which backgrounds we need to draw, and in which layers\n    // to put them\n    var lowerBackgroundIDs = [];\n    var lowerDomains = [];\n    subplotSelection.each(function(subplot) {\n        var plotinfo = fullLayout._plots[subplot];\n\n        if(plotinfo.mainplot) {\n            // mainplot is a reference to the main plot this one is overlaid on\n            // so if it exists, this is an overlaid plot and we don't need to\n            // give it its own background\n            if(plotinfo.bg) {\n                plotinfo.bg.remove();\n            }\n            plotinfo.bg = undefined;\n            return;\n        }\n\n        var xDomain = plotinfo.xaxis.domain;\n        var yDomain = plotinfo.yaxis.domain;\n        var plotgroup = plotinfo.plotgroup;\n\n        if(overlappingDomain(xDomain, yDomain, lowerDomains)) {\n            var pgNode = plotgroup.node();\n            var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, 'rect', 'bg');\n            pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);\n        } else {\n            plotgroup.select('rect.bg').remove();\n            lowerBackgroundIDs.push(subplot);\n            lowerDomains.push([xDomain, yDomain]);\n        }\n    });\n\n    // now create all the lower-layer backgrounds at once now that\n    // we have the list of subplots that need them\n    var lowerBackgrounds = fullLayout._bgLayer.selectAll('.bg')\n        .data(lowerBackgroundIDs);\n\n    lowerBackgrounds.enter().append('rect')\n        .classed('bg', true);\n\n    lowerBackgrounds.exit().remove();\n\n    lowerBackgrounds.each(function(subplot) {\n        fullLayout._plots[subplot].bg = d3.select(this);\n    });\n\n    subplotSelection.each(function(subplot) {\n        var plotinfo = fullLayout._plots[subplot];\n        var xa = plotinfo.xaxis;\n        var ya = plotinfo.yaxis;\n\n        if(plotinfo.bg && hasSVGCartesian) {\n            plotinfo.bg\n                .call(Drawing.setRect,\n                    xa._offset - pad, ya._offset - pad,\n                    xa._length + 2 * pad, ya._length + 2 * pad)\n                .call(Color.fill, fullLayout.plot_bgcolor)\n                .style('stroke-width', 0);\n        }\n\n        // Clip so that data only shows up on the plot area.\n        var clipId = plotinfo.clipId = 'clip' + fullLayout._uid + subplot + 'plot';\n\n        var plotClip = Lib.ensureSingleById(fullLayout._clips, 'clipPath', clipId, function(s) {\n            s.classed('plotclip', true)\n                .append('rect');\n        });\n\n        plotinfo.clipRect = plotClip.select('rect').attr({\n            width: xa._length,\n            height: ya._length\n        });\n\n        Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);\n\n        var plotClipId;\n        var layerClipId;\n\n        if(plotinfo._hasClipOnAxisFalse) {\n            plotClipId = null;\n            layerClipId = clipId;\n        } else {\n            plotClipId = clipId;\n            layerClipId = null;\n        }\n\n        Drawing.setClipUrl(plotinfo.plot, plotClipId);\n\n        // stash layer clipId value (null or same as clipId)\n        // to DRY up Drawing.setClipUrl calls on trace-module and trace layers\n        // downstream\n        plotinfo.layerClipId = layerClipId;\n\n        // figure out extra axis line and tick positions as needed\n        if(!hasSVGCartesian) return;\n\n        var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop,\n            leftYLineWidth, rightYLineWidth;\n        var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight,\n            connectYBottom, connectYTop;\n        var extraSubplot;\n\n        function xLinePath(y) {\n            return 'M' + xLinesXLeft + ',' + y + 'H' + xLinesXRight;\n        }\n\n        function xLinePathFree(y) {\n            return 'M' + xa._offset + ',' + y + 'h' + xa._length;\n        }\n\n        function yLinePath(x) {\n            return 'M' + x + ',' + yLinesYTop + 'V' + yLinesYBottom;\n        }\n\n        function yLinePathFree(x) {\n            return 'M' + x + ',' + ya._offset + 'v' + ya._length;\n        }\n\n        function mainPath(ax, pathFn, pathFnFree) {\n            if(!ax.showline || subplot !== ax._mainSubplot) return '';\n            if(!ax._anchorAxis) return pathFnFree(ax._mainLinePosition);\n            var out = pathFn(ax._mainLinePosition);\n            if(ax.mirror) out += pathFn(ax._mainMirrorPosition);\n            return out;\n        }\n\n        /*\n         * x lines get longer where they meet y lines, to make a crisp corner.\n         * The x lines get the padding (margin.pad) plus the y line width to\n         * fill up the corner nicely. Free x lines are excluded - they always\n         * span exactly the data area of the plot\n         *\n         *  | XXXXX\n         *  | XXXXX\n         *  |\n         *  +------\n         *     x1\n         *    -----\n         *     x2\n         */\n        var xPath = 'M0,0';\n        if(shouldShowLinesOrTicks(xa, subplot)) {\n            leftYLineWidth = findCounterAxisLineWidth(xa, 'left', ya, axList);\n            xLinesXLeft = xa._offset - (leftYLineWidth ? (pad + leftYLineWidth) : 0);\n            rightYLineWidth = findCounterAxisLineWidth(xa, 'right', ya, axList);\n            xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? (pad + rightYLineWidth) : 0);\n            xLinesYBottom = getLinePosition(xa, ya, 'bottom');\n            xLinesYTop = getLinePosition(xa, ya, 'top');\n\n            // save axis line positions for extra ticks to reference\n            // each subplot that gets ticks from \"allticks\" gets an entry:\n            //    [left or bottom, right or top]\n            extraSubplot = (!xa._anchorAxis || subplot !== xa._mainSubplot);\n            if(extraSubplot && xa.ticks && xa.mirror === 'allticks') {\n                xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];\n            }\n\n            xPath = mainPath(xa, xLinePath, xLinePathFree);\n            if(extraSubplot && xa.showline && (xa.mirror === 'all' || xa.mirror === 'allticks')) {\n                xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);\n            }\n\n            plotinfo.xlines\n                .style('stroke-width', xa._lw + 'px')\n                .call(Color.stroke, xa.showline ?\n                    xa.linecolor : 'rgba(0,0,0,0)');\n        }\n        plotinfo.xlines.attr('d', xPath);\n\n        /*\n         * y lines that meet x axes get longer only by margin.pad, because\n         * the x axes fill in the corner space. Free y axes, like free x axes,\n         * always span exactly the data area of the plot\n         *\n         *   |   | XXXX\n         * y2| y1| XXXX\n         *   |   | XXXX\n         *       |\n         *       +-----\n         */\n        var yPath = 'M0,0';\n        if(shouldShowLinesOrTicks(ya, subplot)) {\n            connectYBottom = findCounterAxisLineWidth(ya, 'bottom', xa, axList);\n            yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);\n            connectYTop = findCounterAxisLineWidth(ya, 'top', xa, axList);\n            yLinesYTop = ya._offset - (connectYTop ? pad : 0);\n            yLinesXLeft = getLinePosition(ya, xa, 'left');\n            yLinesXRight = getLinePosition(ya, xa, 'right');\n\n            extraSubplot = (!ya._anchorAxis || subplot !== xa._mainSubplot);\n            if(extraSubplot && ya.ticks && ya.mirror === 'allticks') {\n                ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];\n            }\n\n            yPath = mainPath(ya, yLinePath, yLinePathFree);\n            if(extraSubplot && ya.showline && (ya.mirror === 'all' || ya.mirror === 'allticks')) {\n                yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);\n            }\n\n            plotinfo.ylines\n                .style('stroke-width', ya._lw + 'px')\n                .call(Color.stroke, ya.showline ?\n                    ya.linecolor : 'rgba(0,0,0,0)');\n        }\n        plotinfo.ylines.attr('d', yPath);\n    });\n\n    Axes.makeClipPaths(gd);\n    exports.drawMainTitle(gd);\n    ModeBar.manage(gd);\n\n    return gd._promises.length && Promise.all(gd._promises);\n};\n\nfunction findMainSubplot(ax, fullLayout) {\n    var subplotList = fullLayout._subplots;\n    var ids = subplotList.cartesian.concat(subplotList.gl2d || []);\n    var mockGd = {_fullLayout: fullLayout};\n\n    var isX = ax._id.charAt(0) === 'x';\n    var anchorAx = ax._mainAxis._anchorAxis;\n    var mainSubplotID = '';\n    var nextBestMainSubplotID = '';\n    var anchorID = '';\n\n    // First try the main ID with the anchor\n    if(anchorAx) {\n        anchorID = anchorAx._mainAxis._id;\n        mainSubplotID = isX ? (ax._id + anchorID) : (anchorID + ax._id);\n    }\n\n    // Then look for a subplot with the counteraxis overlaying the anchor\n    // If that fails just use the first subplot including this axis\n    if(!mainSubplotID || !fullLayout._plots[mainSubplotID]) {\n        mainSubplotID = '';\n\n        for(var j = 0; j < ids.length; j++) {\n            var id = ids[j];\n            var yIndex = id.indexOf('y');\n            var idPart = isX ? id.substr(0, yIndex) : id.substr(yIndex);\n            var counterPart = isX ? id.substr(yIndex) : id.substr(0, yIndex);\n\n            if(idPart === ax._id) {\n                if(!nextBestMainSubplotID) nextBestMainSubplotID = id;\n                var counterAx = Axes.getFromId(mockGd, counterPart);\n                if(anchorID && counterAx.overlaying === anchorID) {\n                    mainSubplotID = id;\n                    break;\n                }\n            }\n        }\n    }\n\n    return mainSubplotID || nextBestMainSubplotID;\n}\n\nfunction shouldShowLinesOrTicks(ax, subplot) {\n    return (ax.ticks || ax.showline) &&\n        (subplot === ax._mainSubplot || ax.mirror === 'all' || ax.mirror === 'allticks');\n}\n\n/*\n * should we draw a line on counterAx at this side of ax?\n * It's assumed that counterAx is known to overlay the subplot we're working on\n * but it may not be its main axis.\n */\nfunction shouldShowLineThisSide(ax, side, counterAx) {\n    // does counterAx get a line at all?\n    if(!counterAx.showline || !counterAx._lw) return false;\n\n    // are we drawing *all* lines for counterAx?\n    if(counterAx.mirror === 'all' || counterAx.mirror === 'allticks') return true;\n\n    var anchorAx = counterAx._anchorAxis;\n\n    // is this a free axis? free axes can only have a subplot side-line with all(ticks)? mirroring\n    if(!anchorAx) return false;\n\n    // in order to handle cases where the user forgot to anchor this axis correctly\n    // (because its default anchor has the same domain on the relevant end)\n    // check whether the relevant position is the same.\n    var sideIndex = alignmentConstants.FROM_BL[side];\n    if(counterAx.side === side) {\n        return anchorAx.domain[sideIndex] === ax.domain[sideIndex];\n    }\n    return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];\n}\n\n/*\n * Is there another axis intersecting `side` end of `ax`?\n * First look at `counterAx` (the axis for this subplot),\n * then at all other potential counteraxes on or overlaying this subplot.\n * Take the line width from the first one that has a line.\n */\nfunction findCounterAxisLineWidth(ax, side, counterAx, axList) {\n    if(shouldShowLineThisSide(ax, side, counterAx)) {\n        return counterAx._lw;\n    }\n    for(var i = 0; i < axList.length; i++) {\n        var axi = axList[i];\n        if(axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {\n            return axi._lw;\n        }\n    }\n    return 0;\n}\n\nexports.drawMainTitle = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    Titles.draw(gd, 'gtitle', {\n        propContainer: fullLayout,\n        propName: 'title',\n        placeholder: fullLayout._dfltTitle.plot,\n        attributes: {\n            x: fullLayout.width / 2,\n            y: fullLayout._size.t / 2,\n            'text-anchor': 'middle'\n        }\n    });\n};\n\n// First, see if we need to do arraysToCalcdata\n// call it regardless of what change we made, in case\n// supplyDefaults brought in an array that was already\n// in gd.data but not in gd._fullData previously\nexports.doTraceStyle = function(gd) {\n    for(var i = 0; i < gd.calcdata.length; i++) {\n        var cdi = gd.calcdata[i],\n            _module = ((cdi[0] || {}).trace || {})._module || {},\n            arraysToCalcdata = _module.arraysToCalcdata;\n\n        if(arraysToCalcdata) arraysToCalcdata(cdi, cdi[0].trace);\n    }\n\n    Plots.style(gd);\n    Registry.getComponentMethod('legend', 'draw')(gd);\n\n    return Plots.previousPromises(gd);\n};\n\nexports.doColorBars = function(gd) {\n    for(var i = 0; i < gd.calcdata.length; i++) {\n        var cdi0 = gd.calcdata[i][0];\n\n        if((cdi0.t || {}).cb) {\n            var trace = cdi0.trace,\n                cb = cdi0.t.cb;\n\n            if(Registry.traceIs(trace, 'contour')) {\n                cb.line({\n                    width: trace.contours.showlines !== false ?\n                        trace.line.width : 0,\n                    dash: trace.line.dash,\n                    color: trace.contours.coloring === 'line' ?\n                        cb._opts.line.color : trace.line.color\n                });\n            }\n            if(Registry.traceIs(trace, 'markerColorscale')) {\n                cb.options(trace.marker.colorbar)();\n            }\n            else cb.options(trace.colorbar)();\n        }\n    }\n\n    return Plots.previousPromises(gd);\n};\n\n// force plot() to redo the layout and replot with the modified layout\nexports.layoutReplot = function(gd) {\n    var layout = gd.layout;\n    gd.layout = undefined;\n    return Registry.call('plot', gd, '', layout);\n};\n\nexports.doLegend = function(gd) {\n    Registry.getComponentMethod('legend', 'draw')(gd);\n    return Plots.previousPromises(gd);\n};\n\nexports.doTicksRelayout = function(gd, rangesAltered) {\n    if(rangesAltered) {\n        Axes.doTicks(gd, Object.keys(rangesAltered), true);\n    } else {\n        Axes.doTicks(gd, 'redraw');\n    }\n\n    if(gd._fullLayout._hasOnlyLargeSploms) {\n        clearGlCanvases(gd);\n        Registry.subplotsRegistry.splom.plot(gd);\n    }\n\n    exports.drawMainTitle(gd);\n    return Plots.previousPromises(gd);\n};\n\nexports.doModeBar = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    ModeBar.manage(gd);\n\n    for(var i = 0; i < fullLayout._basePlotModules.length; i++) {\n        var updateFx = fullLayout._basePlotModules[i].updateFx;\n        if(updateFx) updateFx(fullLayout);\n    }\n\n    return Plots.previousPromises(gd);\n};\n\nexports.doCamera = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var sceneIds = fullLayout._subplots.gl3d;\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        var sceneLayout = fullLayout[sceneIds[i]];\n        var scene = sceneLayout._scene;\n\n        scene.setCamera(sceneLayout.camera);\n    }\n};\n\nexports.drawData = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var calcdata = gd.calcdata;\n    var i;\n\n    // remove old colorbars explicitly\n    for(i = 0; i < calcdata.length; i++) {\n        var trace = calcdata[i][0].trace;\n        if(trace.visible !== true || !trace._module.colorbar) {\n            fullLayout._infolayer.select('.cb' + trace.uid).remove();\n        }\n    }\n\n    clearGlCanvases(gd);\n\n    // loop over the base plot modules present on graph\n    var basePlotModules = fullLayout._basePlotModules;\n    for(i = 0; i < basePlotModules.length; i++) {\n        basePlotModules[i].plot(gd);\n    }\n\n    // styling separate from drawing\n    Plots.style(gd);\n\n    // show annotations and shapes\n    Registry.getComponentMethod('shapes', 'draw')(gd);\n    Registry.getComponentMethod('annotations', 'draw')(gd);\n\n    // Mark the first render as complete\n    fullLayout._replotting = false;\n\n    return Plots.previousPromises(gd);\n};\n\nexports.doAutoRangeAndConstraints = function(gd) {\n    var axList = Axes.list(gd, '', true);\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        cleanAxisConstraints(gd, ax);\n        doAutoRange(ax);\n    }\n\n    enforceAxisConstraints(gd);\n};\n\n// An initial paint must be completed before these components can be\n// correctly sized and the whole plot re-margined. fullLayout._replotting must\n// be set to false before these will work properly.\nexports.finalDraw = function(gd) {\n    Registry.getComponentMethod('shapes', 'draw')(gd);\n    Registry.getComponentMethod('images', 'draw')(gd);\n    Registry.getComponentMethod('annotations', 'draw')(gd);\n    Registry.getComponentMethod('legend', 'draw')(gd);\n    Registry.getComponentMethod('rangeslider', 'draw')(gd);\n    Registry.getComponentMethod('rangeselector', 'draw')(gd);\n    Registry.getComponentMethod('sliders', 'draw')(gd);\n    Registry.getComponentMethod('updatemenus', 'draw')(gd);\n};\n",null]}