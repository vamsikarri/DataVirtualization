{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/ndarray-extract-contour/contour.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/ndarray-extract-contour/contour.js","mtime":1529418310042},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["\"use strict\"\n\nvar pool = require(\"typedarray-pool\")\n\nmodule.exports = createSurfaceExtractor\n\n//Helper macros\nfunction array(i) {\n  return \"a\" + i\n}\nfunction data(i) {\n  return \"d\" + i\n}\nfunction cube(i,bitmask) {\n  return \"c\" + i + \"_\" + bitmask\n}\nfunction shape(i) {\n  return \"s\" + i\n}\nfunction stride(i,j) {\n  return \"t\" + i + \"_\" + j\n}\nfunction offset(i) {\n  return \"o\" + i\n}\nfunction scalar(i) {\n  return \"x\" + i\n}\nfunction pointer(i) {\n  return \"p\" + i\n}\nfunction delta(i,bitmask) {\n  return \"d\" + i + \"_\" + bitmask\n}\nfunction index(i) {\n  return \"i\" + i\n}\nfunction step(i,j) {\n  return \"u\" + i + \"_\" + j\n}\nfunction pcube(bitmask) {\n  return \"b\" + bitmask\n}\nfunction qcube(bitmask) {\n  return \"y\" + bitmask\n}\nfunction pdelta(bitmask) {\n  return \"e\" + bitmask\n}\nfunction vert(i) {\n  return \"v\" + i\n}\nvar VERTEX_IDS = \"V\"\nvar PHASES = \"P\"\nvar VERTEX_COUNT = \"N\"\nvar POOL_SIZE = \"Q\"\nvar POINTER = \"X\"\nvar TEMPORARY = \"T\"\n\nfunction permBitmask(dimension, mask, order) {\n  var r = 0\n  for(var i=0; i<dimension; ++i) {\n    if(mask & (1<<i)) {\n      r |= (1<<order[i])\n    }\n  }\n  return r\n}\n\n//Generates the surface procedure\nfunction compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {\n  var arrayArgs = typesig.length\n  var dimension = order.length\n\n  if(dimension < 2) {\n    throw new Error(\"ndarray-extract-contour: Dimension must be at least 2\")\n  }\n\n  var funcName = \"extractContour\" + order.join(\"_\")\n  var code = []\n  var vars = []\n  var args = []\n\n  //Assemble arguments\n  for(var i=0; i<arrayArgs; ++i) {\n    args.push(array(i))  \n  }\n  for(var i=0; i<scalarArgs; ++i) {\n    args.push(scalar(i))\n  }\n\n  //Shape\n  for(var i=0; i<dimension; ++i) {\n    vars.push(shape(i) + \"=\" + array(0) + \".shape[\" + i + \"]|0\")\n  }\n  //Data, stride, offset pointers\n  for(var i=0; i<arrayArgs; ++i) {\n    vars.push(data(i) + \"=\" + array(i) + \".data\",\n              offset(i) + \"=\" + array(i) + \".offset|0\")\n    for(var j=0; j<dimension; ++j) {\n      vars.push(stride(i,j) + \"=\" + array(i) + \".stride[\" + j + \"]|0\")\n    }\n  }\n  //Pointer, delta and cube variables\n  for(var i=0; i<arrayArgs; ++i) {\n    vars.push(pointer(i) + \"=\" + offset(i))\n    vars.push(cube(i,0))\n    for(var j=1; j<(1<<dimension); ++j) {\n      var ptrStr = []\n      for(var k=0; k<dimension; ++k) {\n        if(j & (1<<k)) {\n          ptrStr.push(\"-\" + stride(i,k))\n        }\n      }\n      vars.push(delta(i,j) + \"=(\" + ptrStr.join(\"\") + \")|0\")\n      vars.push(cube(i,j) + \"=0\")\n    }\n  }\n  //Create step variables\n  for(var i=0; i<arrayArgs; ++i) {\n    for(var j=0; j<dimension; ++j) {\n      var stepVal = [ stride(i,order[j]) ]\n      if(j > 0) {\n        stepVal.push(stride(i, order[j-1]) + \"*\" + shape(order[j-1]) )\n      }\n      vars.push(step(i,order[j]) + \"=(\" + stepVal.join(\"-\") + \")|0\")\n    }\n  }\n  //Create index variables\n  for(var i=0; i<dimension; ++i) {\n    vars.push(index(i) + \"=0\")\n  }\n  //Vertex count\n  vars.push(VERTEX_COUNT + \"=0\")\n  //Compute pool size, initialize pool step\n  var sizeVariable = [\"2\"]\n  for(var i=dimension-2; i>=0; --i) {\n    sizeVariable.push(shape(order[i]))\n  }\n  //Previous phases and vertex_ids\n  vars.push(POOL_SIZE + \"=(\" + sizeVariable.join(\"*\") + \")|0\",\n            PHASES + \"=mallocUint32(\" + POOL_SIZE + \")\",\n            VERTEX_IDS + \"=mallocUint32(\" + POOL_SIZE + \")\",\n            POINTER + \"=0\")\n  //Create cube variables for phases\n  vars.push(pcube(0) + \"=0\")\n  for(var j=1; j<(1<<dimension); ++j) {\n    var cubeDelta = []\n    var cubeStep = [ ]\n    for(var k=0; k<dimension; ++k) {\n      if(j & (1<<k)) {\n        if(cubeStep.length === 0) {\n          cubeDelta.push(\"1\")\n        } else {\n          cubeDelta.unshift(cubeStep.join(\"*\"))\n        }\n      }\n      cubeStep.push(shape(order[k]))\n    }\n    var signFlag = \"\"\n    if(cubeDelta[0].indexOf(shape(order[dimension-2])) < 0) {\n      signFlag = \"-\"\n    }\n    var jperm = permBitmask(dimension, j, order)\n    vars.push(pdelta(jperm) + \"=(-\" + cubeDelta.join(\"-\") + \")|0\",\n              qcube(jperm) + \"=(\" + signFlag + cubeDelta.join(\"-\") + \")|0\",\n              pcube(jperm) + \"=0\")\n  }\n  vars.push(vert(0) + \"=0\", TEMPORARY + \"=0\")\n\n  function forLoopBegin(i, start) {\n    code.push(\"for(\", index(order[i]), \"=\", start, \";\",\n      index(order[i]), \"<\", shape(order[i]), \";\",\n      \"++\", index(order[i]), \"){\")\n  }\n\n  function forLoopEnd(i) {\n    for(var j=0; j<arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j,order[i]), \";\")\n    }\n    code.push(\"}\")\n  }\n\n  function fillEmptySlice(k) {\n    for(var i=k-1; i>=0; --i) {\n      forLoopBegin(i, 0) \n    }\n    var phaseFuncArgs = []\n    for(var i=0; i<arrayArgs; ++i) {\n      if(typesig[i]) {\n        phaseFuncArgs.push(data(i) + \".get(\" + pointer(i) + \")\")\n      } else {\n        phaseFuncArgs.push(data(i) + \"[\" + pointer(i) + \"]\")\n      }\n    }\n    for(var i=0; i<scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i))\n    }\n    code.push(PHASES, \"[\", POINTER, \"++]=phase(\", phaseFuncArgs.join(), \");\")\n    for(var i=0; i<k; ++i) {\n      forLoopEnd(i)\n    }\n    for(var j=0; j<arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j,order[k]), \";\")\n    }\n  }\n\n  function processGridCell(mask) {\n    //Read in local data\n    for(var i=0; i<arrayArgs; ++i) {\n      if(typesig[i]) {\n        code.push(cube(i,0), \"=\", data(i), \".get(\", pointer(i), \");\")\n      } else {\n        code.push(cube(i,0), \"=\", data(i), \"[\", pointer(i), \"];\")\n      }\n    }\n\n    //Read in phase\n    var phaseFuncArgs = []\n    for(var i=0; i<arrayArgs; ++i) {\n      phaseFuncArgs.push(cube(i,0))\n    }\n    for(var i=0; i<scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i))\n    }\n    \n    code.push(pcube(0), \"=\", PHASES, \"[\", POINTER, \"]=phase(\", phaseFuncArgs.join(), \");\")\n    \n    //Read in other cube data\n    for(var j=1; j<(1<<dimension); ++j) {\n      code.push(pcube(j), \"=\", PHASES, \"[\", POINTER, \"+\", pdelta(j), \"];\")\n    }\n\n    //Check for boundary crossing\n    var vertexPredicate = []\n    for(var j=1; j<(1<<dimension); ++j) {\n      vertexPredicate.push(\"(\" + pcube(0) + \"!==\" + pcube(j) + \")\")\n    }\n    code.push(\"if(\", vertexPredicate.join(\"||\"), \"){\")\n\n    //Read in boundary data\n    var vertexArgs = []\n    for(var i=0; i<dimension; ++i) {\n      vertexArgs.push(index(i))\n    }\n    for(var i=0; i<arrayArgs; ++i) {\n      vertexArgs.push(cube(i,0))\n      for(var j=1; j<(1<<dimension); ++j) {\n        if(typesig[i]) {\n          code.push(cube(i,j), \"=\", data(i), \".get(\", pointer(i), \"+\", delta(i,j), \");\")\n        } else {\n          code.push(cube(i,j), \"=\", data(i), \"[\", pointer(i), \"+\", delta(i,j), \"];\")\n        }\n        vertexArgs.push(cube(i,j))\n      }\n    }\n    for(var i=0; i<(1<<dimension); ++i) {\n      vertexArgs.push(pcube(i))\n    }\n    for(var i=0; i<scalarArgs; ++i) {\n      vertexArgs.push(scalar(i))\n    }\n\n    //Generate vertex\n    code.push(\"vertex(\", vertexArgs.join(), \");\",\n      vert(0), \"=\", VERTEX_IDS, \"[\", POINTER, \"]=\", VERTEX_COUNT, \"++;\")\n\n    //Check for face crossings\n    var base = (1<<dimension)-1\n    var corner = pcube(base)\n    for(var j=0; j<dimension; ++j) {\n      if((mask & ~(1<<j))===0) {\n        //Check face\n        var subset = base^(1<<j)\n        var edge = pcube(subset)\n        var faceArgs = [ ]\n        for(var k=subset; k>0; k=(k-1)&subset) {\n          faceArgs.push(VERTEX_IDS + \"[\" + POINTER + \"+\" + pdelta(k) + \"]\")\n        }\n        faceArgs.push(vert(0))\n        for(var k=0; k<arrayArgs; ++k) {\n          if(j&1) {\n            faceArgs.push(cube(k,base), cube(k,subset))\n          } else {\n            faceArgs.push(cube(k,subset), cube(k,base))\n          }\n        }\n        if(j&1) {\n          faceArgs.push(corner, edge)\n        } else {\n          faceArgs.push(edge, corner)\n        }\n        for(var k=0; k<scalarArgs; ++k) {\n          faceArgs.push(scalar(k))\n        }\n        code.push(\"if(\", corner, \"!==\", edge, \"){\",\n          \"face(\", faceArgs.join(), \")}\")\n      }\n    }\n    \n    //Increment pointer, close off if statement\n    code.push(\"}\",\n      POINTER, \"+=1;\")\n  }\n\n  function flip() {\n    for(var j=1; j<(1<<dimension); ++j) {\n      code.push(TEMPORARY, \"=\", pdelta(j), \";\",\n                pdelta(j), \"=\", qcube(j), \";\",\n                qcube(j), \"=\", TEMPORARY, \";\")\n    }\n  }\n\n  function createLoop(i, mask) {\n    if(i < 0) {\n      processGridCell(mask)\n      return\n    }\n    fillEmptySlice(i)\n    code.push(\"if(\", shape(order[i]), \">0){\",\n      index(order[i]), \"=1;\")\n    createLoop(i-1, mask|(1<<order[i]))\n\n    for(var j=0; j<arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j,order[i]), \";\")\n    }\n    if(i === dimension-1) {\n      code.push(POINTER, \"=0;\")\n      flip()\n    }\n    forLoopBegin(i, 2)\n    createLoop(i-1, mask)\n    if(i === dimension-1) {\n      code.push(\"if(\", index(order[dimension-1]), \"&1){\",\n        POINTER, \"=0;}\")\n      flip()\n    }\n    forLoopEnd(i)\n    code.push(\"}\")\n  }\n\n  createLoop(dimension-1, 0)\n\n  //Release scratch memory\n  code.push(\"freeUint32(\", VERTEX_IDS, \");freeUint32(\", PHASES, \");\")\n\n  //Compile and link procedure\n  var procedureCode = [\n    \"'use strict';\",\n    \"function \", funcName, \"(\", args.join(), \"){\",\n      \"var \", vars.join(), \";\",\n      code.join(\"\"),\n    \"}\",\n    \"return \", funcName ].join(\"\")\n\n  var proc = new Function(\n    \"vertex\", \n    \"face\", \n    \"phase\", \n    \"mallocUint32\", \n    \"freeUint32\",\n    procedureCode)\n  return proc(\n    vertexFunc, \n    faceFunc, \n    phaseFunc, \n    pool.mallocUint32, \n    pool.freeUint32)\n}\n\nfunction createSurfaceExtractor(args) {\n  function error(msg) {\n    throw new Error(\"ndarray-extract-contour: \" + msg)\n  }\n  if(typeof args !== \"object\") {\n    error(\"Must specify arguments\")\n  }\n  var order = args.order\n  if(!Array.isArray(order)) {\n    error(\"Must specify order\")\n  }\n  var arrays = args.arrayArguments||1\n  if(arrays < 1) {\n    error(\"Must have at least one array argument\")\n  }\n  var scalars = args.scalarArguments||0\n  if(scalars < 0) {\n    error(\"Scalar arg count must be > 0\")\n  }\n  if(typeof args.vertex !== \"function\") {\n    error(\"Must specify vertex creation function\")\n  }\n  if(typeof args.cell !== \"function\") {\n    error(\"Must specify cell creation function\")\n  }\n  if(typeof args.phase !== \"function\") {\n    error(\"Must specify phase function\")\n  }\n  var getters = args.getters || []\n  var typesig = new Array(arrays)\n  for(var i=0; i<arrays; ++i) {\n    if(getters.indexOf(i) >= 0) {\n      typesig[i] = true\n    } else {\n      typesig[i] = false\n    }\n  }\n  return compileSurfaceProcedure(\n    args.vertex,\n    args.cell,\n    args.phase,\n    scalars,\n    order,\n    typesig)\n}",null]}