{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scattercarpet/attributes.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scattercarpet/attributes.js","mtime":1529418310738},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar plotAttrs = require('../../plots/attributes');\nvar colorAttributes = require('../../components/colorscale/color_attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterMarkerAttrs = scatterAttrs.marker,\n    scatterLineAttrs = scatterAttrs.line,\n    scatterMarkerLineAttrs = scatterMarkerAttrs.line;\n\nmodule.exports = {\n    carpet: {\n        valType: 'string',\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'An identifier for this carpet, so that `scattercarpet` and',\n            '`scattercontour` traces can specify a carpet plot on which',\n            'they lie'\n        ].join(' ')\n    },\n    a: {\n        valType: 'data_array',\n        editType: 'calc',\n        description: [\n            'Sets the quantity of component `a` in each data point.',\n            'If `a`, `b`, and `c` are all provided, they need not be',\n            'normalized, only the relative values matter. If only two',\n            'arrays are provided they must be normalized to match',\n            '`ternary<i>.sum`.'\n        ].join(' ')\n    },\n    b: {\n        valType: 'data_array',\n        editType: 'calc',\n        description: [\n            'Sets the quantity of component `a` in each data point.',\n            'If `a`, `b`, and `c` are all provided, they need not be',\n            'normalized, only the relative values matter. If only two',\n            'arrays are provided they must be normalized to match',\n            '`ternary<i>.sum`.'\n        ].join(' ')\n    },\n    mode: extendFlat({}, scatterAttrs.mode, {dflt: 'markers'}),\n    text: extendFlat({}, scatterAttrs.text, {\n        description: [\n            'Sets text elements associated with each (a,b,c) point.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of strings, the items are mapped in order to the',\n            'the data points in (a,b,c).'\n        ].join(' ')\n    }),\n    line: {\n        color: scatterLineAttrs.color,\n        width: scatterLineAttrs.width,\n        dash: scatterLineAttrs.dash,\n        shape: extendFlat({}, scatterLineAttrs.shape,\n            {values: ['linear', 'spline']}),\n        smoothing: scatterLineAttrs.smoothing,\n        editType: 'calc'\n    },\n    connectgaps: scatterAttrs.connectgaps,\n    fill: extendFlat({}, scatterAttrs.fill, {\n        values: ['none', 'toself', 'tonext'],\n        description: [\n            'Sets the area to fill with a solid color.',\n            'Use with `fillcolor` if not *none*.',\n            'scatterternary has a subset of the options available to scatter.',\n            '*toself* connects the endpoints of the trace (or each segment',\n            'of the trace if it has gaps) into a closed shape.',\n            '*tonext* fills the space between two traces if one completely',\n            'encloses the other (eg consecutive contour lines), and behaves like',\n            '*toself* if there is no trace before it. *tonext* should not be',\n            'used if one trace does not enclose the other.'\n        ].join(' ')\n    }),\n    fillcolor: scatterAttrs.fillcolor,\n    marker: extendFlat({\n        symbol: scatterMarkerAttrs.symbol,\n        opacity: scatterMarkerAttrs.opacity,\n        maxdisplayed: scatterMarkerAttrs.maxdisplayed,\n        size: scatterMarkerAttrs.size,\n        sizeref: scatterMarkerAttrs.sizeref,\n        sizemin: scatterMarkerAttrs.sizemin,\n        sizemode: scatterMarkerAttrs.sizemode,\n        line: extendFlat({\n            width: scatterMarkerLineAttrs.width,\n            editType: 'calc'\n        },\n            colorAttributes('marker'.line)\n        ),\n        gradient: scatterMarkerAttrs.gradient,\n        editType: 'calc'\n    }, colorAttributes('marker'), {\n        showscale: scatterMarkerAttrs.showscale,\n        colorbar: colorbarAttrs\n    }),\n\n    textfont: scatterAttrs.textfont,\n    textposition: scatterAttrs.textposition,\n\n    selected: scatterAttrs.selected,\n    unselected: scatterAttrs.unselected,\n\n    hoverinfo: extendFlat({}, plotAttrs.hoverinfo, {\n        flags: ['a', 'b', 'text', 'name']\n    }),\n    hoveron: scatterAttrs.hoveron,\n};\n",null]}