{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/simplify-planar-graph/simplify.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/simplify-planar-graph/simplify.js","mtime":1529418311915},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["\"use strict\"\n\nmodule.exports = simplifyPolygon\n\nvar orient = require(\"robust-orientation\")\nvar sc = require(\"simplicial-complex\")\n\nfunction errorWeight(base, a, b) {\n  var area = Math.abs(orient(base, a, b))\n  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1]-b[1], 2))\n  return area / perim\n}\n\nfunction simplifyPolygon(cells, positions, minArea) {\n\n  var n = positions.length\n  var nc = cells.length\n  var inv = new Array(n)\n  var outv = new Array(n)\n  var weights = new Array(n)\n  var dead = new Array(n)\n  \n  //Initialize tables\n  for(var i=0; i<n; ++i) {\n    inv[i] = outv[i] = -1\n    weights[i] = Infinity\n    dead[i] = false\n  }\n\n  //Compute neighbors\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    if(c.length !== 2) {\n      throw new Error(\"Input must be a graph\")\n    }\n    var s = c[1]\n    var t = c[0]\n    if(outv[t] !== -1) {\n      outv[t] = -2\n    } else {\n      outv[t] = s\n    }\n    if(inv[s] !== -1) {\n      inv[s] = -2\n    } else {\n      inv[s] = t\n    }\n  }\n\n  //Updates the weight for vertex i\n  function computeWeight(i) {\n    if(dead[i]) {\n      return Infinity\n    }\n    //TODO: Check that the line segment doesn't cross once simplified\n    var s = inv[i]\n    var t = outv[i]\n    if((s<0) || (t<0)) {\n      return Infinity\n    } else {\n      return errorWeight(positions[i], positions[s], positions[t])\n    }\n  }\n\n  //Swaps two nodes on the heap (i,j) are the index of the nodes\n  function heapSwap(i,j) {\n    var a = heap[i]\n    var b = heap[j]\n    heap[i] = b\n    heap[j] = a\n    index[a] = j\n    index[b] = i\n  }\n\n  //Returns the weight of node i on the heap\n  function heapWeight(i) {\n    return weights[heap[i]]\n  }\n\n  function heapParent(i) {\n    if(i & 1) {\n      return (i - 1) >> 1\n    }\n    return (i >> 1) - 1\n  }\n\n  //Bubble element i down the heap\n  function heapDown(i) {\n    var w = heapWeight(i)\n    while(true) {\n      var tw = w\n      var left  = 2*i + 1\n      var right = 2*(i + 1)\n      var next = i\n      if(left < heapCount) {\n        var lw = heapWeight(left)\n        if(lw < tw) {\n          next = left\n          tw = lw\n        }\n      }\n      if(right < heapCount) {\n        var rw = heapWeight(right)\n        if(rw < tw) {\n          next = right\n        }\n      }\n      if(next === i) {\n        return i\n      }\n      heapSwap(i, next)\n      i = next      \n    }\n  }\n\n  //Bubbles element i up the heap\n  function heapUp(i) {\n    var w = heapWeight(i)\n    while(i > 0) {\n      var parent = heapParent(i)\n      if(parent >= 0) {\n        var pw = heapWeight(parent)\n        if(w < pw) {\n          heapSwap(i, parent)\n          i = parent\n          continue\n        }\n      }\n      return i\n    }\n  }\n\n  //Pop minimum element\n  function heapPop() {\n    if(heapCount > 0) {\n      var head = heap[0]\n      heapSwap(0, heapCount-1)\n      heapCount -= 1\n      heapDown(0)\n      return head\n    }\n    return -1\n  }\n\n  //Update heap item i\n  function heapUpdate(i, w) {\n    var a = heap[i]\n    if(weights[a] === w) {\n      return i\n    }\n    weights[a] = -Infinity\n    heapUp(i)\n    heapPop()\n    weights[a] = w\n    heapCount += 1\n    return heapUp(heapCount-1)\n  }\n\n  //Kills a vertex (assume vertex already removed from heap)\n  function kill(i) {\n    if(dead[i]) {\n      return\n    }\n    //Kill vertex\n    dead[i] = true\n    //Fixup topology\n    var s = inv[i]\n    var t = outv[i]\n    if(inv[t] >= 0) {\n      inv[t] = s\n    }\n    if(outv[s] >= 0) {\n      outv[s] = t\n    }\n\n    //Update weights on s and t\n    if(index[s] >= 0) {\n      heapUpdate(index[s], computeWeight(s))\n    }\n    if(index[t] >= 0) {\n      heapUpdate(index[t], computeWeight(t))\n    }\n  }\n\n  //Initialize weights and heap\n  var heap = []\n  var index = new Array(n)\n  for(var i=0; i<n; ++i) {\n    var w = weights[i] = computeWeight(i)\n    if(w < Infinity) {\n      index[i] = heap.length\n      heap.push(i)\n    } else {\n      index[i] = -1\n    }\n  }\n  var heapCount = heap.length\n  for(var i=heapCount>>1; i>=0; --i) {\n    heapDown(i)\n  }\n  \n  //Kill vertices\n  while(true) {\n    var hmin = heapPop()\n    if((hmin < 0) || (weights[hmin] > minArea)) {\n      break\n    }\n    kill(hmin)\n  }\n\n  //Build collapsed vertex table\n  var npositions = []\n  for(var i=0; i<n; ++i) {\n    if(!dead[i]) {\n      index[i] = npositions.length\n      npositions.push(positions[i].slice())\n    }\n  }\n  var nv = npositions.length\n\n  function tortoiseHare(seq, start) {\n    if(seq[start] < 0) {\n      return start\n    }\n    var t = start\n    var h = start\n    do {\n      //Walk two steps with h\n      var nh = seq[h]\n      if(!dead[h] || nh < 0 || nh === h) {\n        break\n      }\n      h = nh\n      nh = seq[h]\n      if(!dead[h] || nh < 0 || nh === h) {\n        break\n      }\n      h = nh\n\n      //Walk one step with t\n      t = seq[t]\n    } while(t !== h)\n    //Compress cycles\n    for(var v=start; v!==h; v = seq[v]) {\n      seq[v] = h\n    }\n    return h\n  }\n\n  var ncells = []\n  cells.forEach(function(c) {\n    var tin = tortoiseHare(inv, c[0])\n    var tout = tortoiseHare(outv, c[1])\n    if(tin >= 0 && tout >= 0 && tin !== tout) {\n      var cin = index[tin]\n      var cout = index[tout]\n      if(cin !== cout) {\n        ncells.push([ cin, cout ])\n      }\n    }\n  })\n\n  //Normalize result\n  sc.unique(sc.normalize(ncells))\n\n  //Return final list of cells\n  return {\n    positions: npositions,\n    edges: ncells\n  }\n}",null]}