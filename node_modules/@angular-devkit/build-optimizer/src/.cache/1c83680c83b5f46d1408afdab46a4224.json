{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/gl2d/camera.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/gl2d/camera.js","mtime":1529418310689},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar mouseChange = require('mouse-change');\nvar mouseWheel = require('mouse-wheel');\nvar mouseOffset = require('mouse-event-offset');\nvar cartesianConstants = require('../cartesian/constants');\nvar hasPassive = require('has-passive-events');\n\nmodule.exports = createCamera;\n\nfunction Camera2D(element, plot) {\n    this.element = element;\n    this.plot = plot;\n    this.mouseListener = null;\n    this.wheelListener = null;\n    this.lastInputTime = Date.now();\n    this.lastPos = [0, 0];\n    this.boxEnabled = false;\n    this.boxInited = false;\n    this.boxStart = [0, 0];\n    this.boxEnd = [0, 0];\n    this.dragStart = [0, 0];\n}\n\n\nfunction createCamera(scene) {\n    var element = scene.mouseContainer,\n        plot = scene.glplot,\n        result = new Camera2D(element, plot);\n\n    function unSetAutoRange() {\n        scene.xaxis.autorange = false;\n        scene.yaxis.autorange = false;\n    }\n\n    function getSubplotConstraint() {\n        // note: this assumes we only have one x and one y axis on this subplot\n        // when this constraint is lifted this block won't make sense\n        var constraints = scene.graphDiv._fullLayout._axisConstraintGroups;\n        var xaId = scene.xaxis._id;\n        var yaId = scene.yaxis._id;\n        for(var i = 0; i < constraints.length; i++) {\n            if(constraints[i][xaId] !== -1) {\n                if(constraints[i][yaId] !== -1) return true;\n                break;\n            }\n        }\n        return false;\n    }\n\n    result.mouseListener = mouseChange(element, handleInteraction);\n\n    // enable simple touch interactions\n    element.addEventListener('touchstart', function(ev) {\n        var xy = mouseOffset(ev.changedTouches[0], element);\n        handleInteraction(0, xy[0], xy[1]);\n        handleInteraction(1, xy[0], xy[1]);\n\n        ev.preventDefault();\n    }, hasPassive ? {passive: false} : false);\n    element.addEventListener('touchmove', function(ev) {\n        ev.preventDefault();\n        var xy = mouseOffset(ev.changedTouches[0], element);\n        handleInteraction(1, xy[0], xy[1]);\n\n        ev.preventDefault();\n    }, hasPassive ? {passive: false} : false);\n    element.addEventListener('touchend', function(ev) {\n        handleInteraction(0, result.lastPos[0], result.lastPos[1]);\n\n        ev.preventDefault();\n    }, hasPassive ? {passive: false} : false);\n\n    function handleInteraction(buttons, x, y) {\n        var dataBox = scene.calcDataBox(),\n            viewBox = plot.viewBox;\n\n        var lastX = result.lastPos[0],\n            lastY = result.lastPos[1];\n\n        var MINDRAG = cartesianConstants.MINDRAG * plot.pixelRatio;\n        var MINZOOM = cartesianConstants.MINZOOM * plot.pixelRatio;\n\n        var dx, dy;\n\n        x *= plot.pixelRatio;\n        y *= plot.pixelRatio;\n\n        // mouseChange gives y about top; convert to about bottom\n        y = (viewBox[3] - viewBox[1]) - y;\n\n        function updateRange(i0, start, end) {\n            var range0 = Math.min(start, end),\n                range1 = Math.max(start, end);\n\n            if(range0 !== range1) {\n                dataBox[i0] = range0;\n                dataBox[i0 + 2] = range1;\n                result.dataBox = dataBox;\n                scene.setRanges(dataBox);\n            }\n            else {\n                scene.selectBox.selectBox = [0, 0, 1, 1];\n                scene.glplot.setDirty();\n            }\n        }\n\n        switch(scene.fullLayout.dragmode) {\n            case 'zoom':\n                if(buttons) {\n                    var dataX = x /\n                            (viewBox[2] - viewBox[0]) * (dataBox[2] - dataBox[0]) +\n                        dataBox[0];\n                    var dataY = y /\n                            (viewBox[3] - viewBox[1]) * (dataBox[3] - dataBox[1]) +\n                        dataBox[1];\n\n                    if(!result.boxInited) {\n                        result.boxStart[0] = dataX;\n                        result.boxStart[1] = dataY;\n                        result.dragStart[0] = x;\n                        result.dragStart[1] = y;\n                    }\n\n                    result.boxEnd[0] = dataX;\n                    result.boxEnd[1] = dataY;\n\n                    // we need to mark the box as initialized right away\n                    // so that we can tell the start and end points apart\n                    result.boxInited = true;\n\n                    // but don't actually enable the box until the cursor moves\n                    if(!result.boxEnabled && (\n                        result.boxStart[0] !== result.boxEnd[0] ||\n                        result.boxStart[1] !== result.boxEnd[1])\n                    ) {\n                        result.boxEnabled = true;\n                    }\n\n                    // constrain aspect ratio if the axes require it\n                    var smallDx = Math.abs(result.dragStart[0] - x) < MINZOOM;\n                    var smallDy = Math.abs(result.dragStart[1] - y) < MINZOOM;\n                    if(getSubplotConstraint() && !(smallDx && smallDy)) {\n                        dx = result.boxEnd[0] - result.boxStart[0];\n                        dy = result.boxEnd[1] - result.boxStart[1];\n                        var dydx = (dataBox[3] - dataBox[1]) / (dataBox[2] - dataBox[0]);\n\n                        if(Math.abs(dx * dydx) > Math.abs(dy)) {\n                            result.boxEnd[1] = result.boxStart[1] +\n                                Math.abs(dx) * dydx * (dy >= 0 ? 1 : -1);\n\n                            // gl-select-box clips to the plot area bounds,\n                            // which breaks the axis constraint, so don't allow\n                            // this box to go out of bounds\n                            if(result.boxEnd[1] < dataBox[1]) {\n                                result.boxEnd[1] = dataBox[1];\n                                result.boxEnd[0] = result.boxStart[0] +\n                                    (dataBox[1] - result.boxStart[1]) / Math.abs(dydx);\n                            }\n                            else if(result.boxEnd[1] > dataBox[3]) {\n                                result.boxEnd[1] = dataBox[3];\n                                result.boxEnd[0] = result.boxStart[0] +\n                                    (dataBox[3] - result.boxStart[1]) / Math.abs(dydx);\n                            }\n                        }\n                        else {\n                            result.boxEnd[0] = result.boxStart[0] +\n                                Math.abs(dy) / dydx * (dx >= 0 ? 1 : -1);\n\n                            if(result.boxEnd[0] < dataBox[0]) {\n                                result.boxEnd[0] = dataBox[0];\n                                result.boxEnd[1] = result.boxStart[1] +\n                                    (dataBox[0] - result.boxStart[0]) * Math.abs(dydx);\n                            }\n                            else if(result.boxEnd[0] > dataBox[2]) {\n                                result.boxEnd[0] = dataBox[2];\n                                result.boxEnd[1] = result.boxStart[1] +\n                                    (dataBox[2] - result.boxStart[0]) * Math.abs(dydx);\n                            }\n                        }\n                    }\n                    // otherwise clamp small changes to the origin so we get 1D zoom\n                    else {\n                        if(smallDx) result.boxEnd[0] = result.boxStart[0];\n                        if(smallDy) result.boxEnd[1] = result.boxStart[1];\n                    }\n                }\n                else if(result.boxEnabled) {\n                    dx = result.boxStart[0] !== result.boxEnd[0];\n                    dy = result.boxStart[1] !== result.boxEnd[1];\n                    if(dx || dy) {\n                        if(dx) {\n                            updateRange(0, result.boxStart[0], result.boxEnd[0]);\n                            scene.xaxis.autorange = false;\n                        }\n                        if(dy) {\n                            updateRange(1, result.boxStart[1], result.boxEnd[1]);\n                            scene.yaxis.autorange = false;\n                        }\n                        scene.relayoutCallback();\n                    }\n                    else {\n                        scene.glplot.setDirty();\n                    }\n                    result.boxEnabled = false;\n                    result.boxInited = false;\n                }\n                // if box was inited but button released then - reset the box\n                else if(result.boxInited) {\n                    result.boxInited = false;\n                }\n                break;\n\n            case 'pan':\n                result.boxEnabled = false;\n                result.boxInited = false;\n\n                if(buttons) {\n                    if(!result.panning) {\n                        result.dragStart[0] = x;\n                        result.dragStart[1] = y;\n                    }\n\n                    if(Math.abs(result.dragStart[0] - x) < MINDRAG) x = result.dragStart[0];\n                    if(Math.abs(result.dragStart[1] - y) < MINDRAG) y = result.dragStart[1];\n\n                    dx = (lastX - x) * (dataBox[2] - dataBox[0]) /\n                        (plot.viewBox[2] - plot.viewBox[0]);\n                    dy = (lastY - y) * (dataBox[3] - dataBox[1]) /\n                        (plot.viewBox[3] - plot.viewBox[1]);\n\n                    dataBox[0] += dx;\n                    dataBox[2] += dx;\n                    dataBox[1] += dy;\n                    dataBox[3] += dy;\n\n                    scene.setRanges(dataBox);\n\n                    result.panning = true;\n                    result.lastInputTime = Date.now();\n                    unSetAutoRange();\n                    scene.cameraChanged();\n                    scene.handleAnnotations();\n                }\n                else if(result.panning) {\n                    result.panning = false;\n                    scene.relayoutCallback();\n                }\n                break;\n        }\n\n        result.lastPos[0] = x;\n        result.lastPos[1] = y;\n    }\n\n    result.wheelListener = mouseWheel(element, function(dx, dy) {\n        if(!scene.scrollZoom) return false;\n\n        var dataBox = scene.calcDataBox(),\n            viewBox = plot.viewBox;\n\n        var lastX = result.lastPos[0],\n            lastY = result.lastPos[1];\n\n        var scale = Math.exp(5.0 * dy / (viewBox[3] - viewBox[1]));\n\n        var cx = lastX /\n                (viewBox[2] - viewBox[0]) * (dataBox[2] - dataBox[0]) +\n            dataBox[0];\n        var cy = lastY /\n                (viewBox[3] - viewBox[1]) * (dataBox[3] - dataBox[1]) +\n            dataBox[1];\n\n        dataBox[0] = (dataBox[0] - cx) * scale + cx;\n        dataBox[2] = (dataBox[2] - cx) * scale + cx;\n        dataBox[1] = (dataBox[1] - cy) * scale + cy;\n        dataBox[3] = (dataBox[3] - cy) * scale + cy;\n\n        scene.setRanges(dataBox);\n\n        result.lastInputTime = Date.now();\n        unSetAutoRange();\n        scene.cameraChanged();\n        scene.handleAnnotations();\n        scene.relayoutCallback();\n\n        return true;\n    }, true);\n\n    return result;\n}\n",null]}