{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-cone3d/cone.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-cone3d/cone.js","mtime":1529418308618},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["\"use strict\";\n\nvar V = require('gl-vec3');\nvar V4 = require('gl-vec4');\n\nvar vec3 = function(x, y, z) {\n\tvar v = V.create();\n\tif (x !== undefined) {\n\t\tV.set(v, x, y, z);\n\t}\n\treturn v;\n}\n\nvar createPositionsForMeshgrid = function(meshgrid) {\n\tvar xs = meshgrid[0], ys = meshgrid[1], zs = meshgrid[2];\n\tvar positions = [];\n\tfor (var z=0; z<zs.length; z++) {\n\t\tfor (var y=0; y<ys.length; y++) {\n\t\t\tfor (var x=0; x<xs.length; x++) {\n\t\t\t\tpositions.push([zs[z], ys[y], xs[x]]);\n\t\t\t}\n\t\t}\n\t}\n\treturn positions;\n};\n\nvar findLastSmallerIndex = function(points, v) {\n\tfor (var i=0; i<points.length; i++) {\n\t\tif (points[i] >= v) {\n\t\t\treturn i-1;\n\t\t}\n\t}\n\treturn i;\n};\n\nvar tmp = V.create();\nvar tmp2 = V.create();\n\nvar clamp = function(v, min, max) {\n\treturn v < min ? min : (v > max ? max : v);\n};\n\nvar sampleMeshgrid = function(point, array, meshgrid, clampOverflow) {\n\tvar x = point[0];\n\tvar y = point[1];\n\tvar z = point[2];\n\n\tvar w = meshgrid[0].length;\n\tvar h = meshgrid[1].length;\n\tvar d = meshgrid[2].length;\n\n\t// Find the index of the nearest smaller value in the meshgrid for each coordinate of (x,y,z).\n\t// The nearest smaller value index for x is the index x0 such that\n\t// meshgrid[0][x0] < x and for all x1 > x0, meshgrid[0][x1] >= x.\n\tvar x0 = findLastSmallerIndex(meshgrid[0], x);\n\tvar y0 = findLastSmallerIndex(meshgrid[1], y);\n\tvar z0 = findLastSmallerIndex(meshgrid[2], z);\n\n\t// Get the nearest larger meshgrid value indices.\n\t// From the above \"nearest smaller value\", we know that\n\t//   meshgrid[0][x0] < x\n\t//   meshgrid[0][x0+1] >= x\n\tvar x1 = x0 + 1;\n\tvar y1 = y0 + 1;\n\tvar z1 = z0 + 1;\n\n\tif (clampOverflow) {\n\t\tx0 = clamp(x0, 0, w-1);\n\t\tx1 = clamp(x1, 0, w-1);\n\t\ty0 = clamp(y0, 0, h-1);\n\t\ty1 = clamp(y1, 0, h-1);\n\t\tz0 = clamp(z0, 0, d-1);\n\t\tz1 = clamp(z1, 0, d-1);\n\t}\n\n\t// Reject points outside the meshgrid, return a zero vector.\n\tif (x0 < 0 || y0 < 0 || z0 < 0 || x1 >= w || y1 >= h || z1 >= d) {\n\t\treturn V.create();\n\t}\n\n\t// Normalize point coordinates to 0..1 scaling factor between x0 and x1.\n\tvar xf = (x - meshgrid[0][x0]) / (meshgrid[0][x1] - meshgrid[0][x0]);\n\tvar yf = (y - meshgrid[1][y0]) / (meshgrid[1][y1] - meshgrid[1][y0]);\n\tvar zf = (z - meshgrid[2][z0]) / (meshgrid[2][z1] - meshgrid[2][z0]);\n\n\tif (xf < 0 || xf > 1 || isNaN(xf)) xf = 0;\n\tif (yf < 0 || yf > 1 || isNaN(yf)) yf = 0;\n\tif (zf < 0 || zf > 1 || isNaN(zf)) zf = 0;\n\n\tvar z0off = z0*w*h;\n\tvar z1off = z1*w*h;\n\n\tvar y0off = y0*w;\n\tvar y1off = y1*w;\n\n\tvar x0off = x0;\n\tvar x1off = x1;\n\n\t// Sample data array around the (x,y,z) point.\n\t//  vZYX = array[zZoff + yYoff + xXoff]\n\tvar v000 = array[y0off + z0off + x0off];\n\tvar v001 = array[y0off + z0off + x1off];\n\tvar v010 = array[y1off + z0off + x0off];\n\tvar v011 = array[y1off + z0off + x1off];\n\tvar v100 = array[y0off + z1off + x0off];\n\tvar v101 = array[y0off + z1off + x1off];\n\tvar v110 = array[y1off + z1off + x0off];\n\tvar v111 = array[y1off + z1off + x1off];\n\n\tvar result = V.create();\n\n\t// Average samples according to distance to point.\n\tV.lerp(result, v000, v001, xf);\n\tV.lerp(tmp, v010, v011, xf);\n\tV.lerp(result, result, tmp, yf);\n\tV.lerp(tmp, v100, v101, xf);\n\tV.lerp(tmp2, v110, v111, xf);\n\tV.lerp(tmp, tmp, tmp2, yf);\n\tV.lerp(result, result, tmp, zf);\n\n\treturn result;\n};\n\nvar getOrthogonalVector = function(dst, v) {\n\t// Return up-vector for only-z vector.\n\tif (v[0] === 0 && v[1] === 0) {\n\t\tV.set(dst, 0, 1, 0);\n\t} else {\n\t\t// Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\n\t\t// From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\n\t\t// Assign z = 0, x = -b, y = a:\n\t\t// a*-b + b*a + c*0 = -ba + ba + 0 = 0\n\t\tV.set(dst, -v[1], v[0], 0);\n\t}\n\treturn dst;\n};\n\nmodule.exports = function(vectorfield, bounds) {\n\tvar positions;\n\tif (vectorfield.positions) {\n\t\tpositions = vectorfield.positions;\n\t} else {\n\t\tpositions = createPositionsForMeshgrid(vectorfield.meshgrid);\n\t}\n\tvar meshgrid = vectorfield.meshgrid;\n\tvar vectors = vectorfield.vectors;\n\tvar geo = {\n\t\tpositions: [],\n\t\tvertexIntensity: [],\n\t\tvertexIntensityBounds: vectorfield.vertexIntensityBounds,\n\t\tvertexNormals: [],\n\t\tvectors: [],\n\t\tcells: [],\n\t\tconeOffset: vectorfield.coneOffset,\n\t\tcolormap: vectorfield.colormap\n\t};\n\n\tif (vectorfield.positions.length === 0) {\n\t\tif (bounds) {\n\t\t\tbounds[0] = [0,0,0];\n\t\t\tbounds[1] = [0,0,0];\n\t\t}\n\t\treturn geo;\n\t}\n\n\t// Compute bounding box for the dataset.\n\t// Compute maximum velocity for the dataset to use for scaling the cones.\n\tvar maxNorm = 0;\n\tvar minX = 1/0, maxX = -1/0;\n\tvar minY = 1/0, maxY = -1/0;\n\tvar minZ = 1/0, maxZ = -1/0;\n\tvar v2 = null;\n\tvar positionVectors = [];\n\tvar minSeparation = 1/0;\n\tfor (var i = 0; i < positions.length; i++) {\n\t\tvar v1 = positions[i];\n\t\tminX = Math.min(v1[0], minX);\n\t\tmaxX = Math.max(v1[0], maxX);\n\t\tminY = Math.min(v1[1], minY);\n\t\tmaxY = Math.max(v1[1], maxY);\n\t\tminZ = Math.min(v1[2], minZ);\n\t\tmaxZ = Math.max(v1[2], maxZ);\n\t\tvar u;\n\t\tif (meshgrid) {\n\t\t\tu = sampleMeshgrid(v1, vectors, meshgrid, true);\n\t\t} else {\n\t\t\tu = vectors[i];\n\t\t}\n\t\tif (V.length(u) > maxNorm) {\n\t\t\tmaxNorm = V.length(u);\n\t\t}\n\t\tif (v2) {\n\t\t\tvar separation = V.distance(v1, v2);\n\t\t\tif (separation < minSeparation) {\n\t\t\t\tminSeparation = separation;\n\t\t\t}\n\t\t}\n\t\tv2 = v1;\n\t\tpositionVectors.push(u);\n\t}\n\tvar minV = [minX, minY, minZ];\n\tvar maxV = [maxX, maxY, maxZ];\n\tif (bounds) {\n\t\tbounds[0] = minV;\n\t\tbounds[1] = maxV;\n\t}\n\tif (maxNorm === 0) {\n\t\tmaxNorm = 1;\n\t}\n\t// Inverted max norm would map vector with norm maxNorm to 1 coord space units in length\n\tvar invertedMaxNorm = 1 / maxNorm;\n\n\tif (!isFinite(minSeparation) || isNaN(minSeparation)) {\n\t\tminSeparation = 1.0;\n\t}\n\n\t// Inverted max norm multiplied scaled by smallest found vector position distance:\n\t// Maps a vector with norm maxNorm to minSeparation coord space units in length.\n\t// In practice, scales maxNorm vectors so that they are just long enough to reach the adjacent vector position.\n\tgeo.vectorScale = invertedMaxNorm * minSeparation;\n\n\tvar nml = vec3(0,1,0);\n\n\tvar coneScale = vectorfield.coneSize || 0.5;\n\n\tif (vectorfield.absoluteConeSize) {\n\t\tconeScale = vectorfield.absoluteConeSize * invertedMaxNorm;\n\t}\n\n\tgeo.coneScale = coneScale;\n\n\t// Build the cone model.\n\tfor (var i = 0, j = 0; i < positions.length; i++) {\n\t\tvar p = positions[i];\n\t\tvar x = p[0], y = p[1], z = p[2];\n\t\tvar d = positionVectors[i];\n\t\tvar intensity = V.length(d) * invertedMaxNorm;\n\t\tfor (var k = 0, l = 8; k < l; k++) {\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\n\t\t\tgeo.vertexIntensity.push(intensity, intensity, intensity);\n\t\t\tgeo.vertexIntensity.push(intensity, intensity, intensity);\n\n\t\t\tgeo.vertexNormals.push(nml, nml, nml);\n\t\t\tgeo.vertexNormals.push(nml, nml, nml);\n\n\t\t\tvar m = geo.positions.length;\n\t\t\tgeo.cells.push([m-6, m-5, m-4], [m-3, m-2, m-1]);\n\t\t}\n\t}\n\n\treturn geo;\n};\n\nmodule.exports.createConeMesh = require('./lib/conemesh');\n",null]}