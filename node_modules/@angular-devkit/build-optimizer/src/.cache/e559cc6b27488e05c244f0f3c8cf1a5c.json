{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/lib/keyed_container.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/lib/keyed_container.js","mtime":1529418310674},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar nestedProperty = require('./nested_property');\n\nvar SIMPLE_PROPERTY_REGEX = /^\\w*$/;\n\n// bitmask for deciding what's updated. Sometimes the name needs to be updated,\n// sometimes the value needs to be updated, and sometimes both do. This is just\n// a simple way to track what's updated such that it's a simple OR operation to\n// assimilate new updates.\n//\n// The only exception is the UNSET bit that tracks when we need to explicitly\n// unset and remove the property. This concrn arises because of the special\n// way in which nestedProperty handles null/undefined. When you specify `null`,\n// it prunes any unused items in the tree. I ran into some issues with it getting\n// null vs undefined confused, so UNSET is just a bit that forces the property\n// update to send `null`, removing the property explicitly rather than setting\n// it to undefined.\nvar NONE = 0;\nvar NAME = 1;\nvar VALUE = 2;\nvar BOTH = 3;\nvar UNSET = 4;\n\nmodule.exports = function keyedContainer(baseObj, path, keyName, valueName) {\n    keyName = keyName || 'name';\n    valueName = valueName || 'value';\n    var i, arr, baseProp;\n    var changeTypes = {};\n\n    if(path && path.length) {\n        baseProp = nestedProperty(baseObj, path);\n        arr = baseProp.get();\n    } else {\n        arr = baseObj;\n    }\n\n    path = path || '';\n\n    // Construct an index:\n    var indexLookup = {};\n    if(arr) {\n        for(i = 0; i < arr.length; i++) {\n            indexLookup[arr[i][keyName]] = i;\n        }\n    }\n\n    var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);\n\n    var obj = {\n        set: function(name, value) {\n            var changeType = value === null ? UNSET : NONE;\n\n            // create the base array if necessary\n            if(!arr) {\n                if(!baseProp || changeType === UNSET) return;\n\n                arr = [];\n                baseProp.set(arr);\n            }\n\n            var idx = indexLookup[name];\n            if(idx === undefined) {\n                if(changeType === UNSET) return;\n\n                changeType = changeType | BOTH;\n                idx = arr.length;\n                indexLookup[name] = idx;\n            } else if(value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {\n                changeType = changeType | VALUE;\n            }\n\n            var newValue = arr[idx] = arr[idx] || {};\n            newValue[keyName] = name;\n\n            if(isSimpleValueProp) {\n                newValue[valueName] = value;\n            } else {\n                nestedProperty(newValue, valueName).set(value);\n            }\n\n            // If it's not an unset, force that bit to be unset. This is all related to the fact\n            // that undefined and null are a bit specially implemented in nestedProperties.\n            if(value !== null) {\n                changeType = changeType & ~UNSET;\n            }\n\n            changeTypes[idx] = changeTypes[idx] | changeType;\n\n            return obj;\n        },\n        get: function(name) {\n            if(!arr) return;\n\n            var idx = indexLookup[name];\n\n            if(idx === undefined) {\n                return undefined;\n            } else if(isSimpleValueProp) {\n                return arr[idx][valueName];\n            } else {\n                return nestedProperty(arr[idx], valueName).get();\n            }\n        },\n        rename: function(name, newName) {\n            var idx = indexLookup[name];\n\n            if(idx === undefined) return obj;\n            changeTypes[idx] = changeTypes[idx] | NAME;\n\n            indexLookup[newName] = idx;\n            delete indexLookup[name];\n\n            arr[idx][keyName] = newName;\n\n            return obj;\n        },\n        remove: function(name) {\n            var idx = indexLookup[name];\n\n            if(idx === undefined) return obj;\n\n            var object = arr[idx];\n            if(Object.keys(object).length > 2) {\n                // This object contains more than just the key/value, so unset\n                // the value without modifying the entry otherwise:\n                changeTypes[idx] = changeTypes[idx] | VALUE;\n                return obj.set(name, null);\n            }\n\n            if(isSimpleValueProp) {\n                for(i = idx; i < arr.length; i++) {\n                    changeTypes[i] = changeTypes[i] | BOTH;\n                }\n                for(i = idx; i < arr.length; i++) {\n                    indexLookup[arr[i][keyName]]--;\n                }\n                arr.splice(idx, 1);\n                delete(indexLookup[name]);\n            } else {\n                // Perform this update *strictly* so we can check whether the result's\n                // been pruned. If so, it's a removal. If not, it's a value unset only.\n                nestedProperty(object, valueName).set(null);\n\n                // Now check if the top level nested property has any keys left. If so,\n                // the object still has values so we only want to unset the key. If not,\n                // the entire object can be removed since there's no other data.\n                // var topLevelKeys = Object.keys(object[valueName.split('.')[0]] || []);\n\n                changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;\n            }\n\n            return obj;\n        },\n        constructUpdate: function() {\n            var astr, idx;\n            var update = {};\n            var changed = Object.keys(changeTypes);\n            for(var i = 0; i < changed.length; i++) {\n                idx = changed[i];\n                astr = path + '[' + idx + ']';\n                if(arr[idx]) {\n                    if(changeTypes[idx] & NAME) {\n                        update[astr + '.' + keyName] = arr[idx][keyName];\n                    }\n                    if(changeTypes[idx] & VALUE) {\n                        if(isSimpleValueProp) {\n                            update[astr + '.' + valueName] = (changeTypes[idx] & UNSET) ? null : arr[idx][valueName];\n                        } else {\n                            update[astr + '.' + valueName] = (changeTypes[idx] & UNSET) ? null : nestedProperty(arr[idx], valueName).get();\n                        }\n                    }\n                } else {\n                    update[astr] = null;\n                }\n            }\n\n            return update;\n        }\n    };\n\n    return obj;\n};\n",null]}