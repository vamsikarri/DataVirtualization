{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/pie/calc.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/pie/calc.js","mtime":1529418310729},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar tinycolor = require('tinycolor2');\n\nvar Color = require('../../components/color');\nvar helpers = require('./helpers');\n\nmodule.exports = function calc(gd, trace) {\n    var vals = trace.values;\n    var hasVals = isArrayOrTypedArray(vals) && vals.length;\n    var labels = trace.labels;\n    var colors = trace.marker.colors || [];\n    var cd = [];\n    var fullLayout = gd._fullLayout;\n    var colorWay = fullLayout.colorway;\n    var colorMap = fullLayout._piecolormap;\n    var allThisTraceLabels = {};\n    var vTotal = 0;\n    var hiddenLabels = fullLayout.hiddenlabels || [];\n\n    var i, v, label, hidden, pt;\n\n    if(!fullLayout._piecolorway && colorWay !== Color.defaults) {\n        fullLayout._piecolorway = generateDefaultColors(colorWay);\n    }\n\n    if(trace.dlabel) {\n        labels = new Array(vals.length);\n        for(i = 0; i < vals.length; i++) {\n            labels[i] = String(trace.label0 + i * trace.dlabel);\n        }\n    }\n\n    function pullColor(color, label) {\n        if(!color) return false;\n\n        color = tinycolor(color);\n        if(!color.isValid()) return false;\n\n        color = Color.addOpacity(color, color.getAlpha());\n        if(!colorMap[label]) colorMap[label] = color;\n\n        return color;\n    }\n\n    var seriesLen = (hasVals ? vals : labels).length;\n\n    for(i = 0; i < seriesLen; i++) {\n        if(hasVals) {\n            v = vals[i];\n            if(!isNumeric(v)) continue;\n            v = +v;\n            if(v < 0) continue;\n        }\n        else v = 1;\n\n        label = labels[i];\n        if(label === undefined || label === '') label = i;\n        label = String(label);\n\n        var thisLabelIndex = allThisTraceLabels[label];\n        if(thisLabelIndex === undefined) {\n            allThisTraceLabels[label] = cd.length;\n\n            hidden = hiddenLabels.indexOf(label) !== -1;\n\n            if(!hidden) vTotal += v;\n\n            cd.push({\n                v: v,\n                label: label,\n                color: pullColor(colors[i]),\n                i: i,\n                pts: [i],\n                hidden: hidden\n            });\n        }\n        else {\n            pt = cd[thisLabelIndex];\n            pt.v += v;\n            pt.pts.push(i);\n            if(!pt.hidden) vTotal += v;\n\n            if(pt.color === false && colors[i]) {\n                pt.color = pullColor(colors[i], label);\n            }\n        }\n    }\n\n    if(trace.sort) cd.sort(function(a, b) { return b.v - a.v; });\n\n    /**\n     * now go back and fill in colors we're still missing\n     * this is done after sorting, so we pick defaults\n     * in the order slices will be displayed\n     */\n\n    for(i = 0; i < cd.length; i++) {\n        pt = cd[i];\n        if(pt.color === false) {\n            // have we seen this label and assigned a color to it in a previous trace?\n            if(colorMap[pt.label]) {\n                pt.color = colorMap[pt.label];\n            }\n            else {\n                colorMap[pt.label] = pt.color = nextDefaultColor(\n                    fullLayout._piedefaultcolorcount,\n                    fullLayout._piecolorway\n                );\n                fullLayout._piedefaultcolorcount++;\n            }\n        }\n    }\n\n    // include the sum of all values in the first point\n    if(cd[0]) cd[0].vTotal = vTotal;\n\n    // now insert text\n    if(trace.textinfo && trace.textinfo !== 'none') {\n        var hasLabel = trace.textinfo.indexOf('label') !== -1;\n        var hasText = trace.textinfo.indexOf('text') !== -1;\n        var hasValue = trace.textinfo.indexOf('value') !== -1;\n        var hasPercent = trace.textinfo.indexOf('percent') !== -1;\n        var separators = fullLayout.separators;\n\n        var thisText;\n\n        for(i = 0; i < cd.length; i++) {\n            pt = cd[i];\n            thisText = hasLabel ? [pt.label] : [];\n            if(hasText) {\n                var texti = helpers.getFirstFilled(trace.text, pt.pts);\n                if(texti) thisText.push(texti);\n            }\n            if(hasValue) thisText.push(helpers.formatPieValue(pt.v, separators));\n            if(hasPercent) thisText.push(helpers.formatPiePercent(pt.v / vTotal, separators));\n            pt.text = thisText.join('<br>');\n        }\n    }\n\n    return cd;\n};\n\n/**\n * pick a default color from the main default set, augmented by\n * itself lighter then darker before repeating\n */\nvar pieDefaultColors;\n\nfunction nextDefaultColor(index, pieColorWay) {\n    if(!pieDefaultColors) {\n        // generate this default set on demand (but then it gets saved in the module)\n        var mainDefaults = Color.defaults;\n        pieDefaultColors = generateDefaultColors(mainDefaults);\n    }\n\n    var pieColors = pieColorWay || pieDefaultColors;\n    return pieColors[index % pieColors.length];\n}\n\nfunction generateDefaultColors(colorList) {\n    var i;\n\n    var pieColors = colorList.slice();\n\n    for(i = 0; i < colorList.length; i++) {\n        pieColors.push(tinycolor(colorList[i]).lighten(20).toHexString());\n    }\n\n    for(i = 0; i < colorList.length; i++) {\n        pieColors.push(tinycolor(colorList[i]).darken(20).toHexString());\n    }\n\n    return pieColors;\n}\n",null]}