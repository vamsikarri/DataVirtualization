{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/simplicial-complex-contour/contour.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/simplicial-complex-contour/contour.js","mtime":1529418311909},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\n\nmodule.exports = extractContour\n\nvar ndarray = require('ndarray')\nvar pool    = require('typedarray-pool')\nvar ndsort  = require('ndarray-sort')\n\nvar contourAlgorithm = require('./lib/codegen')\n\nfunction getDimension(cells) {\n  var numCells = cells.length\n  var d = 0\n  for(var i=0; i<numCells; ++i) {\n    d = Math.max(d, cells[i].length)|0\n  }\n  return d-1\n}\n\nfunction getSigns(values, level) {\n  var numVerts    = values.length\n  var vertexSigns = pool.mallocUint8(numVerts)\n  for(var i=0; i<numVerts; ++i) {\n    vertexSigns[i] = (values[i] < level)|0\n  }\n  return vertexSigns\n}\n\nfunction getEdges(cells, d) {\n  var numCells = cells.length\n  var maxEdges = ((d * (d+1)/2) * numCells)|0\n  var edges    = pool.mallocUint32(maxEdges*2)\n  var ePtr     = 0\n  for(var i=0; i<numCells; ++i) {\n    var c = cells[i]\n    var d = c.length\n    for(var j=0; j<d; ++j) {\n      for(var k=0; k<j; ++k) {\n        var a = c[k]\n        var b = c[j]\n        edges[ePtr++] = Math.min(a,b)|0\n        edges[ePtr++] = Math.max(a,b)|0\n      }\n    }\n  }\n  var nedges = (ePtr/2)|0\n  ndsort(ndarray(edges, [nedges,2])) \n  var ptr = 2\n  for(var i=2; i<ePtr; i+=2) {\n    if(edges[i-2] === edges[i] &&\n       edges[i-1] === edges[i+1]) {\n      continue\n    }\n    edges[ptr++] = edges[i]\n    edges[ptr++] = edges[i+1]\n  }\n\n  return ndarray(edges, [(ptr/2)|0, 2])\n}\n\nfunction getCrossingWeights(edges, values, signs, level) {\n  var edata     = edges.data\n  var numEdges  = edges.shape[0]\n  var weights   = pool.mallocDouble(numEdges)\n  var ptr       = 0\n  for(var i=0; i<numEdges; ++i) {\n    var a  = edata[2*i]\n    var b  = edata[2*i+1]\n    if(signs[a] === signs[b]) {\n      continue\n    }\n    var va = values[a]\n    var vb = values[b]\n    edata[2*ptr]     = a\n    edata[2*ptr+1]   = b\n    weights[ptr++]   = (vb - level) / (vb - va)\n  }\n  edges.shape[0] = ptr\n  return ndarray(weights, [ptr])\n}\n\nfunction getCascade(edges, numVerts) {\n  var result   = pool.mallocInt32(numVerts*2)\n  var numEdges = edges.shape[0]\n  var edata    = edges.data\n  result[0]    = 0\n  var lastV    = 0\n  for(var i=0; i<numEdges; ++i) {\n    var a = edata[2*i]\n    if(a !== lastV) {\n      result[2*lastV+1] = i\n      while(++lastV < a) {\n        result[2*lastV] = i\n        result[2*lastV+1] = i\n      }\n      result[2*lastV] = i\n    }\n  }\n  result[2*lastV+1] = numEdges\n  while(++lastV < numVerts) {\n    result[2*lastV] = result[2*lastV+1] = numEdges\n  }\n  return result\n}\n\nfunction unpackEdges(edges) {\n  var ne = edges.shape[0]|0\n  var edata = edges.data\n  var result = new Array(ne)\n  for(var i=0; i<ne; ++i) {\n    result[i] = [edata[2*i], edata[2*i+1]]\n  }\n  return result\n}\n\nfunction extractContour(cells, values, level, d) {\n  level = level||0.0\n\n  //If user didn't specify `d`, use brute force scan\n  if(typeof d === 'undefined') {\n    d = getDimension(cells)\n  }\n\n  //Count number of cells\n  var numCells = cells.length\n  if(numCells === 0 || d < 1) {\n    return {\n      cells:         [],\n      vertexIds:     [],\n      vertexWeights: []\n    }\n  }\n\n  //Read in vertex signs\n  var vertexSigns = getSigns(values, +level)\n\n  //First get 1-skeleton, find all crossings\n  var edges   = getEdges(cells, d)\n  var weights = getCrossingWeights(edges, values, vertexSigns, +level)\n\n  //Build vertex cascade to speed up binary search\n  var vcascade = getCascade(edges, values.length|0)\n\n  //Then construct cells\n  var faces = contourAlgorithm(d)(cells, edges.data, vcascade, vertexSigns)\n\n  //Unpack data into pretty format\n  var uedges   = unpackEdges(edges)\n  var uweights = [].slice.call(weights.data, 0, weights.shape[0])\n\n  //Release data\n  pool.free(vertexSigns)\n  pool.free(edges.data)\n  pool.free(weights.data)\n  pool.free(vcascade)\n  \n  return {\n    cells:         faces,\n    vertexIds:     uedges,\n    vertexWeights: uweights\n  }\n}",null]}