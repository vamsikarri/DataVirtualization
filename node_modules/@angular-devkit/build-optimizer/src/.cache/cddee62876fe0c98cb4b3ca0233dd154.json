{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/contour/plot.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/contour/plot.js","mtime":1529418310714},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvert = require('../../plots/cartesian/set_convert');\nvar getUidsFromCalcData = require('../../plots/get_data').getUidsFromCalcData;\n\nvar heatmapPlot = require('../heatmap/plot');\nvar makeCrossings = require('./make_crossings');\nvar findAllPaths = require('./find_all_paths');\nvar emptyPathinfo = require('./empty_pathinfo');\nvar convertToConstraints = require('./convert_to_constraints');\nvar closeBoundaries = require('./close_boundaries');\nvar constants = require('./constants');\nvar costConstants = constants.LABELOPTIMIZER;\n\nexports.plot = function plot(gd, plotinfo, cdcontours, contourLayer) {\n    var uidLookup = getUidsFromCalcData(cdcontours);\n\n    contourLayer.selectAll('g.contour').each(function(d) {\n        if(!uidLookup[d.trace.uid]) {\n            d3.select(this).remove();\n        }\n    });\n\n    for(var i = 0; i < cdcontours.length; i++) {\n        plotOne(gd, plotinfo, cdcontours[i], contourLayer);\n    }\n};\n\nfunction plotOne(gd, plotinfo, cd, contourLayer) {\n    var trace = cd[0].trace;\n    var x = cd[0].x;\n    var y = cd[0].y;\n    var contours = trace.contours;\n    var id = 'contour' + trace.uid;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var fullLayout = gd._fullLayout;\n    var pathinfo = emptyPathinfo(contours, plotinfo, cd[0]);\n\n    // use a heatmap to fill - draw it behind the lines\n    var heatmapColoringLayer = Lib.ensureSingle(contourLayer, 'g', 'heatmapcoloring');\n    var cdheatmaps = [];\n    if(contours.coloring === 'heatmap') {\n        if(trace.zauto && (trace.autocontour === false)) {\n            trace._input.zmin = trace.zmin =\n                contours.start - contours.size / 2;\n            trace._input.zmax = trace.zmax =\n                trace.zmin + pathinfo.length * contours.size;\n        }\n        cdheatmaps = [cd];\n    }\n    heatmapPlot(gd, plotinfo, cdheatmaps, heatmapColoringLayer);\n\n    makeCrossings(pathinfo);\n    findAllPaths(pathinfo);\n\n    var leftedge = xa.c2p(x[0], true),\n        rightedge = xa.c2p(x[x.length - 1], true),\n        bottomedge = ya.c2p(y[0], true),\n        topedge = ya.c2p(y[y.length - 1], true),\n        perimeter = [\n            [leftedge, topedge],\n            [rightedge, topedge],\n            [rightedge, bottomedge],\n            [leftedge, bottomedge]\n        ];\n\n    var fillPathinfo = pathinfo;\n    if(contours.type === 'constraint') {\n        fillPathinfo = convertToConstraints(pathinfo, contours._operation);\n        closeBoundaries(fillPathinfo, contours._operation, perimeter, trace);\n    }\n\n    // draw everything\n    var plotGroup = exports.makeContourGroup(contourLayer, cd, id);\n    makeBackground(plotGroup, perimeter, contours);\n    makeFills(plotGroup, fillPathinfo, perimeter, contours);\n    makeLinesAndLabels(plotGroup, pathinfo, gd, cd[0], contours, perimeter);\n    clipGaps(plotGroup, plotinfo, fullLayout._clips, cd[0], perimeter);\n}\n\nexports.makeContourGroup = function(layer, cd, id) {\n    var plotgroup = layer\n        .selectAll('g.contour.' + id)\n        .data(cd);\n\n    plotgroup.enter().append('g')\n        .classed('contour', true)\n        .classed(id, true);\n\n    plotgroup.exit().remove();\n\n    return plotgroup;\n};\n\nfunction makeBackground(plotgroup, perimeter, contours) {\n    var bggroup = Lib.ensureSingle(plotgroup, 'g', 'contourbg');\n\n    var bgfill = bggroup.selectAll('path')\n        .data(contours.coloring === 'fill' ? [0] : []);\n    bgfill.enter().append('path');\n    bgfill.exit().remove();\n    bgfill\n        .attr('d', 'M' + perimeter.join('L') + 'Z')\n        .style('stroke', 'none');\n}\n\nfunction makeFills(plotgroup, pathinfo, perimeter, contours) {\n    var fillgroup = Lib.ensureSingle(plotgroup, 'g', 'contourfill');\n\n    var fillitems = fillgroup.selectAll('path')\n        .data(contours.coloring === 'fill' || (contours.type === 'constraint' && contours._operation !== '=') ? pathinfo : []);\n    fillitems.enter().append('path');\n    fillitems.exit().remove();\n    fillitems.each(function(pi) {\n        // join all paths for this level together into a single path\n        // first follow clockwise around the perimeter to close any open paths\n        // if the whole perimeter is above this level, start with a path\n        // enclosing the whole thing. With all that, the parity should mean\n        // that we always fill everything above the contour, nothing below\n        var fullpath = joinAllPaths(pi, perimeter);\n\n        if(!fullpath) d3.select(this).remove();\n        else d3.select(this).attr('d', fullpath).style('stroke', 'none');\n    });\n}\n\nfunction initFullPath(pi, perimeter) {\n    var prefixBoundary = pi.prefixBoundary;\n    if(prefixBoundary === undefined) {\n        var edgeVal2 = Math.min(pi.z[0][0], pi.z[0][1]);\n        prefixBoundary = (!pi.edgepaths.length && edgeVal2 > pi.level);\n    }\n\n    if(prefixBoundary) {\n        // TODO: why does ^^ not work for constraints?\n        // pi.prefixBoundary gets set by closeBoundaries\n        return 'M' + perimeter.join('L') + 'Z';\n    }\n    return '';\n}\n\nfunction joinAllPaths(pi, perimeter) {\n    var fullpath = initFullPath(pi, perimeter),\n        i = 0,\n        startsleft = pi.edgepaths.map(function(v, i) { return i; }),\n        newloop = true,\n        endpt,\n        newendpt,\n        cnt,\n        nexti,\n        possiblei,\n        addpath;\n\n    function istop(pt) { return Math.abs(pt[1] - perimeter[0][1]) < 0.01; }\n    function isbottom(pt) { return Math.abs(pt[1] - perimeter[2][1]) < 0.01; }\n    function isleft(pt) { return Math.abs(pt[0] - perimeter[0][0]) < 0.01; }\n    function isright(pt) { return Math.abs(pt[0] - perimeter[2][0]) < 0.01; }\n\n    while(startsleft.length) {\n        addpath = Drawing.smoothopen(pi.edgepaths[i], pi.smoothing);\n        fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n        startsleft.splice(startsleft.indexOf(i), 1);\n        endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n        nexti = -1;\n\n        // now loop through sides, moving our endpoint until we find a new start\n        for(cnt = 0; cnt < 4; cnt++) { // just to prevent infinite loops\n            if(!endpt) {\n                Lib.log('Missing end?', i, pi);\n                break;\n            }\n\n            if(istop(endpt) && !isright(endpt)) newendpt = perimeter[1]; // right top\n            else if(isleft(endpt)) newendpt = perimeter[0]; // left top\n            else if(isbottom(endpt)) newendpt = perimeter[3]; // right bottom\n            else if(isright(endpt)) newendpt = perimeter[2]; // left bottom\n\n            for(possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n                var ptNew = pi.edgepaths[possiblei][0];\n                // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n                if(Math.abs(endpt[0] - newendpt[0]) < 0.01) {\n                    if(Math.abs(endpt[0] - ptNew[0]) < 0.01 &&\n                            (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                }\n                else if(Math.abs(endpt[1] - newendpt[1]) < 0.01) {\n                    if(Math.abs(endpt[1] - ptNew[1]) < 0.01 &&\n                            (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                }\n                else {\n                    Lib.log('endpt to newendpt is not vert. or horz.',\n                        endpt, newendpt, ptNew);\n                }\n            }\n\n            endpt = newendpt;\n\n            if(nexti >= 0) break;\n            fullpath += 'L' + newendpt;\n        }\n\n        if(nexti === pi.edgepaths.length) {\n            Lib.log('unclosed perimeter path');\n            break;\n        }\n\n        i = nexti;\n\n        // if we closed back on a loop we already included,\n        // close it and start a new loop\n        newloop = (startsleft.indexOf(i) === -1);\n        if(newloop) {\n            i = startsleft[0];\n            fullpath += 'Z';\n        }\n    }\n\n    // finally add the interior paths\n    for(i = 0; i < pi.paths.length; i++) {\n        fullpath += Drawing.smoothclosed(pi.paths[i], pi.smoothing);\n    }\n\n    return fullpath;\n}\n\nfunction makeLinesAndLabels(plotgroup, pathinfo, gd, cd0, contours, perimeter) {\n    var lineContainer = Lib.ensureSingle(plotgroup, 'g', 'contourlines');\n    var showLines = contours.showlines !== false;\n    var showLabels = contours.showlabels;\n    var clipLinesForLabels = showLines && showLabels;\n\n    // Even if we're not going to show lines, we need to create them\n    // if we're showing labels, because the fill paths include the perimeter\n    // so can't be used to position the labels correctly.\n    // In this case we'll remove the lines after making the labels.\n    var linegroup = exports.createLines(lineContainer, showLines || showLabels, pathinfo);\n\n    var lineClip = exports.createLineClip(lineContainer, clipLinesForLabels,\n        gd._fullLayout._clips, cd0.trace.uid);\n\n    var labelGroup = plotgroup.selectAll('g.contourlabels')\n        .data(showLabels ? [0] : []);\n\n    labelGroup.exit().remove();\n\n    labelGroup.enter().append('g')\n        .classed('contourlabels', true);\n\n    if(showLabels) {\n        var labelClipPathData = [perimeter];\n\n        var labelData = [];\n\n        // invalidate the getTextLocation cache in case paths changed\n        Lib.clearLocationCache();\n\n        var contourFormat = exports.labelFormatter(contours, cd0.t.cb, gd._fullLayout);\n\n        var dummyText = Drawing.tester.append('text')\n            .attr('data-notex', 1)\n            .call(Drawing.font, contours.labelfont);\n\n        var xLen = pathinfo[0].xaxis._length;\n        var yLen = pathinfo[0].yaxis._length;\n\n        // visible bounds of the contour trace (and the midpoints, to\n        // help with cost calculations)\n        var bounds = {\n            left: Math.max(perimeter[0][0], 0),\n            right: Math.min(perimeter[2][0], xLen),\n            top: Math.max(perimeter[0][1], 0),\n            bottom: Math.min(perimeter[2][1], yLen)\n        };\n        bounds.middle = (bounds.top + bounds.bottom) / 2;\n        bounds.center = (bounds.left + bounds.right) / 2;\n\n        var plotDiagonal = Math.sqrt(xLen * xLen + yLen * yLen);\n\n        // the path length to use to scale the number of labels to draw:\n        var normLength = constants.LABELDISTANCE * plotDiagonal /\n            Math.max(1, pathinfo.length / constants.LABELINCREASE);\n\n        linegroup.each(function(d) {\n            var textOpts = exports.calcTextOpts(d.level, contourFormat, dummyText, gd);\n\n            d3.select(this).selectAll('path').each(function() {\n                var path = this;\n                var pathBounds = Lib.getVisibleSegment(path, bounds, textOpts.height / 2);\n                if(!pathBounds) return;\n\n                if(pathBounds.len < (textOpts.width + textOpts.height) * constants.LABELMIN) return;\n\n                var maxLabels = Math.min(Math.ceil(pathBounds.len / normLength),\n                    constants.LABELMAX);\n\n                for(var i = 0; i < maxLabels; i++) {\n                    var loc = exports.findBestTextLocation(path, pathBounds, textOpts,\n                        labelData, bounds);\n\n                    if(!loc) break;\n\n                    exports.addLabelData(loc, textOpts, labelData, labelClipPathData);\n                }\n            });\n        });\n\n        dummyText.remove();\n\n        exports.drawLabels(labelGroup, labelData, gd, lineClip,\n            clipLinesForLabels ? labelClipPathData : null);\n    }\n\n    if(showLabels && !showLines) linegroup.remove();\n}\n\nexports.createLines = function(lineContainer, makeLines, pathinfo) {\n    var smoothing = pathinfo[0].smoothing;\n\n    var linegroup = lineContainer.selectAll('g.contourlevel')\n        .data(makeLines ? pathinfo : []);\n\n    linegroup.exit().remove();\n    linegroup.enter().append('g')\n        .classed('contourlevel', true);\n\n    if(makeLines) {\n        // pedgepaths / ppaths are used by contourcarpet, for the paths transformed from a/b to x/y\n        // edgepaths / paths are used by contour since it's in x/y from the start\n        var opencontourlines = linegroup.selectAll('path.openline')\n            .data(function(d) { return d.pedgepaths || d.edgepaths; });\n\n        opencontourlines.exit().remove();\n        opencontourlines.enter().append('path')\n            .classed('openline', true);\n\n        opencontourlines\n            .attr('d', function(d) {\n                return Drawing.smoothopen(d, smoothing);\n            })\n            .style('stroke-miterlimit', 1)\n            .style('vector-effect', 'non-scaling-stroke');\n\n        var closedcontourlines = linegroup.selectAll('path.closedline')\n            .data(function(d) { return d.ppaths || d.paths; });\n\n        closedcontourlines.exit().remove();\n        closedcontourlines.enter().append('path')\n            .classed('closedline', true);\n\n        closedcontourlines\n            .attr('d', function(d) {\n                return Drawing.smoothclosed(d, smoothing);\n            })\n            .style('stroke-miterlimit', 1)\n            .style('vector-effect', 'non-scaling-stroke');\n    }\n\n    return linegroup;\n};\n\nexports.createLineClip = function(lineContainer, clipLinesForLabels, clips, uid) {\n    var clipId = clipLinesForLabels ? ('clipline' + uid) : null;\n\n    var lineClip = clips.selectAll('#' + clipId)\n        .data(clipLinesForLabels ? [0] : []);\n    lineClip.exit().remove();\n\n    lineClip.enter().append('clipPath')\n        .classed('contourlineclip', true)\n        .attr('id', clipId);\n\n    Drawing.setClipUrl(lineContainer, clipId);\n\n    return lineClip;\n};\n\nexports.labelFormatter = function(contours, colorbar, fullLayout) {\n    if(contours.labelformat) {\n        return fullLayout._d3locale.numberFormat(contours.labelformat);\n    }\n    else {\n        var formatAxis;\n        if(colorbar) {\n            formatAxis = colorbar.axis;\n        }\n        else {\n            formatAxis = {\n                type: 'linear',\n                _id: 'ycontour',\n                showexponent: 'all'\n            };\n\n            if(contours.type === 'constraint') {\n                var value = contours.value;\n                if(Array.isArray(value)) {\n                    formatAxis.range = [value[0], value[value.length - 1]];\n                }\n                else formatAxis.range = [value, value];\n            }\n            else {\n                formatAxis.range = [contours.start, contours.end];\n                formatAxis.nticks = (contours.end - contours.start) / contours.size;\n            }\n\n            if(formatAxis.range[0] === formatAxis.range[1]) {\n                formatAxis.range[1] += formatAxis.range[0] || 1;\n            }\n            if(!formatAxis.nticks) formatAxis.nticks = 1000;\n\n            setConvert(formatAxis, fullLayout);\n            Axes.prepTicks(formatAxis);\n            formatAxis._tmin = null;\n            formatAxis._tmax = null;\n        }\n        return function(v) {\n            return Axes.tickText(formatAxis, v).text;\n        };\n    }\n};\n\nexports.calcTextOpts = function(level, contourFormat, dummyText, gd) {\n    var text = contourFormat(level);\n    dummyText.text(text)\n        .call(svgTextUtils.convertToTspans, gd);\n    var bBox = Drawing.bBox(dummyText.node(), true);\n\n    return {\n        text: text,\n        width: bBox.width,\n        height: bBox.height,\n        level: level,\n        dy: (bBox.top + bBox.bottom) / 2\n    };\n};\n\nexports.findBestTextLocation = function(path, pathBounds, textOpts, labelData, plotBounds) {\n    var textWidth = textOpts.width;\n\n    var p0, dp, pMax, pMin, loc;\n    if(pathBounds.isClosed) {\n        dp = pathBounds.len / costConstants.INITIALSEARCHPOINTS;\n        p0 = pathBounds.min + dp / 2;\n        pMax = pathBounds.max;\n    }\n    else {\n        dp = (pathBounds.len - textWidth) / (costConstants.INITIALSEARCHPOINTS + 1);\n        p0 = pathBounds.min + dp + textWidth / 2;\n        pMax = pathBounds.max - (dp + textWidth) / 2;\n    }\n\n    var cost = Infinity;\n    for(var j = 0; j < costConstants.ITERATIONS; j++) {\n        for(var p = p0; p < pMax; p += dp) {\n            var newLocation = Lib.getTextLocation(path, pathBounds.total, p, textWidth);\n            var newCost = locationCost(newLocation, textOpts, labelData, plotBounds);\n            if(newCost < cost) {\n                cost = newCost;\n                loc = newLocation;\n                pMin = p;\n            }\n        }\n        if(cost > costConstants.MAXCOST * 2) break;\n\n        // subsequent iterations just look half steps away from the\n        // best we found in the previous iteration\n        if(j) dp /= 2;\n        p0 = pMin - dp / 2;\n        pMax = p0 + dp * 1.5;\n    }\n    if(cost <= costConstants.MAXCOST) return loc;\n};\n\n/*\n * locationCost: a cost function for label locations\n * composed of three kinds of penalty:\n * - for open paths, being close to the end of the path\n * - the angle away from horizontal\n * - being too close to already placed neighbors\n */\nfunction locationCost(loc, textOpts, labelData, bounds) {\n    var halfWidth = textOpts.width / 2;\n    var halfHeight = textOpts.height / 2;\n    var x = loc.x;\n    var y = loc.y;\n    var theta = loc.theta;\n    var dx = Math.cos(theta) * halfWidth;\n    var dy = Math.sin(theta) * halfWidth;\n\n    // cost for being near an edge\n    var normX = ((x > bounds.center) ? (bounds.right - x) : (x - bounds.left)) /\n        (dx + Math.abs(Math.sin(theta) * halfHeight));\n    var normY = ((y > bounds.middle) ? (bounds.bottom - y) : (y - bounds.top)) /\n        (Math.abs(dy) + Math.cos(theta) * halfHeight);\n    if(normX < 1 || normY < 1) return Infinity;\n    var cost = costConstants.EDGECOST * (1 / (normX - 1) + 1 / (normY - 1));\n\n    // cost for not being horizontal\n    cost += costConstants.ANGLECOST * theta * theta;\n\n    // cost for being close to other labels\n    var x1 = x - dx;\n    var y1 = y - dy;\n    var x2 = x + dx;\n    var y2 = y + dy;\n    for(var i = 0; i < labelData.length; i++) {\n        var labeli = labelData[i];\n        var dxd = Math.cos(labeli.theta) * labeli.width / 2;\n        var dyd = Math.sin(labeli.theta) * labeli.width / 2;\n        var dist = Lib.segmentDistance(\n            x1, y1,\n            x2, y2,\n            labeli.x - dxd, labeli.y - dyd,\n            labeli.x + dxd, labeli.y + dyd\n        ) * 2 / (textOpts.height + labeli.height);\n\n        var sameLevel = labeli.level === textOpts.level;\n        var distOffset = sameLevel ? costConstants.SAMELEVELDISTANCE : 1;\n\n        if(dist <= distOffset) return Infinity;\n\n        var distFactor = costConstants.NEIGHBORCOST *\n            (sameLevel ? costConstants.SAMELEVELFACTOR : 1);\n\n        cost += distFactor / (dist - distOffset);\n    }\n\n    return cost;\n}\n\nexports.addLabelData = function(loc, textOpts, labelData, labelClipPathData) {\n    var halfWidth = textOpts.width / 2;\n    var halfHeight = textOpts.height / 2;\n\n    var x = loc.x;\n    var y = loc.y;\n    var theta = loc.theta;\n\n    var sin = Math.sin(theta);\n    var cos = Math.cos(theta);\n    var dxw = halfWidth * cos;\n    var dxh = halfHeight * sin;\n    var dyw = halfWidth * sin;\n    var dyh = -halfHeight * cos;\n    var bBoxPts = [\n        [x - dxw - dxh, y - dyw - dyh],\n        [x + dxw - dxh, y + dyw - dyh],\n        [x + dxw + dxh, y + dyw + dyh],\n        [x - dxw + dxh, y - dyw + dyh],\n    ];\n\n    labelData.push({\n        text: textOpts.text,\n        x: x,\n        y: y,\n        dy: textOpts.dy,\n        theta: theta,\n        level: textOpts.level,\n        width: textOpts.width,\n        height: textOpts.height\n    });\n\n    labelClipPathData.push(bBoxPts);\n};\n\nexports.drawLabels = function(labelGroup, labelData, gd, lineClip, labelClipPathData) {\n    var labels = labelGroup.selectAll('text')\n        .data(labelData, function(d) {\n            return d.text + ',' + d.x + ',' + d.y + ',' + d.theta;\n        });\n\n    labels.exit().remove();\n\n    labels.enter().append('text')\n        .attr({\n            'data-notex': 1,\n            'text-anchor': 'middle'\n        })\n        .each(function(d) {\n            var x = d.x + Math.sin(d.theta) * d.dy;\n            var y = d.y - Math.cos(d.theta) * d.dy;\n            d3.select(this)\n                .text(d.text)\n                .attr({\n                    x: x,\n                    y: y,\n                    transform: 'rotate(' + (180 * d.theta / Math.PI) + ' ' + x + ' ' + y + ')'\n                })\n                .call(svgTextUtils.convertToTspans, gd);\n        });\n\n    if(labelClipPathData) {\n        var clipPath = '';\n        for(var i = 0; i < labelClipPathData.length; i++) {\n            clipPath += 'M' + labelClipPathData[i].join('L') + 'Z';\n        }\n\n        var lineClipPath = Lib.ensureSingle(lineClip, 'path', '');\n        lineClipPath.attr('d', clipPath);\n    }\n};\n\nfunction clipGaps(plotGroup, plotinfo, clips, cd0, perimeter) {\n    var clipId = 'clip' + cd0.trace.uid;\n\n    var clipPath = clips.selectAll('#' + clipId)\n        .data(cd0.trace.connectgaps ? [] : [0]);\n    clipPath.enter().append('clipPath')\n        .classed('contourclip', true)\n        .attr('id', clipId);\n    clipPath.exit().remove();\n\n    if(cd0.trace.connectgaps === false) {\n        var clipPathInfo = {\n            // fraction of the way from missing to present point\n            // to draw the boundary.\n            // if you make this 1 (or 1-epsilon) then a point in\n            // a sea of missing data will disappear entirely.\n            level: 0.9,\n            crossings: {},\n            starts: [],\n            edgepaths: [],\n            paths: [],\n            xaxis: plotinfo.xaxis,\n            yaxis: plotinfo.yaxis,\n            x: cd0.x,\n            y: cd0.y,\n            // 0 = no data, 1 = data\n            z: makeClipMask(cd0),\n            smoothing: 0\n        };\n\n        makeCrossings([clipPathInfo]);\n        findAllPaths([clipPathInfo]);\n        var fullpath = joinAllPaths(clipPathInfo, perimeter);\n\n        var path = Lib.ensureSingle(clipPath, 'path', '');\n        path.attr('d', fullpath);\n    }\n    else clipId = null;\n\n    plotGroup.call(Drawing.setClipUrl, clipId);\n    plotinfo.plot.selectAll('.hm' + cd0.trace.uid)\n        .call(Drawing.setClipUrl, clipId);\n}\n\nfunction makeClipMask(cd0) {\n    var empties = cd0.trace._emptypoints,\n        z = [],\n        m = cd0.z.length,\n        n = cd0.z[0].length,\n        i,\n        row = [],\n        emptyPoint;\n\n    for(i = 0; i < n; i++) row.push(1);\n    for(i = 0; i < m; i++) z.push(row.slice());\n    for(i = 0; i < empties.length; i++) {\n        emptyPoint = empties[i];\n        z[emptyPoint[0]][emptyPoint[1]] = 0;\n    }\n    // save this mask to determine whether to show this data in hover\n    cd0.zmask = z;\n    return z;\n}\n",null]}