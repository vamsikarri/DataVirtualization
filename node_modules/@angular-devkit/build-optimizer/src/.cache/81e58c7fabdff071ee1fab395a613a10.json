{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/carpet/axis_aligned_line.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/carpet/axis_aligned_line.js","mtime":1529418310704},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\n/* This function retrns a set of control points that define a curve aligned along\n * either the a or b axis. Exactly one of a or b must be an array defining the range\n * spanned.\n *\n * Honestly this is the most complicated function I've implemente here so far because\n * of the way it handles knot insertion and direction/axis-agnostic slices.\n */\nmodule.exports = function(carpet, carpetcd, a, b) {\n    var idx, tangent, tanIsoIdx, tanIsoPar, segment, refidx;\n    var p0, p1, v0, v1, start, end, range;\n\n    var axis = isArrayOrTypedArray(a) ? 'a' : 'b';\n    var ax = axis === 'a' ? carpet.aaxis : carpet.baxis;\n    var smoothing = ax.smoothing;\n    var toIdx = axis === 'a' ? carpet.a2i : carpet.b2j;\n    var pt = axis === 'a' ? a : b;\n    var iso = axis === 'a' ? b : a;\n    var n = axis === 'a' ? carpetcd.a.length : carpetcd.b.length;\n    var m = axis === 'a' ? carpetcd.b.length : carpetcd.a.length;\n    var isoIdx = Math.floor(axis === 'a' ? carpet.b2j(iso) : carpet.a2i(iso));\n\n    var xy = axis === 'a' ? function(value) {\n        return carpet.evalxy([], value, isoIdx);\n    } : function(value) {\n        return carpet.evalxy([], isoIdx, value);\n    };\n\n    if(smoothing) {\n        tanIsoIdx = Math.max(0, Math.min(m - 2, isoIdx));\n        tanIsoPar = isoIdx - tanIsoIdx;\n        tangent = axis === 'a' ? function(i, ti) {\n            return carpet.dxydi([], i, tanIsoIdx, ti, tanIsoPar);\n        } : function(j, tj) {\n            return carpet.dxydj([], tanIsoIdx, j, tanIsoPar, tj);\n        };\n    }\n\n    var vstart = toIdx(pt[0]);\n    var vend = toIdx(pt[1]);\n\n    // So that we can make this work in two directions, flip all of the\n    // math functions if the direction is from higher to lower indices:\n    //\n    // Note that the tolerance is directional!\n    var dir = vstart < vend ? 1 : -1;\n    var tol = (vend - vstart) * 1e-8;\n    var dirfloor = dir > 0 ? Math.floor : Math.ceil;\n    var dirceil = dir > 0 ? Math.ceil : Math.floor;\n    var dirmin = dir > 0 ? Math.min : Math.max;\n    var dirmax = dir > 0 ? Math.max : Math.min;\n\n    var idx0 = dirfloor(vstart + tol);\n    var idx1 = dirceil(vend - tol);\n\n    p0 = xy(vstart);\n    var segments = [[p0]];\n\n    for(idx = idx0; idx * dir < idx1 * dir; idx += dir) {\n        segment = [];\n        start = dirmax(vstart, idx);\n        end = dirmin(vend, idx + dir);\n        range = end - start;\n\n        // In order to figure out which cell we're in for the derivative (remember,\n        // the derivatives are *not* constant across grid lines), let's just average\n        // the start and end points. This cuts out just a tiny bit of logic and\n        // there's really no computational difference:\n        refidx = Math.max(0, Math.min(n - 2, Math.floor(0.5 * (start + end))));\n\n        p1 = xy(end);\n        if(smoothing) {\n            v0 = tangent(refidx, start - refidx);\n            v1 = tangent(refidx, end - refidx);\n\n            segment.push([\n                p0[0] + v0[0] / 3 * range,\n                p0[1] + v0[1] / 3 * range\n            ]);\n\n            segment.push([\n                p1[0] - v1[0] / 3 * range,\n                p1[1] - v1[1] / 3 * range\n            ]);\n        }\n\n        segment.push(p1);\n\n        segments.push(segment);\n        p0 = p1;\n    }\n\n    return segments;\n};\n",null]}