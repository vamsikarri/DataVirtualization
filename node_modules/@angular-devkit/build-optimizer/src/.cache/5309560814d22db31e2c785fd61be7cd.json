{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/parcoords/defaults.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/parcoords/defaults.js","mtime":1529418310727},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar attributes = require('./attributes');\nvar hasColorscale = require('../../components/colorscale/has_colorscale');\nvar colorscaleDefaults = require('../../components/colorscale/defaults');\nvar maxDimensionCount = require('./constants').maxDimensionCount;\nvar handleDomainDefaults = require('../../plots/domain').defaults;\nvar axisBrush = require('./axisbrush');\n\nfunction handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce) {\n    var lineColor = coerce('line.color', defaultColor);\n\n    if(hasColorscale(traceIn, 'line') && Lib.isArrayOrTypedArray(lineColor)) {\n        if(lineColor.length) {\n            coerce('line.colorscale');\n            colorscaleDefaults(traceIn, traceOut, layout, coerce, {prefix: 'line.', cLetter: 'c'});\n            // TODO: I think it would be better to keep showing lines beyond the last line color\n            // but I'm not sure what color to give these lines - probably black or white\n            // depending on the background color?\n            traceOut._length = Math.min(traceOut._length, lineColor.length);\n        }\n        else {\n            traceOut.line.color = defaultColor;\n        }\n    }\n}\n\nfunction dimensionsDefaults(traceIn, traceOut) {\n    var dimensionsIn = traceIn.dimensions || [],\n        dimensionsOut = traceOut.dimensions = [];\n\n    var dimensionIn, dimensionOut, i;\n    var commonLength = Infinity;\n\n    if(dimensionsIn.length > maxDimensionCount) {\n        Lib.log('parcoords traces support up to ' + maxDimensionCount + ' dimensions at the moment');\n        dimensionsIn.splice(maxDimensionCount);\n    }\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(dimensionIn, dimensionOut, attributes.dimensions, attr, dflt);\n    }\n\n    for(i = 0; i < dimensionsIn.length; i++) {\n        dimensionIn = dimensionsIn[i];\n        dimensionOut = {};\n\n        if(!Lib.isPlainObject(dimensionIn)) {\n            continue;\n        }\n\n        var values = coerce('values');\n        var visible = coerce('visible');\n        if(!(values && values.length)) {\n            visible = dimensionOut.visible = false;\n        }\n\n        if(visible) {\n            coerce('label');\n            coerce('tickvals');\n            coerce('ticktext');\n            coerce('tickformat');\n            coerce('range');\n\n            coerce('multiselect');\n            var constraintRange = coerce('constraintrange');\n            if(constraintRange) {\n                dimensionOut.constraintrange = axisBrush.cleanRanges(constraintRange, dimensionOut);\n            }\n\n            commonLength = Math.min(commonLength, values.length);\n        }\n\n        dimensionOut._index = i;\n        dimensionsOut.push(dimensionOut);\n    }\n\n    traceOut._length = commonLength;\n\n    return dimensionsOut;\n}\n\nmodule.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n    }\n\n    var dimensions = dimensionsDefaults(traceIn, traceOut);\n\n    handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce);\n\n    handleDomainDefaults(traceOut, layout, coerce);\n\n    if(!Array.isArray(dimensions) || !dimensions.length) {\n        traceOut.visible = false;\n    }\n\n    // since we're not slicing uneven arrays anymore, stash the length in each dimension\n    // but we can't do this in dimensionsDefaults (yet?) because line.color can also\n    // truncate\n    for(var i = 0; i < dimensions.length; i++) {\n        if(dimensions[i].visible) dimensions[i]._length = traceOut._length;\n    }\n\n    // make default font size 10px (default is 12),\n    // scale linearly with global font size\n    var fontDflt = {\n        family: layout.font.family,\n        size: Math.round(layout.font.size / 1.2),\n        color: layout.font.color\n    };\n\n    Lib.coerceFont(coerce, 'labelfont', fontDflt);\n    Lib.coerceFont(coerce, 'tickfont', fontDflt);\n    Lib.coerceFont(coerce, 'rangefont', fontDflt);\n};\n",null]}