{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/contour/constraint_mapping.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/contour/constraint_mapping.js","mtime":1529418310712},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar filterOps = require('../../constants/filter_ops');\nvar isNumeric = require('fast-isnumeric');\n\n// This syntax conforms to the existing filter transform syntax, but we don't care\n// about open vs. closed intervals for simply drawing contours constraints:\nmodule.exports = {\n    '[]': makeRangeSettings('[]'),\n    '][': makeRangeSettings(']['),\n    '>': makeInequalitySettings('>'),\n    '<': makeInequalitySettings('<'),\n    '=': makeInequalitySettings('=')\n};\n\n// This does not in any way shape or form support calendars. It's adapted from\n// transforms/filter.js.\nfunction coerceValue(operation, value) {\n    var hasArrayValue = Array.isArray(value);\n\n    var coercedValue;\n\n    function coerce(value) {\n        return isNumeric(value) ? (+value) : null;\n    }\n\n    if(filterOps.COMPARISON_OPS2.indexOf(operation) !== -1) {\n        coercedValue = hasArrayValue ? coerce(value[0]) : coerce(value);\n    } else if(filterOps.INTERVAL_OPS.indexOf(operation) !== -1) {\n        coercedValue = hasArrayValue ?\n            [coerce(value[0]), coerce(value[1])] :\n            [coerce(value), coerce(value)];\n    } else if(filterOps.SET_OPS.indexOf(operation) !== -1) {\n        coercedValue = hasArrayValue ? value.map(coerce) : [coerce(value)];\n    }\n\n    return coercedValue;\n}\n\n// Returns a parabola scaled so that the min/max is either +/- 1 and zero at the two values\n// provided. The data is mapped by this function when constructing intervals so that it's\n// very easy to construct contours as normal.\nfunction makeRangeSettings(operation) {\n    return function(value) {\n        value = coerceValue(operation, value);\n\n        // Ensure proper ordering:\n        var min = Math.min(value[0], value[1]);\n        var max = Math.max(value[0], value[1]);\n\n        return {\n            start: min,\n            end: max,\n            size: max - min\n        };\n    };\n}\n\nfunction makeInequalitySettings(operation) {\n    return function(value) {\n        value = coerceValue(operation, value);\n\n        return {\n            start: value,\n            end: Infinity,\n            size: Infinity\n        };\n    };\n}\n",null]}