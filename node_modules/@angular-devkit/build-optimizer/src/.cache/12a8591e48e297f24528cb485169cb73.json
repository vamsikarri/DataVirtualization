{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scattergeo/hover.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scattergeo/hover.js","mtime":1529418310740},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Fx = require('../../components/fx');\nvar Axes = require('../../plots/cartesian/axes');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar getTraceColor = require('../scatter/get_trace_color');\nvar fillHoverText = require('../scatter/fill_hover_text');\nvar attributes = require('./attributes');\n\nmodule.exports = function hoverPoints(pointData, xval, yval) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var geo = pointData.subplot;\n\n    var isLonLatOverEdges = geo.projection.isLonLatOverEdges;\n    var project = geo.project;\n\n    function distFn(d) {\n        var lonlat = d.lonlat;\n\n        if(lonlat[0] === BADNUM) return Infinity;\n        if(isLonLatOverEdges(lonlat)) return Infinity;\n\n        var pt = project(lonlat);\n        var px = project([xval, yval]);\n        var dx = Math.abs(pt[0] - px[0]);\n        var dy = Math.abs(pt[1] - px[1]);\n        var rad = Math.max(3, d.mrc || 0);\n\n        // N.B. d.mrc is the calculated marker radius\n        // which is only set for trace with 'markers' mode.\n\n        return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - 3 / rad);\n    }\n\n    Fx.getClosest(cd, distFn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if(pointData.index === false) return;\n\n    var di = cd[pointData.index];\n    var lonlat = di.lonlat;\n    var pos = [xa.c2p(lonlat), ya.c2p(lonlat)];\n    var rad = di.mrc || 1;\n\n    pointData.x0 = pos[0] - rad;\n    pointData.x1 = pos[0] + rad;\n    pointData.y0 = pos[1] - rad;\n    pointData.y1 = pos[1] + rad;\n\n    pointData.loc = di.loc;\n    pointData.lon = lonlat[0];\n    pointData.lat = lonlat[1];\n\n    pointData.color = getTraceColor(trace, di);\n    pointData.extraText = getExtraText(trace, di, geo.mockAxis, cd[0].t.labels);\n\n    return [pointData];\n};\n\nfunction getExtraText(trace, pt, axis, labels) {\n    var hoverinfo = pt.hi || trace.hoverinfo;\n\n    var parts = hoverinfo === 'all' ?\n        attributes.hoverinfo.flags :\n        hoverinfo.split('+');\n\n    var hasLocation = parts.indexOf('location') !== -1 && Array.isArray(trace.locations);\n    var hasLon = (parts.indexOf('lon') !== -1);\n    var hasLat = (parts.indexOf('lat') !== -1);\n    var hasText = (parts.indexOf('text') !== -1);\n    var text = [];\n\n    function format(val) {\n        return Axes.tickText(axis, axis.c2l(val), 'hover').text + '\\u00B0';\n    }\n\n    if(hasLocation) {\n        text.push(pt.loc);\n    } else if(hasLon && hasLat) {\n        text.push('(' + format(pt.lonlat[0]) + ', ' + format(pt.lonlat[1]) + ')');\n    } else if(hasLon) {\n        text.push(labels.lon + format(pt.lonlat[0]));\n    } else if(hasLat) {\n        text.push(labels.lat + format(pt.lonlat[1]));\n    }\n\n    if(hasText) {\n        fillHoverText(pt, trace, text);\n    }\n\n    return text.join('<br>');\n}\n",null]}