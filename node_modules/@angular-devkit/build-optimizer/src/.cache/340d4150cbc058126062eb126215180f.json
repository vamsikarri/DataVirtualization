{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/lib/queue.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/lib/queue.js","mtime":1529418310676},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../lib');\nvar config = require('../plot_api/plot_config');\n\n\n/**\n * Copy arg array *without* removing `undefined` values from objects.\n *\n * @param gd\n * @param args\n * @returns {Array}\n */\nfunction copyArgArray(gd, args) {\n    var copy = [];\n    var arg;\n\n    for(var i = 0; i < args.length; i++) {\n        arg = args[i];\n\n        if(arg === gd) copy[i] = arg;\n        else if(typeof arg === 'object') {\n            copy[i] = Array.isArray(arg) ?\n                Lib.extendDeep([], arg) :\n                Lib.extendDeepAll({}, arg);\n        }\n        else copy[i] = arg;\n    }\n\n    return copy;\n}\n\n\n// -----------------------------------------------------\n// Undo/Redo queue for plots\n// -----------------------------------------------------\n\n\nvar queue = {};\n\n// TODO: disable/enable undo and redo buttons appropriately\n\n/**\n * Add an item to the undoQueue for a graphDiv\n *\n * @param gd\n * @param undoFunc Function undo this operation\n * @param undoArgs Args to supply undoFunc with\n * @param redoFunc Function to redo this operation\n * @param redoArgs Args to supply redoFunc with\n */\nqueue.add = function(gd, undoFunc, undoArgs, redoFunc, redoArgs) {\n    var queueObj,\n        queueIndex;\n\n    // make sure we have the queue and our position in it\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    queueIndex = gd.undoQueue.index;\n\n    // if we're already playing an undo or redo, or if this is an auto operation\n    // (like pane resize... any others?) then we don't save this to the undo queue\n    if(gd.autoplay) {\n        if(!gd.undoQueue.inSequence) gd.autoplay = false;\n        return;\n    }\n\n    // if we're not in a sequence or are just starting, we need a new queue item\n    if(!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {\n        queueObj = {undo: {calls: [], args: []}, redo: {calls: [], args: []}};\n        gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);\n        gd.undoQueue.index += 1;\n    } else {\n        queueObj = gd.undoQueue.queue[queueIndex - 1];\n    }\n    gd.undoQueue.beginSequence = false;\n\n    // we unshift to handle calls for undo in a forward for loop later\n    if(queueObj) {\n        queueObj.undo.calls.unshift(undoFunc);\n        queueObj.undo.args.unshift(undoArgs);\n        queueObj.redo.calls.push(redoFunc);\n        queueObj.redo.args.push(redoArgs);\n    }\n\n    if(gd.undoQueue.queue.length > config.queueLength) {\n        gd.undoQueue.queue.shift();\n        gd.undoQueue.index--;\n    }\n};\n\n/**\n * Begin a sequence of undoQueue changes\n *\n * @param gd\n */\nqueue.startSequence = function(gd) {\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    gd.undoQueue.sequence = true;\n    gd.undoQueue.beginSequence = true;\n};\n\n/**\n * Stop a sequence of undoQueue changes\n *\n * Call this *after* you're sure your undo chain has ended\n *\n * @param gd\n */\nqueue.stopSequence = function(gd) {\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    gd.undoQueue.sequence = false;\n    gd.undoQueue.beginSequence = false;\n};\n\n/**\n * Move one step back in the undo queue, and undo the object there.\n *\n * @param gd\n */\nqueue.undo = function undo(gd) {\n    var queueObj, i;\n\n    if(gd.framework && gd.framework.isPolar) {\n        gd.framework.undo();\n        return;\n    }\n    if(gd.undoQueue === undefined ||\n            isNaN(gd.undoQueue.index) ||\n            gd.undoQueue.index <= 0) {\n        return;\n    }\n\n    // index is pointing to next *forward* queueObj, point to the one we're undoing\n    gd.undoQueue.index--;\n\n    // get the queueObj for instructions on how to undo\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n    // this sequence keeps things from adding to the queue during undo/redo\n    gd.undoQueue.inSequence = true;\n    for(i = 0; i < queueObj.undo.calls.length; i++) {\n        queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);\n    }\n    gd.undoQueue.inSequence = false;\n    gd.autoplay = false;\n};\n\n/**\n * Redo the current object in the undo, then move forward in the queue.\n *\n * @param gd\n */\nqueue.redo = function redo(gd) {\n    var queueObj, i;\n\n    if(gd.framework && gd.framework.isPolar) {\n        gd.framework.redo();\n        return;\n    }\n    if(gd.undoQueue === undefined ||\n            isNaN(gd.undoQueue.index) ||\n            gd.undoQueue.index >= gd.undoQueue.queue.length) {\n        return;\n    }\n\n    // get the queueObj for instructions on how to undo\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n    // this sequence keeps things from adding to the queue during undo/redo\n    gd.undoQueue.inSequence = true;\n    for(i = 0; i < queueObj.redo.calls.length; i++) {\n        queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);\n    }\n    gd.undoQueue.inSequence = false;\n    gd.autoplay = false;\n\n    // index is pointing to the thing we just redid, move it\n    gd.undoQueue.index++;\n};\n\n/**\n * Called by undo/redo to make the actual changes.\n *\n * Not meant to be called publically, but included for mocking out in tests.\n *\n * @param gd\n * @param func\n * @param args\n */\nqueue.plotDo = function(gd, func, args) {\n    gd.autoplay = true;\n\n    // this *won't* copy gd and it preserves `undefined` properties!\n    args = copyArgArray(gd, args);\n\n    // call the supplied function\n    func.apply(null, args);\n};\n\nmodule.exports = queue;\n",null]}