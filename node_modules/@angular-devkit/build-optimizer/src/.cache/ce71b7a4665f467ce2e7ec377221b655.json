{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/pointcloud/convert.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/pointcloud/convert.js","mtime":1529418310731},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar createPointCloudRenderer = require('gl-pointcloud2d');\n\nvar str2RGBArray = require('../../lib/str2rgbarray');\nvar expandAxis = require('../../plots/cartesian/autorange').expand;\nvar getTraceColor = require('../scatter/get_trace_color');\n\nfunction Pointcloud(scene, uid) {\n    this.scene = scene;\n    this.uid = uid;\n    this.type = 'pointcloud';\n\n    this.pickXData = [];\n    this.pickYData = [];\n    this.xData = [];\n    this.yData = [];\n    this.textLabels = [];\n    this.color = 'rgb(0, 0, 0)';\n    this.name = '';\n    this.hoverinfo = 'all';\n\n    this.idToIndex = new Int32Array(0);\n    this.bounds = [0, 0, 0, 0];\n\n    this.pointcloudOptions = {\n        positions: new Float32Array(0),\n        idToIndex: this.idToIndex,\n        sizemin: 0.5,\n        sizemax: 12,\n        color: [0, 0, 0, 1],\n        areaRatio: 1,\n        borderColor: [0, 0, 0, 1]\n    };\n    this.pointcloud = createPointCloudRenderer(scene.glplot, this.pointcloudOptions);\n    this.pointcloud._trace = this; // scene2d requires this prop\n}\n\nvar proto = Pointcloud.prototype;\n\nproto.handlePick = function(pickResult) {\n    var index = this.idToIndex[pickResult.pointId];\n\n    // prefer the readout from XY, if present\n    return {\n        trace: this,\n        dataCoord: pickResult.dataCoord,\n        traceCoord: this.pickXYData ?\n            [this.pickXYData[index * 2], this.pickXYData[index * 2 + 1]] :\n            [this.pickXData[index], this.pickYData[index]],\n        textLabel: Array.isArray(this.textLabels) ?\n            this.textLabels[index] :\n            this.textLabels,\n        color: this.color,\n        name: this.name,\n        pointIndex: index,\n        hoverinfo: this.hoverinfo\n    };\n};\n\nproto.update = function(options) {\n    this.index = options.index;\n    this.textLabels = options.text;\n    this.name = options.name;\n    this.hoverinfo = options.hoverinfo;\n    this.bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n    this.updateFast(options);\n\n    this.color = getTraceColor(options, {});\n};\n\nproto.updateFast = function(options) {\n    var x = this.xData = this.pickXData = options.x;\n    var y = this.yData = this.pickYData = options.y;\n    var xy = this.pickXYData = options.xy;\n\n    var userBounds = options.xbounds && options.ybounds;\n    var index = options.indices;\n\n    var len,\n        idToIndex,\n        positions,\n        bounds = this.bounds;\n\n    var xx, yy, i;\n\n    if(xy) {\n\n        positions = xy;\n\n        // dividing xy.length by 2 and truncating to integer if xy.length was not even\n        len = xy.length >>> 1;\n\n        if(userBounds) {\n\n            bounds[0] = options.xbounds[0];\n            bounds[2] = options.xbounds[1];\n            bounds[1] = options.ybounds[0];\n            bounds[3] = options.ybounds[1];\n\n        } else {\n\n            for(i = 0; i < len; i++) {\n\n                xx = positions[i * 2];\n                yy = positions[i * 2 + 1];\n\n                if(xx < bounds[0]) bounds[0] = xx;\n                if(xx > bounds[2]) bounds[2] = xx;\n                if(yy < bounds[1]) bounds[1] = yy;\n                if(yy > bounds[3]) bounds[3] = yy;\n            }\n\n        }\n\n        if(index) {\n\n            idToIndex = index;\n\n        } else {\n\n            idToIndex = new Int32Array(len);\n\n            for(i = 0; i < len; i++) {\n\n                idToIndex[i] = i;\n\n            }\n\n        }\n\n    } else {\n\n        len = x.length;\n\n        positions = new Float32Array(2 * len);\n        idToIndex = new Int32Array(len);\n\n        for(i = 0; i < len; i++) {\n            xx = x[i];\n            yy = y[i];\n\n            idToIndex[i] = i;\n\n            positions[i * 2] = xx;\n            positions[i * 2 + 1] = yy;\n\n            if(xx < bounds[0]) bounds[0] = xx;\n            if(xx > bounds[2]) bounds[2] = xx;\n            if(yy < bounds[1]) bounds[1] = yy;\n            if(yy > bounds[3]) bounds[3] = yy;\n        }\n\n    }\n\n    this.idToIndex = idToIndex;\n    this.pointcloudOptions.idToIndex = idToIndex;\n\n    this.pointcloudOptions.positions = positions;\n\n    var markerColor = str2RGBArray(options.marker.color),\n        borderColor = str2RGBArray(options.marker.border.color),\n        opacity = options.opacity * options.marker.opacity;\n\n    markerColor[3] *= opacity;\n    this.pointcloudOptions.color = markerColor;\n\n    // detect blending from the number of points, if undefined\n    // because large data with blending hits performance\n    var blend = options.marker.blend;\n    if(blend === null) {\n        var maxPoints = 100;\n        blend = x.length < maxPoints || y.length < maxPoints;\n    }\n    this.pointcloudOptions.blend = blend;\n\n    borderColor[3] *= opacity;\n    this.pointcloudOptions.borderColor = borderColor;\n\n    var markerSizeMin = options.marker.sizemin;\n    var markerSizeMax = Math.max(options.marker.sizemax, options.marker.sizemin);\n    this.pointcloudOptions.sizeMin = markerSizeMin;\n    this.pointcloudOptions.sizeMax = markerSizeMax;\n    this.pointcloudOptions.areaRatio = options.marker.border.arearatio;\n\n    this.pointcloud.update(this.pointcloudOptions);\n\n    // add item for autorange routine\n    this.expandAxesFast(bounds, markerSizeMax / 2); // avoid axis reexpand just because of the adaptive point size\n};\n\nproto.expandAxesFast = function(bounds, markerSize) {\n    var pad = markerSize || 0.5;\n\n    expandAxis(this.scene.xaxis, [bounds[0], bounds[2]], {ppad: pad});\n    expandAxis(this.scene.yaxis, [bounds[1], bounds[3]], {ppad: pad});\n};\n\nproto.dispose = function() {\n    this.pointcloud.dispose();\n};\n\nfunction createPointcloud(scene, data) {\n    var plot = new Pointcloud(scene, data.uid);\n    plot.update(data);\n    return plot;\n}\n\nmodule.exports = createPointcloud;\n",null]}