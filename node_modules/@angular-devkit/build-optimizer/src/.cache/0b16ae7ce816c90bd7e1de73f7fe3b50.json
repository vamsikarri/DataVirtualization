{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/bar/plot.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/bar/plot.js","mtime":1529418310700},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Registry = require('../../registry');\n\nvar attributes = require('./attributes'),\n    attributeText = attributes.text,\n    attributeTextPosition = attributes.textposition,\n    attributeTextFont = attributes.textfont,\n    attributeInsideTextFont = attributes.insidetextfont,\n    attributeOutsideTextFont = attributes.outsidetextfont;\n\n// padding in pixels around text\nvar TEXTPAD = 3;\n\nmodule.exports = function plot(gd, plotinfo, cdbar, barLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var fullLayout = gd._fullLayout;\n\n    var bartraces = barLayer.selectAll('g.trace.bars')\n        .data(cdbar, function(d) { return d[0].trace.uid; });\n\n    bartraces.enter().append('g')\n        .attr('class', 'trace bars')\n        .append('g')\n        .attr('class', 'points');\n\n    bartraces.exit().remove();\n\n    bartraces.order();\n\n    bartraces.each(function(d) {\n        var cd0 = d[0];\n        var t = cd0.t;\n        var trace = cd0.trace;\n        var sel = d3.select(this);\n\n        if(!plotinfo.isRangePlot) cd0.node3 = sel;\n\n        var poffset = t.poffset;\n        var poffsetIsArray = Array.isArray(poffset);\n\n        var bars = sel.select('g.points').selectAll('g.point').data(Lib.identity);\n\n        bars.enter().append('g')\n            .classed('point', true);\n\n        bars.exit().remove();\n\n        bars.each(function(di, i) {\n            var bar = d3.select(this);\n\n            // now display the bar\n            // clipped xf/yf (2nd arg true): non-positive\n            // log values go off-screen by plotwidth\n            // so you see them continue if you drag the plot\n            var p0 = di.p + ((poffsetIsArray) ? poffset[i] : poffset),\n                p1 = p0 + di.w,\n                s0 = di.b,\n                s1 = s0 + di.s;\n\n            var x0, x1, y0, y1;\n            if(trace.orientation === 'h') {\n                y0 = ya.c2p(p0, true);\n                y1 = ya.c2p(p1, true);\n                x0 = xa.c2p(s0, true);\n                x1 = xa.c2p(s1, true);\n\n                // for selections\n                di.ct = [x1, (y0 + y1) / 2];\n            }\n            else {\n                x0 = xa.c2p(p0, true);\n                x1 = xa.c2p(p1, true);\n                y0 = ya.c2p(s0, true);\n                y1 = ya.c2p(s1, true);\n\n                // for selections\n                di.ct = [(x0 + x1) / 2, y1];\n            }\n\n            if(!isNumeric(x0) || !isNumeric(x1) ||\n                    !isNumeric(y0) || !isNumeric(y1) ||\n                    x0 === x1 || y0 === y1) {\n                bar.remove();\n                return;\n            }\n\n            var lw = (di.mlw + 1 || trace.marker.line.width + 1 ||\n                    (di.trace ? di.trace.marker.line.width : 0) + 1) - 1,\n                offset = d3.round((lw / 2) % 1, 2);\n\n            function roundWithLine(v) {\n                // if there are explicit gaps, don't round,\n                // it can make the gaps look crappy\n                return (fullLayout.bargap === 0 && fullLayout.bargroupgap === 0) ?\n                    d3.round(Math.round(v) - offset, 2) : v;\n            }\n\n            function expandToVisible(v, vc) {\n                // if it's not in danger of disappearing entirely,\n                // round more precisely\n                return Math.abs(v - vc) >= 2 ? roundWithLine(v) :\n                // but if it's very thin, expand it so it's\n                // necessarily visible, even if it might overlap\n                // its neighbor\n                (v > vc ? Math.ceil(v) : Math.floor(v));\n            }\n\n            if(!gd._context.staticPlot) {\n                // if bars are not fully opaque or they have a line\n                // around them, round to integer pixels, mainly for\n                // safari so we prevent overlaps from its expansive\n                // pixelation. if the bars ARE fully opaque and have\n                // no line, expand to a full pixel to make sure we\n                // can see them\n                var op = Color.opacity(di.mc || trace.marker.color),\n                    fixpx = (op < 1 || lw > 0.01) ?\n                        roundWithLine : expandToVisible;\n                x0 = fixpx(x0, x1);\n                x1 = fixpx(x1, x0);\n                y0 = fixpx(y0, y1);\n                y1 = fixpx(y1, y0);\n            }\n\n            Lib.ensureSingle(bar, 'path')\n                .style('vector-effect', 'non-scaling-stroke')\n                .attr('d',\n                    'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z')\n                .call(Drawing.setClipUrl, plotinfo.layerClipId);\n\n            appendBarText(gd, bar, d, i, x0, x1, y0, y1);\n\n            if(plotinfo.layerClipId) {\n                Drawing.hideOutsideRangePoint(d[i], bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n            }\n        });\n\n        // lastly, clip points groups of `cliponaxis !== false` traces\n        // on `plotinfo._hasClipOnAxisFalse === true` subplots\n        var hasClipOnAxisFalse = d[0].trace.cliponaxis === false;\n        Drawing.setClipUrl(sel, hasClipOnAxisFalse ? null : plotinfo.layerClipId);\n    });\n\n    // error bars are on the top\n    Registry.getComponentMethod('errorbars', 'plot')(bartraces, plotinfo);\n};\n\nfunction appendBarText(gd, bar, calcTrace, i, x0, x1, y0, y1) {\n    var textPosition;\n\n    function appendTextNode(bar, text, textFont) {\n        var textSelection = Lib.ensureSingle(bar, 'text')\n            .text(text)\n            .attr({\n                'class': 'bartext bartext-' + textPosition,\n                transform: '',\n                'text-anchor': 'middle',\n                // prohibit tex interpretation until we can handle\n                // tex and regular text together\n                'data-notex': 1\n            })\n            .call(Drawing.font, textFont)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        return textSelection;\n    }\n\n    // get trace attributes\n    var trace = calcTrace[0].trace,\n        orientation = trace.orientation;\n\n    var text = getText(trace, i);\n    if(!text) return;\n\n    textPosition = getTextPosition(trace, i);\n    if(textPosition === 'none') return;\n\n    var textFont = getTextFont(trace, i, gd._fullLayout.font),\n        insideTextFont = getInsideTextFont(trace, i, textFont),\n        outsideTextFont = getOutsideTextFont(trace, i, textFont);\n\n    // compute text position\n    var barmode = gd._fullLayout.barmode,\n        inStackMode = (barmode === 'stack'),\n        inRelativeMode = (barmode === 'relative'),\n        inStackOrRelativeMode = inStackMode || inRelativeMode,\n\n        calcBar = calcTrace[i],\n        isOutmostBar = !inStackOrRelativeMode || calcBar._outmost,\n\n        barWidth = Math.abs(x1 - x0) - 2 * TEXTPAD,  // padding excluded\n        barHeight = Math.abs(y1 - y0) - 2 * TEXTPAD,  // padding excluded\n\n        textSelection,\n        textBB,\n        textWidth,\n        textHeight;\n\n    if(textPosition === 'outside') {\n        if(!isOutmostBar) textPosition = 'inside';\n    }\n\n    if(textPosition === 'auto') {\n        if(isOutmostBar) {\n            // draw text using insideTextFont and check if it fits inside bar\n            textPosition = 'inside';\n            textSelection = appendTextNode(bar, text, insideTextFont);\n\n            textBB = Drawing.bBox(textSelection.node()),\n            textWidth = textBB.width,\n            textHeight = textBB.height;\n\n            var textHasSize = (textWidth > 0 && textHeight > 0),\n                fitsInside =\n                    (textWidth <= barWidth && textHeight <= barHeight),\n                fitsInsideIfRotated =\n                    (textWidth <= barHeight && textHeight <= barWidth),\n                fitsInsideIfShrunk = (orientation === 'h') ?\n                    (barWidth >= textWidth * (barHeight / textHeight)) :\n                    (barHeight >= textHeight * (barWidth / textWidth));\n            if(textHasSize &&\n                    (fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk)) {\n                textPosition = 'inside';\n            }\n            else {\n                textPosition = 'outside';\n                textSelection.remove();\n                textSelection = null;\n            }\n        }\n        else textPosition = 'inside';\n    }\n\n    if(!textSelection) {\n        textSelection = appendTextNode(bar, text,\n                (textPosition === 'outside') ?\n                outsideTextFont : insideTextFont);\n\n        textBB = Drawing.bBox(textSelection.node()),\n        textWidth = textBB.width,\n        textHeight = textBB.height;\n\n        if(textWidth <= 0 || textHeight <= 0) {\n            textSelection.remove();\n            return;\n        }\n    }\n\n    // compute text transform\n    var transform, constrained;\n    if(textPosition === 'outside') {\n        constrained = trace.constraintext === 'both' || trace.constraintext === 'outside';\n        transform = getTransformToMoveOutsideBar(x0, x1, y0, y1, textBB,\n            orientation, constrained);\n    }\n    else {\n        constrained = trace.constraintext === 'both' || trace.constraintext === 'inside';\n        transform = getTransformToMoveInsideBar(x0, x1, y0, y1, textBB,\n            orientation, constrained);\n    }\n\n    textSelection.attr('transform', transform);\n}\n\nfunction getTransformToMoveInsideBar(x0, x1, y0, y1, textBB, orientation, constrained) {\n    // compute text and target positions\n    var textWidth = textBB.width,\n        textHeight = textBB.height,\n        textX = (textBB.left + textBB.right) / 2,\n        textY = (textBB.top + textBB.bottom) / 2,\n        barWidth = Math.abs(x1 - x0),\n        barHeight = Math.abs(y1 - y0),\n        targetWidth,\n        targetHeight,\n        targetX,\n        targetY;\n\n    // apply text padding\n    var textpad;\n    if(barWidth > (2 * TEXTPAD) && barHeight > (2 * TEXTPAD)) {\n        textpad = TEXTPAD;\n        barWidth -= 2 * textpad;\n        barHeight -= 2 * textpad;\n    }\n    else textpad = 0;\n\n    // compute rotation and scale\n    var rotate,\n        scale;\n\n    if(textWidth <= barWidth && textHeight <= barHeight) {\n        // no scale or rotation is required\n        rotate = false;\n        scale = 1;\n    }\n    else if(textWidth <= barHeight && textHeight <= barWidth) {\n        // only rotation is required\n        rotate = true;\n        scale = 1;\n    }\n    else if((textWidth < textHeight) === (barWidth < barHeight)) {\n        // only scale is required\n        rotate = false;\n        scale = constrained ? Math.min(barWidth / textWidth, barHeight / textHeight) : 1;\n    }\n    else {\n        // both scale and rotation are required\n        rotate = true;\n        scale = constrained ? Math.min(barHeight / textWidth, barWidth / textHeight) : 1;\n    }\n\n    if(rotate) rotate = 90;  // rotate clockwise\n\n    // compute text and target positions\n    if(rotate) {\n        targetWidth = scale * textHeight;\n        targetHeight = scale * textWidth;\n    }\n    else {\n        targetWidth = scale * textWidth;\n        targetHeight = scale * textHeight;\n    }\n\n    if(orientation === 'h') {\n        if(x1 < x0) {\n            // bar end is on the left hand side\n            targetX = x1 + textpad + targetWidth / 2;\n            targetY = (y0 + y1) / 2;\n        }\n        else {\n            targetX = x1 - textpad - targetWidth / 2;\n            targetY = (y0 + y1) / 2;\n        }\n    }\n    else {\n        if(y1 > y0) {\n            // bar end is on the bottom\n            targetX = (x0 + x1) / 2;\n            targetY = y1 - textpad - targetHeight / 2;\n        }\n        else {\n            targetX = (x0 + x1) / 2;\n            targetY = y1 + textpad + targetHeight / 2;\n        }\n    }\n\n    return getTransform(textX, textY, targetX, targetY, scale, rotate);\n}\n\nfunction getTransformToMoveOutsideBar(x0, x1, y0, y1, textBB, orientation, constrained) {\n    var barWidth = (orientation === 'h') ?\n            Math.abs(y1 - y0) :\n            Math.abs(x1 - x0),\n        textpad;\n\n    // Keep the padding so the text doesn't sit right against\n    // the bars, but don't factor it into barWidth\n    if(barWidth > 2 * TEXTPAD) {\n        textpad = TEXTPAD;\n    }\n\n    // compute rotation and scale\n    var scale = 1;\n    if(constrained) {\n        scale = (orientation === 'h') ?\n            Math.min(1, barWidth / textBB.height) :\n            Math.min(1, barWidth / textBB.width);\n    }\n\n    // compute text and target positions\n    var textX = (textBB.left + textBB.right) / 2,\n        textY = (textBB.top + textBB.bottom) / 2,\n        targetWidth,\n        targetHeight,\n        targetX,\n        targetY;\n\n    targetWidth = scale * textBB.width;\n    targetHeight = scale * textBB.height;\n\n    if(orientation === 'h') {\n        if(x1 < x0) {\n            // bar end is on the left hand side\n            targetX = x1 - textpad - targetWidth / 2;\n            targetY = (y0 + y1) / 2;\n        }\n        else {\n            targetX = x1 + textpad + targetWidth / 2;\n            targetY = (y0 + y1) / 2;\n        }\n    }\n    else {\n        if(y1 > y0) {\n            // bar end is on the bottom\n            targetX = (x0 + x1) / 2;\n            targetY = y1 + textpad + targetHeight / 2;\n        }\n        else {\n            targetX = (x0 + x1) / 2;\n            targetY = y1 - textpad - targetHeight / 2;\n        }\n    }\n\n    return getTransform(textX, textY, targetX, targetY, scale, false);\n}\n\nfunction getTransform(textX, textY, targetX, targetY, scale, rotate) {\n    var transformScale,\n        transformRotate,\n        transformTranslate;\n\n    if(scale < 1) transformScale = 'scale(' + scale + ') ';\n    else {\n        scale = 1;\n        transformScale = '';\n    }\n\n    transformRotate = (rotate) ?\n        'rotate(' + rotate + ' ' + textX + ' ' + textY + ') ' : '';\n\n    // Note that scaling also affects the center of the text box\n    var translateX = (targetX - scale * textX),\n        translateY = (targetY - scale * textY);\n    transformTranslate = 'translate(' + translateX + ' ' + translateY + ')';\n\n    return transformTranslate + transformScale + transformRotate;\n}\n\nfunction getText(trace, index) {\n    var value = getValue(trace.text, index);\n    return coerceString(attributeText, value);\n}\n\nfunction getTextPosition(trace, index) {\n    var value = getValue(trace.textposition, index);\n    return coerceEnumerated(attributeTextPosition, value);\n}\n\nfunction getTextFont(trace, index, defaultValue) {\n    return getFontValue(\n        attributeTextFont, trace.textfont, index, defaultValue);\n}\n\nfunction getInsideTextFont(trace, index, defaultValue) {\n    return getFontValue(\n        attributeInsideTextFont, trace.insidetextfont, index, defaultValue);\n}\n\nfunction getOutsideTextFont(trace, index, defaultValue) {\n    return getFontValue(\n        attributeOutsideTextFont, trace.outsidetextfont, index, defaultValue);\n}\n\nfunction getFontValue(attributeDefinition, attributeValue, index, defaultValue) {\n    attributeValue = attributeValue || {};\n\n    var familyValue = getValue(attributeValue.family, index),\n        sizeValue = getValue(attributeValue.size, index),\n        colorValue = getValue(attributeValue.color, index);\n\n    return {\n        family: coerceString(\n            attributeDefinition.family, familyValue, defaultValue.family),\n        size: coerceNumber(\n            attributeDefinition.size, sizeValue, defaultValue.size),\n        color: coerceColor(\n            attributeDefinition.color, colorValue, defaultValue.color)\n    };\n}\n\nfunction getValue(arrayOrScalar, index) {\n    var value;\n    if(!Array.isArray(arrayOrScalar)) value = arrayOrScalar;\n    else if(index < arrayOrScalar.length) value = arrayOrScalar[index];\n    return value;\n}\n\nfunction coerceString(attributeDefinition, value, defaultValue) {\n    if(typeof value === 'string') {\n        if(value || !attributeDefinition.noBlank) return value;\n    }\n    else if(typeof value === 'number') {\n        if(!attributeDefinition.strict) return String(value);\n    }\n\n    return (defaultValue !== undefined) ?\n        defaultValue :\n        attributeDefinition.dflt;\n}\n\nfunction coerceEnumerated(attributeDefinition, value, defaultValue) {\n    if(attributeDefinition.coerceNumber) value = +value;\n\n    if(attributeDefinition.values.indexOf(value) !== -1) return value;\n\n    return (defaultValue !== undefined) ?\n        defaultValue :\n        attributeDefinition.dflt;\n}\n\nfunction coerceNumber(attributeDefinition, value, defaultValue) {\n    if(isNumeric(value)) {\n        value = +value;\n\n        var min = attributeDefinition.min,\n            max = attributeDefinition.max,\n            isOutOfBounds = (min !== undefined && value < min) ||\n                (max !== undefined && value > max);\n\n        if(!isOutOfBounds) return value;\n    }\n\n    return (defaultValue !== undefined) ?\n        defaultValue :\n        attributeDefinition.dflt;\n}\n\nfunction coerceColor(attributeDefinition, value, defaultValue) {\n    if(tinycolor(value).isValid()) return value;\n\n    return (defaultValue !== undefined) ?\n        defaultValue :\n        attributeDefinition.dflt;\n}\n",null]}