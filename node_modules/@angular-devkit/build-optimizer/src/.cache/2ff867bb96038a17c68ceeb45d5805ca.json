{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/components/modebar/buttons.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/components/modebar/buttons.js","mtime":1529418310620},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\nvar axisIds = require('../../plots/cartesian/axis_ids');\nvar Lib = require('../../lib');\nvar Icons = require('../../../build/ploticon');\n\nvar _ = Lib._;\n\nvar modeBarButtons = module.exports = {};\n\n/**\n * ModeBar buttons configuration\n *\n * @param {string} name\n *      name / id of the buttons (for tracking)\n * @param {string} title\n *      text that appears while hovering over the button,\n *      enter null, false or '' for no hover text\n * @param {string} icon\n *      svg icon object associated with the button\n *      can be linked to Plotly.Icons to use the default plotly icons\n * @param {string} [gravity]\n *      icon positioning\n * @param {function} click\n *      click handler associated with the button, a function of\n *      'gd' (the main graph object) and\n *      'ev' (the event object)\n * @param {string} [attr]\n *      attribute associated with button,\n *      use this with 'val' to keep track of the state\n * @param {*} [val]\n *      initial 'attr' value, can be a function of gd\n * @param {boolean} [toggle]\n *      is the button a toggle button?\n */\n\nmodeBarButtons.toImage = {\n    name: 'toImage',\n    title: function(gd) {\n        var opts = gd._context.toImageButtonOptions || {};\n        var format = opts.format || 'png';\n        return format === 'png' ?\n            _(gd, 'Download plot as a png') : // legacy text\n            _(gd, 'Download plot'); // generic non-PNG text\n    },\n    icon: Icons.camera,\n    click: function(gd) {\n        var toImageButtonOptions = gd._context.toImageButtonOptions;\n        var opts = {format: toImageButtonOptions.format || 'png'};\n\n        Lib.notifier(_(gd, 'Taking snapshot - this may take a few seconds'), 'long');\n\n        if(opts.format !== 'svg' && Lib.isIE()) {\n            Lib.notifier(_(gd, 'IE only supports svg.  Changing format to svg.'), 'long');\n            opts.format = 'svg';\n        }\n\n        ['filename', 'width', 'height', 'scale'].forEach(function(key) {\n            if(toImageButtonOptions[key]) {\n                opts[key] = toImageButtonOptions[key];\n            }\n        });\n\n        Registry.call('downloadImage', gd, opts)\n          .then(function(filename) {\n              Lib.notifier(_(gd, 'Snapshot succeeded') + ' - ' + filename, 'long');\n          })\n          .catch(function() {\n              Lib.notifier(_(gd, 'Sorry, there was a problem downloading your snapshot!'), 'long');\n          });\n    }\n};\n\nmodeBarButtons.sendDataToCloud = {\n    name: 'sendDataToCloud',\n    title: function(gd) { return _(gd, 'Edit in Chart Studio'); },\n    icon: Icons.disk,\n    click: function(gd) {\n        Plots.sendDataToCloud(gd);\n    }\n};\n\nmodeBarButtons.zoom2d = {\n    name: 'zoom2d',\n    title: function(gd) { return _(gd, 'Zoom'); },\n    attr: 'dragmode',\n    val: 'zoom',\n    icon: Icons.zoombox,\n    click: handleCartesian\n};\n\nmodeBarButtons.pan2d = {\n    name: 'pan2d',\n    title: function(gd) { return _(gd, 'Pan'); },\n    attr: 'dragmode',\n    val: 'pan',\n    icon: Icons.pan,\n    click: handleCartesian\n};\n\nmodeBarButtons.select2d = {\n    name: 'select2d',\n    title: function(gd) { return _(gd, 'Box Select'); },\n    attr: 'dragmode',\n    val: 'select',\n    icon: Icons.selectbox,\n    click: handleCartesian\n};\n\nmodeBarButtons.lasso2d = {\n    name: 'lasso2d',\n    title: function(gd) { return _(gd, 'Lasso Select'); },\n    attr: 'dragmode',\n    val: 'lasso',\n    icon: Icons.lasso,\n    click: handleCartesian\n};\n\nmodeBarButtons.zoomIn2d = {\n    name: 'zoomIn2d',\n    title: function(gd) { return _(gd, 'Zoom in'); },\n    attr: 'zoom',\n    val: 'in',\n    icon: Icons.zoom_plus,\n    click: handleCartesian\n};\n\nmodeBarButtons.zoomOut2d = {\n    name: 'zoomOut2d',\n    title: function(gd) { return _(gd, 'Zoom out'); },\n    attr: 'zoom',\n    val: 'out',\n    icon: Icons.zoom_minus,\n    click: handleCartesian\n};\n\nmodeBarButtons.autoScale2d = {\n    name: 'autoScale2d',\n    title: function(gd) { return _(gd, 'Autoscale'); },\n    attr: 'zoom',\n    val: 'auto',\n    icon: Icons.autoscale,\n    click: handleCartesian\n};\n\nmodeBarButtons.resetScale2d = {\n    name: 'resetScale2d',\n    title: function(gd) { return _(gd, 'Reset axes'); },\n    attr: 'zoom',\n    val: 'reset',\n    icon: Icons.home,\n    click: handleCartesian\n};\n\nmodeBarButtons.hoverClosestCartesian = {\n    name: 'hoverClosestCartesian',\n    title: function(gd) { return _(gd, 'Show closest data on hover'); },\n    attr: 'hovermode',\n    val: 'closest',\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: handleCartesian\n};\n\nmodeBarButtons.hoverCompareCartesian = {\n    name: 'hoverCompareCartesian',\n    title: function(gd) { return _(gd, 'Compare data on hover'); },\n    attr: 'hovermode',\n    val: function(gd) {\n        return gd._fullLayout._isHoriz ? 'y' : 'x';\n    },\n    icon: Icons.tooltip_compare,\n    gravity: 'ne',\n    click: handleCartesian\n};\n\nfunction handleCartesian(gd, ev) {\n    var button = ev.currentTarget;\n    var astr = button.getAttribute('data-attr');\n    var val = button.getAttribute('data-val') || true;\n    var fullLayout = gd._fullLayout;\n    var aobj = {};\n    var axList = axisIds.list(gd, null, true);\n    var allSpikesEnabled = 'on';\n\n    var ax, i;\n\n    if(astr === 'zoom') {\n        var mag = (val === 'in') ? 0.5 : 2,\n            r0 = (1 + mag) / 2,\n            r1 = (1 - mag) / 2;\n\n        var axName;\n\n        for(i = 0; i < axList.length; i++) {\n            ax = axList[i];\n\n            if(!ax.fixedrange) {\n                axName = ax._name;\n                if(val === 'auto') aobj[axName + '.autorange'] = true;\n                else if(val === 'reset') {\n                    if(ax._rangeInitial === undefined) {\n                        aobj[axName + '.autorange'] = true;\n                    }\n                    else {\n                        var rangeInitial = ax._rangeInitial.slice();\n                        aobj[axName + '.range[0]'] = rangeInitial[0];\n                        aobj[axName + '.range[1]'] = rangeInitial[1];\n                    }\n                    if(ax._showSpikeInitial !== undefined) {\n                        aobj[axName + '.showspikes'] = ax._showSpikeInitial;\n                        if(allSpikesEnabled === 'on' && !ax._showSpikeInitial) {\n                            allSpikesEnabled = 'off';\n                        }\n                    }\n                }\n                else {\n                    var rangeNow = [\n                        ax.r2l(ax.range[0]),\n                        ax.r2l(ax.range[1]),\n                    ];\n\n                    var rangeNew = [\n                        r0 * rangeNow[0] + r1 * rangeNow[1],\n                        r0 * rangeNow[1] + r1 * rangeNow[0]\n                    ];\n\n                    aobj[axName + '.range[0]'] = ax.l2r(rangeNew[0]);\n                    aobj[axName + '.range[1]'] = ax.l2r(rangeNew[1]);\n                }\n            }\n        }\n        fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n    }\n    else {\n        // if ALL traces have orientation 'h', 'hovermode': 'x' otherwise: 'y'\n        if(astr === 'hovermode' && (val === 'x' || val === 'y')) {\n            val = fullLayout._isHoriz ? 'y' : 'x';\n            button.setAttribute('data-val', val);\n        } else if(astr === 'hovermode' && val === 'closest') {\n            for(i = 0; i < axList.length; i++) {\n                ax = axList[i];\n                if(allSpikesEnabled === 'on' && !ax.showspikes) {\n                    allSpikesEnabled = 'off';\n                }\n            }\n            fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n        }\n\n        aobj[astr] = val;\n    }\n\n    Registry.call('relayout', gd, aobj);\n}\n\nmodeBarButtons.zoom3d = {\n    name: 'zoom3d',\n    title: function(gd) { return _(gd, 'Zoom'); },\n    attr: 'scene.dragmode',\n    val: 'zoom',\n    icon: Icons.zoombox,\n    click: handleDrag3d\n};\n\nmodeBarButtons.pan3d = {\n    name: 'pan3d',\n    title: function(gd) { return _(gd, 'Pan'); },\n    attr: 'scene.dragmode',\n    val: 'pan',\n    icon: Icons.pan,\n    click: handleDrag3d\n};\n\nmodeBarButtons.orbitRotation = {\n    name: 'orbitRotation',\n    title: function(gd) { return _(gd, 'Orbital rotation'); },\n    attr: 'scene.dragmode',\n    val: 'orbit',\n    icon: Icons['3d_rotate'],\n    click: handleDrag3d\n};\n\nmodeBarButtons.tableRotation = {\n    name: 'tableRotation',\n    title: function(gd) { return _(gd, 'Turntable rotation'); },\n    attr: 'scene.dragmode',\n    val: 'turntable',\n    icon: Icons['z-axis'],\n    click: handleDrag3d\n};\n\nfunction handleDrag3d(gd, ev) {\n    var button = ev.currentTarget;\n    var attr = button.getAttribute('data-attr');\n    var val = button.getAttribute('data-val') || true;\n    var sceneIds = gd._fullLayout._subplots.gl3d;\n    var layoutUpdate = {};\n\n    var parts = attr.split('.');\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        layoutUpdate[sceneIds[i] + '.' + parts[1]] = val;\n    }\n\n    // for multi-type subplots\n    var val2d = (val === 'pan') ? val : 'zoom';\n    layoutUpdate.dragmode = val2d;\n\n    Registry.call('relayout', gd, layoutUpdate);\n}\n\nmodeBarButtons.resetCameraDefault3d = {\n    name: 'resetCameraDefault3d',\n    title: function(gd) { return _(gd, 'Reset camera to default'); },\n    attr: 'resetDefault',\n    icon: Icons.home,\n    click: handleCamera3d\n};\n\nmodeBarButtons.resetCameraLastSave3d = {\n    name: 'resetCameraLastSave3d',\n    title: function(gd) { return _(gd, 'Reset camera to last save'); },\n    attr: 'resetLastSave',\n    icon: Icons.movie,\n    click: handleCamera3d\n};\n\nfunction handleCamera3d(gd, ev) {\n    var button = ev.currentTarget;\n    var attr = button.getAttribute('data-attr');\n    var fullLayout = gd._fullLayout;\n    var sceneIds = fullLayout._subplots.gl3d;\n    var aobj = {};\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        var sceneId = sceneIds[i],\n            key = sceneId + '.camera',\n            scene = fullLayout[sceneId]._scene;\n\n        if(attr === 'resetDefault') {\n            aobj[key] = null;\n        }\n        else if(attr === 'resetLastSave') {\n            aobj[key] = Lib.extendDeep({}, scene.cameraInitial);\n        }\n    }\n\n    Registry.call('relayout', gd, aobj);\n}\n\nmodeBarButtons.hoverClosest3d = {\n    name: 'hoverClosest3d',\n    title: function(gd) { return _(gd, 'Toggle show closest data on hover'); },\n    attr: 'hovermode',\n    val: null,\n    toggle: true,\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: handleHover3d\n};\n\nfunction handleHover3d(gd, ev) {\n    var button = ev.currentTarget;\n    var val = button._previousVal || false;\n    var layout = gd.layout;\n    var fullLayout = gd._fullLayout;\n    var sceneIds = fullLayout._subplots.gl3d;\n\n    var axes = ['xaxis', 'yaxis', 'zaxis'];\n    var spikeAttrs = ['showspikes', 'spikesides', 'spikethickness', 'spikecolor'];\n\n    // initialize 'current spike' object to be stored in the DOM\n    var currentSpikes = {};\n    var axisSpikes = {};\n    var layoutUpdate = {};\n\n    if(val) {\n        layoutUpdate = Lib.extendDeep(layout, val);\n        button._previousVal = null;\n    }\n    else {\n        layoutUpdate = {\n            'allaxes.showspikes': false\n        };\n\n        for(var i = 0; i < sceneIds.length; i++) {\n            var sceneId = sceneIds[i],\n                sceneLayout = fullLayout[sceneId],\n                sceneSpikes = currentSpikes[sceneId] = {};\n\n            sceneSpikes.hovermode = sceneLayout.hovermode;\n            layoutUpdate[sceneId + '.hovermode'] = false;\n\n            // copy all the current spike attrs\n            for(var j = 0; j < 3; j++) {\n                var axis = axes[j];\n                axisSpikes = sceneSpikes[axis] = {};\n\n                for(var k = 0; k < spikeAttrs.length; k++) {\n                    var spikeAttr = spikeAttrs[k];\n                    axisSpikes[spikeAttr] = sceneLayout[axis][spikeAttr];\n                }\n            }\n        }\n\n        button._previousVal = Lib.extendDeep({}, currentSpikes);\n    }\n\n    Registry.call('relayout', gd, layoutUpdate);\n}\n\nmodeBarButtons.zoomInGeo = {\n    name: 'zoomInGeo',\n    title: function(gd) { return _(gd, 'Zoom in'); },\n    attr: 'zoom',\n    val: 'in',\n    icon: Icons.zoom_plus,\n    click: handleGeo\n};\n\nmodeBarButtons.zoomOutGeo = {\n    name: 'zoomOutGeo',\n    title: function(gd) { return _(gd, 'Zoom out'); },\n    attr: 'zoom',\n    val: 'out',\n    icon: Icons.zoom_minus,\n    click: handleGeo\n};\n\nmodeBarButtons.resetGeo = {\n    name: 'resetGeo',\n    title: function(gd) { return _(gd, 'Reset'); },\n    attr: 'reset',\n    val: null,\n    icon: Icons.autoscale,\n    click: handleGeo\n};\n\nmodeBarButtons.hoverClosestGeo = {\n    name: 'hoverClosestGeo',\n    title: function(gd) { return _(gd, 'Toggle show closest data on hover'); },\n    attr: 'hovermode',\n    val: null,\n    toggle: true,\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: toggleHover\n};\n\nfunction handleGeo(gd, ev) {\n    var button = ev.currentTarget;\n    var attr = button.getAttribute('data-attr');\n    var val = button.getAttribute('data-val') || true;\n    var fullLayout = gd._fullLayout;\n    var geoIds = fullLayout._subplots.geo;\n\n    for(var i = 0; i < geoIds.length; i++) {\n        var id = geoIds[i];\n        var geoLayout = fullLayout[id];\n\n        if(attr === 'zoom') {\n            var scale = geoLayout.projection.scale;\n            var newScale = (val === 'in') ? 2 * scale : 0.5 * scale;\n\n            Registry.call('relayout', gd, id + '.projection.scale', newScale);\n        } else if(attr === 'reset') {\n            resetView(gd, 'geo');\n        }\n    }\n}\n\nmodeBarButtons.hoverClosestGl2d = {\n    name: 'hoverClosestGl2d',\n    title: function(gd) { return _(gd, 'Toggle show closest data on hover'); },\n    attr: 'hovermode',\n    val: null,\n    toggle: true,\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: toggleHover\n};\n\nmodeBarButtons.hoverClosestPie = {\n    name: 'hoverClosestPie',\n    title: function(gd) { return _(gd, 'Toggle show closest data on hover'); },\n    attr: 'hovermode',\n    val: 'closest',\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: toggleHover\n};\n\nfunction toggleHover(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var onHoverVal;\n    if(fullLayout._has('cartesian')) {\n        onHoverVal = fullLayout._isHoriz ? 'y' : 'x';\n    }\n    else onHoverVal = 'closest';\n\n    var newHover = gd._fullLayout.hovermode ? false : onHoverVal;\n\n    Registry.call('relayout', gd, 'hovermode', newHover);\n}\n\n// buttons when more then one plot types are present\n\nmodeBarButtons.toggleHover = {\n    name: 'toggleHover',\n    title: function(gd) { return _(gd, 'Toggle show closest data on hover'); },\n    attr: 'hovermode',\n    val: null,\n    toggle: true,\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: function(gd, ev) {\n        toggleHover(gd);\n\n        // the 3d hovermode update must come\n        // last so that layout.hovermode update does not\n        // override scene?.hovermode?.layout.\n        handleHover3d(gd, ev);\n    }\n};\n\nmodeBarButtons.resetViews = {\n    name: 'resetViews',\n    title: function(gd) { return _(gd, 'Reset views'); },\n    icon: Icons.home,\n    click: function(gd, ev) {\n        var button = ev.currentTarget;\n\n        button.setAttribute('data-attr', 'zoom');\n        button.setAttribute('data-val', 'reset');\n        handleCartesian(gd, ev);\n\n        button.setAttribute('data-attr', 'resetLastSave');\n        handleCamera3d(gd, ev);\n\n        resetView(gd, 'geo');\n        resetView(gd, 'mapbox');\n    }\n};\n\nmodeBarButtons.toggleSpikelines = {\n    name: 'toggleSpikelines',\n    title: function(gd) { return _(gd, 'Toggle Spike Lines'); },\n    icon: Icons.spikeline,\n    attr: '_cartesianSpikesEnabled',\n    val: 'on',\n    click: function(gd) {\n        var fullLayout = gd._fullLayout;\n\n        fullLayout._cartesianSpikesEnabled = fullLayout._cartesianSpikesEnabled === 'on' ? 'off' : 'on';\n\n        var aobj = setSpikelineVisibility(gd);\n\n        Registry.call('relayout', gd, aobj);\n    }\n};\n\nfunction setSpikelineVisibility(gd) {\n    var fullLayout = gd._fullLayout;\n    var axList = axisIds.list(gd, null, true);\n    var aobj = {};\n\n    var ax, axName;\n\n    for(var i = 0; i < axList.length; i++) {\n        ax = axList[i];\n        axName = ax._name;\n        aobj[axName + '.showspikes'] = fullLayout._cartesianSpikesEnabled === 'on' ? true : ax._showSpikeInitial;\n    }\n\n    return aobj;\n}\n\nmodeBarButtons.resetViewMapbox = {\n    name: 'resetViewMapbox',\n    title: function(gd) { return _(gd, 'Reset view'); },\n    attr: 'reset',\n    icon: Icons.home,\n    click: function(gd) {\n        resetView(gd, 'mapbox');\n    }\n};\n\nfunction resetView(gd, subplotType) {\n    var fullLayout = gd._fullLayout;\n    var subplotIds = fullLayout._subplots[subplotType];\n    var aObj = {};\n\n    for(var i = 0; i < subplotIds.length; i++) {\n        var id = subplotIds[i];\n        var subplotObj = fullLayout[id]._subplot;\n        var viewInitial = subplotObj.viewInitial;\n        var viewKeys = Object.keys(viewInitial);\n\n        for(var j = 0; j < viewKeys.length; j++) {\n            var key = viewKeys[j];\n            aObj[id + '.' + key] = viewInitial[key];\n        }\n    }\n\n    Registry.call('relayout', gd, aObj);\n}\n",null]}