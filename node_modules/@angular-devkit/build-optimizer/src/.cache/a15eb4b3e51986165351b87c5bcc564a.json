{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/polytope-closest-point/lib/closest_point_2d.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/polytope-closest-point/lib/closest_point_2d.js","mtime":1529418310765},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["//Optimized version for triangle closest point\n// Based on Eberly's WildMagick codes\n// http://www.geometrictools.com/LibMathematics/Distance/Distance.html\n\"use strict\";\n\nvar diff = new Float64Array(4);\nvar edge0 = new Float64Array(4);\nvar edge1 = new Float64Array(4);\n\nfunction closestPoint2d(V0, V1, V2, point, result) {\n  //Reallocate buffers if necessary\n  if(diff.length < point.length) {\n    diff = new Float64Array(point.length);\n    edge0 = new Float64Array(point.length);\n    edge1 = new Float64Array(point.length);\n  }\n  //Compute edges\n  for(var i=0; i<point.length; ++i) {\n    diff[i]  = V0[i] - point[i];\n    edge0[i] = V1[i] - V0[i];\n    edge1[i] = V2[i] - V0[i];\n  }\n  //Compute coefficients for quadratic func\n  var a00 = 0.0\n    , a01 = 0.0\n    , a11 = 0.0\n    , b0  = 0.0\n    , b1  = 0.0\n    , c   = 0.0;\n  for(var i=0; i<point.length; ++i) {\n    var e0 = edge0[i]\n      , e1 = edge1[i]\n      , d  = diff[i];\n    a00 += e0 * e0;\n    a01 += e0 * e1;\n    a11 += e1 * e1;\n    b0  += d * e0;\n    b1  += d * e1;\n    c   += d * d;\n  }\n  //Compute determinant/coeffs\n  var det = Math.abs(a00*a11 - a01*a01);\n  var s   = a01*b1 - a11*b0;\n  var t   = a01*b0 - a00*b1;\n  var sqrDistance;\n  //Hardcoded Voronoi diagram classification\n  if (s + t <= det) {\n    if (s < 0) {\n      if (t < 0) { // region 4\n        if (b0 < 0) {\n          t = 0;\n          if (-b0 >= a00) {\n            s = 1.0;\n            sqrDistance = a00 + 2.0*b0 + c;\n          } else {\n            s = -b0/a00;\n            sqrDistance = b0*s + c;\n          }\n        } else {\n          s = 0;\n          if (b1 >= 0) {\n            t = 0;\n            sqrDistance = c;\n          } else if (-b1 >= a11) {\n            t = 1;\n            sqrDistance = a11 + 2.0*b1 + c;\n          } else {\n            t = -b1/a11;\n            sqrDistance = b1*t + c;\n          }\n        }\n      } else {  // region 3\n        s = 0;\n        if (b1 >= 0) {\n          t = 0;\n          sqrDistance = c;\n        } else if (-b1 >= a11) {\n          t = 1;\n          sqrDistance = a11 + 2.0*b1 + c;\n        } else {\n          t = -b1/a11;\n          sqrDistance = b1*t + c;\n        }\n      }\n    } else if (t < 0) { // region 5\n      t = 0;\n      if (b0 >= 0) {\n        s = 0;\n        sqrDistance = c;\n      } else if (-b0 >= a00) {\n        s = 1;\n        sqrDistance = a00 + 2.0*b0 + c;\n      } else {\n        s = -b0/a00;\n        sqrDistance = b0*s + c;\n      }\n    } else {  // region 0\n      // minimum at interior point\n      var invDet = 1.0 / det;\n      s *= invDet;\n      t *= invDet;\n      sqrDistance = s*(a00*s + a01*t + 2.0*b0) + t*(a01*s + a11*t + 2.0*b1) + c;\n    }\n  } else {\n    var tmp0, tmp1, numer, denom;\n    \n    if (s < 0) {  // region 2\n      tmp0 = a01 + b0;\n      tmp1 = a11 + b1;\n      if (tmp1 > tmp0) {\n        numer = tmp1 - tmp0;\n        denom = a00 - 2.0*a01 + a11;\n        if (numer >= denom) {\n          s = 1;\n          t = 0;\n          sqrDistance = a00 + 2.0*b0 + c;\n        } else {\n          s = numer/denom;\n          t = 1 - s;\n          sqrDistance = s*(a00*s + a01*t + 2.0*b0) +\n          t*(a01*s + a11*t + 2.0*b1) + c;\n        }\n      } else {\n        s = 0;\n        if (tmp1 <= 0) {\n          t = 1;\n          sqrDistance = a11 + 2.0*b1 + c;\n        } else if (b1 >= 0) {\n          t = 0;\n          sqrDistance = c;\n        } else {\n          t = -b1/a11;\n          sqrDistance = b1*t + c;\n        }\n      }\n    } else if (t < 0) {  // region 6\n      tmp0 = a01 + b1;\n      tmp1 = a00 + b0;\n      if (tmp1 > tmp0) {\n        numer = tmp1 - tmp0;\n        denom = a00 - 2.0*a01 + a11;\n        if (numer >= denom) {\n          t = 1;\n          s = 0;\n          sqrDistance = a11 + 2.0*b1 + c;\n        } else {\n          t = numer/denom;\n          s = 1 - t;\n          sqrDistance = s*(a00*s + a01*t + 2.0*b0) +\n          t*(a01*s + a11*t + 2.0*b1) + c;\n        }\n      } else {\n        t = 0;\n        if (tmp1 <= 0) {\n          s = 1;\n          sqrDistance = a00 + 2.0*b0 + c;\n        } else if (b0 >= 0) {\n          s = 0;\n          sqrDistance = c;\n        } else {\n          s = -b0/a00;\n          sqrDistance = b0*s + c;\n        }\n      }\n    } else {  // region 1\n      numer = a11 + b1 - a01 - b0;\n      if (numer <= 0) {\n        s = 0;\n        t = 1;\n        sqrDistance = a11 + 2.0*b1 + c;\n      } else {\n        denom = a00 - 2.0*a01 + a11;\n        if (numer >= denom) {\n          s = 1;\n          t = 0;\n          sqrDistance = a00 + 2.0*b0 + c;\n        } else {\n          s = numer/denom;\n          t = 1 - s;\n          sqrDistance = s*(a00*s + a01*t + 2.0*b0) +\n          t*(a01*s + a11*t + 2.0*b1) + c;\n        }\n      }\n    }\n  }\n  var u = 1.0 - s - t;\n  for(var i=0; i<point.length; ++i) {\n    result[i] = u * V0[i] + s * V1[i] + t * V2[i];\n  }\n  if(sqrDistance < 0) {\n    return 0;\n  }\n  return sqrDistance;\n}\n\nmodule.exports = closestPoint2d;\n",null]}