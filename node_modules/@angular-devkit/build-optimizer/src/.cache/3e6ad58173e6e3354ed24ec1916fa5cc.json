{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/cartesian/index.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/cartesian/index.js","mtime":1529418310684},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Plots = require('../plots');\nvar Drawing = require('../../components/drawing');\n\nvar getModuleCalcData = require('../get_data').getModuleCalcData;\nvar axisIds = require('./axis_ids');\nvar constants = require('./constants');\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\n\nvar ensureSingle = Lib.ensureSingle;\n\nfunction ensureSingleAndAddDatum(parent, nodeType, className) {\n    return Lib.ensureSingle(parent, nodeType, className, function(s) {\n        s.datum(className);\n    });\n}\n\nexports.name = 'cartesian';\n\nexports.attr = ['xaxis', 'yaxis'];\n\nexports.idRoot = ['x', 'y'];\n\nexports.idRegex = constants.idRegex;\n\nexports.attrRegex = constants.attrRegex;\n\nexports.attributes = require('./attributes');\n\nexports.layoutAttributes = require('./layout_attributes');\n\nexports.supplyLayoutDefaults = require('./layout_defaults');\n\nexports.transitionAxes = require('./transition_axes');\n\nexports.finalizeSubplots = function(layoutIn, layoutOut) {\n    var subplots = layoutOut._subplots;\n    var xList = subplots.xaxis;\n    var yList = subplots.yaxis;\n    var spSVG = subplots.cartesian;\n    var spAll = spSVG.concat(subplots.gl2d || []);\n    var allX = {};\n    var allY = {};\n    var i, xi, yi;\n\n    for(i = 0; i < spAll.length; i++) {\n        var parts = spAll[i].split('y');\n        allX[parts[0]] = 1;\n        allY['y' + parts[1]] = 1;\n    }\n\n    // check for x axes with no subplot, and make one from the anchor of that x axis\n    for(i = 0; i < xList.length; i++) {\n        xi = xList[i];\n        if(!allX[xi]) {\n            yi = (layoutIn[axisIds.id2name(xi)] || {}).anchor;\n            if(!constants.idRegex.y.test(yi)) yi = 'y';\n            spSVG.push(xi + yi);\n            spAll.push(xi + yi);\n\n            if(!allY[yi]) {\n                allY[yi] = 1;\n                Lib.pushUnique(yList, yi);\n            }\n        }\n    }\n\n    // same for y axes with no subplot\n    for(i = 0; i < yList.length; i++) {\n        yi = yList[i];\n        if(!allY[yi]) {\n            xi = (layoutIn[axisIds.id2name(yi)] || {}).anchor;\n            if(!constants.idRegex.x.test(xi)) xi = 'x';\n            spSVG.push(xi + yi);\n            spAll.push(xi + yi);\n\n            if(!allX[xi]) {\n                allX[xi] = 1;\n                Lib.pushUnique(xList, xi);\n            }\n        }\n    }\n\n    // finally, if we've gotten here we're supposed to show cartesian...\n    // so if there are NO subplots at all, make one from the first\n    // x & y axes in the input layout\n    if(!spAll.length) {\n        xi = '';\n        yi = '';\n        for(var ki in layoutIn) {\n            if(constants.attrRegex.test(ki)) {\n                var axLetter = ki.charAt(0);\n                if(axLetter === 'x') {\n                    if(!xi || (+ki.substr(5) < +xi.substr(5))) {\n                        xi = ki;\n                    }\n                }\n                else if(!yi || (+ki.substr(5) < +yi.substr(5))) {\n                    yi = ki;\n                }\n            }\n        }\n        xi = xi ? axisIds.name2id(xi) : 'x';\n        yi = yi ? axisIds.name2id(yi) : 'y';\n        xList.push(xi);\n        yList.push(yi);\n        spSVG.push(xi + yi);\n    }\n};\n\nexports.plot = function(gd, traces, transitionOpts, makeOnCompleteCallback) {\n    var fullLayout = gd._fullLayout;\n    var subplots = fullLayout._subplots.cartesian;\n    var calcdata = gd.calcdata;\n    var i;\n\n    // If traces is not provided, then it's a complete replot and missing\n    // traces are removed\n    if(!Array.isArray(traces)) {\n        traces = [];\n        for(i = 0; i < calcdata.length; i++) traces.push(i);\n    }\n\n    for(i = 0; i < subplots.length; i++) {\n        var subplot = subplots[i];\n        var subplotInfo = fullLayout._plots[subplot];\n\n        // Get all calcdata for this subplot:\n        var cdSubplot = [];\n        var pcd;\n\n        for(var j = 0; j < calcdata.length; j++) {\n            var cd = calcdata[j];\n            var trace = cd[0].trace;\n\n            // Skip trace if whitelist provided and it's not whitelisted:\n            // if (Array.isArray(traces) && traces.indexOf(i) === -1) continue;\n            if(trace.xaxis + trace.yaxis === subplot) {\n                // XXX: Should trace carpet dependencies. Only replot all carpet plots if the carpet\n                // axis has actually changed:\n                //\n                // If this trace is specifically requested, add it to the list:\n                if(traces.indexOf(trace.index) !== -1 || trace.carpet) {\n                    // Okay, so example: traces 0, 1, and 2 have fill = tonext. You animate\n                    // traces 0 and 2. Trace 1 also needs to be updated, otherwise its fill\n                    // is outdated. So this retroactively adds the previous trace if the\n                    // traces are interdependent.\n                    if(\n                        pcd &&\n                        pcd[0].trace.xaxis + pcd[0].trace.yaxis === subplot &&\n                        ['tonextx', 'tonexty', 'tonext'].indexOf(trace.fill) !== -1 &&\n                        cdSubplot.indexOf(pcd) === -1\n                    ) {\n                        cdSubplot.push(pcd);\n                    }\n\n                    cdSubplot.push(cd);\n                }\n\n                // Track the previous trace on this subplot for the retroactive-add step\n                // above:\n                pcd = cd;\n            }\n        }\n\n        plotOne(gd, subplotInfo, cdSubplot, transitionOpts, makeOnCompleteCallback);\n    }\n};\n\nfunction plotOne(gd, plotinfo, cdSubplot, transitionOpts, makeOnCompleteCallback) {\n    var traceLayerClasses = constants.traceLayerClasses;\n    var fullLayout = gd._fullLayout;\n    var modules = fullLayout._modules;\n    var _module, cdModuleAndOthers, cdModule;\n\n    var layerData = [];\n    var zoomScaleQueryParts = [];\n\n    for(var i = 0; i < modules.length; i++) {\n        _module = modules[i];\n        var name = _module.name;\n        var categories = Registry.modules[name].categories;\n\n        if(categories.svg) {\n            var className = (_module.layerName || name + 'layer');\n            var plotMethod = _module.plot;\n\n            // plot all traces of this type on this subplot at once\n            cdModuleAndOthers = getModuleCalcData(cdSubplot, plotMethod);\n            cdModule = cdModuleAndOthers[0];\n            // don't need to search the found traces again - in fact we need to NOT\n            // so that if two modules share the same plotter we don't double-plot\n            cdSubplot = cdModuleAndOthers[1];\n\n            if(cdModule.length) {\n                layerData.push({\n                    i: traceLayerClasses.indexOf(className),\n                    className: className,\n                    plotMethod: plotMethod,\n                    cdModule: cdModule\n                });\n            }\n\n            if(categories.zoomScale) {\n                zoomScaleQueryParts.push('.' + className);\n            }\n        }\n    }\n\n    layerData.sort(function(a, b) { return a.i - b.i; });\n\n    var layers = plotinfo.plot.selectAll('g.mlayer')\n        .data(layerData, function(d) { return d.className; });\n\n    layers.enter().append('g')\n        .attr('class', function(d) { return d.className; })\n        .classed('mlayer', true);\n\n    layers.exit().remove();\n\n    layers.order();\n\n    layers.each(function(d) {\n        var sel = d3.select(this);\n        var className = d.className;\n\n        d.plotMethod(\n            gd, plotinfo, d.cdModule, sel,\n            transitionOpts, makeOnCompleteCallback\n        );\n\n        // layers that allow `cliponaxis: false`\n        if(className !== 'scatterlayer' && className !== 'barlayer') {\n            Drawing.setClipUrl(sel, plotinfo.layerClipId);\n        }\n    });\n\n    // call Scattergl.plot separately\n    if(fullLayout._has('scattergl')) {\n        _module = Registry.getModule('scattergl');\n        cdModule = getModuleCalcData(cdSubplot, _module)[0];\n        _module.plot(gd, plotinfo, cdModule);\n    }\n\n    // stash \"hot\" selections for faster interaction on drag and scroll\n    if(!gd._context.staticPlot) {\n        if(plotinfo._hasClipOnAxisFalse) {\n            plotinfo.clipOnAxisFalseTraces = plotinfo.plot\n                .selectAll('.scatterlayer, .barlayer')\n                .selectAll('.trace');\n        }\n\n        if(zoomScaleQueryParts.length) {\n            var traces = plotinfo.plot\n                .selectAll(zoomScaleQueryParts.join(','))\n                .selectAll('.trace');\n\n            plotinfo.zoomScalePts = traces.selectAll('path.point');\n            plotinfo.zoomScaleTxt = traces.selectAll('.textpoint');\n        }\n    }\n}\n\nexports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var oldPlots = oldFullLayout._plots || {};\n    var newPlots = newFullLayout._plots || {};\n    var oldSubplotList = oldFullLayout._subplots || {};\n    var plotinfo;\n    var i, k;\n\n    // when going from a large splom graph to something else,\n    // we need to clear <g subplot> so that the new cartesian subplot\n    // can have the correct layer ordering\n    if(oldFullLayout._hasOnlyLargeSploms && !newFullLayout._hasOnlyLargeSploms) {\n        for(k in oldPlots) {\n            plotinfo = oldPlots[k];\n            if(plotinfo.plotgroup) plotinfo.plotgroup.remove();\n        }\n    }\n\n    var hadGl = (oldFullLayout._has && oldFullLayout._has('gl'));\n    var hasGl = (newFullLayout._has && newFullLayout._has('gl'));\n\n    if(hadGl && !hasGl) {\n        for(k in oldPlots) {\n            plotinfo = oldPlots[k];\n            if(plotinfo._scene) plotinfo._scene.destroy();\n        }\n    }\n\n    // delete any titles we don't need anymore\n    // check if axis list has changed, and if so clear old titles\n    if(oldSubplotList.xaxis && oldSubplotList.yaxis) {\n        var oldAxIDs = axisIds.listIds({_fullLayout: oldFullLayout});\n        for(i = 0; i < oldAxIDs.length; i++) {\n            var oldAxId = oldAxIDs[i];\n            if(!newFullLayout[axisIds.id2name(oldAxId)]) {\n                oldFullLayout._infolayer.selectAll('.g-' + oldAxId + 'title').remove();\n            }\n        }\n    }\n\n    // if we've gotten rid of all cartesian traces, remove all the subplot svg items\n    var hadCartesian = (oldFullLayout._has && oldFullLayout._has('cartesian'));\n    var hasCartesian = (newFullLayout._has && newFullLayout._has('cartesian'));\n\n    if(hadCartesian && !hasCartesian) {\n        purgeSubplotLayers(oldFullLayout._cartesianlayer.selectAll('.subplot'), oldFullLayout);\n        oldFullLayout._defs.selectAll('.axesclip').remove();\n        delete oldFullLayout._axisConstraintGroups;\n    }\n    // otherwise look for subplots we need to remove\n    else if(oldSubplotList.cartesian) {\n        for(i = 0; i < oldSubplotList.cartesian.length; i++) {\n            var oldSubplotId = oldSubplotList.cartesian[i];\n            if(!newPlots[oldSubplotId]) {\n                var selector = '.' + oldSubplotId + ',.' + oldSubplotId + '-x,.' + oldSubplotId + '-y';\n                oldFullLayout._cartesianlayer.selectAll(selector).remove();\n                removeSubplotExtras(oldSubplotId, oldFullLayout);\n            }\n        }\n    }\n};\n\nexports.drawFramework = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var subplotData = makeSubplotData(gd);\n\n    var subplotLayers = fullLayout._cartesianlayer.selectAll('.subplot')\n        .data(subplotData, Lib.identity);\n\n    subplotLayers.enter().append('g')\n        .attr('class', function(name) { return 'subplot ' + name; });\n\n    subplotLayers.order();\n\n    subplotLayers.exit()\n        .call(purgeSubplotLayers, fullLayout);\n\n    subplotLayers.each(function(name) {\n        var plotinfo = fullLayout._plots[name];\n\n        // keep ref to plot group\n        plotinfo.plotgroup = d3.select(this);\n\n        // initialize list of overlay subplots\n        plotinfo.overlays = [];\n\n        makeSubplotLayer(gd, plotinfo);\n\n        // fill in list of overlay subplots\n        if(plotinfo.mainplot) {\n            var mainplot = fullLayout._plots[plotinfo.mainplot];\n            mainplot.overlays.push(plotinfo);\n        }\n\n        // make separate drag layers for each subplot,\n        // but append them to paper rather than the plot groups,\n        // so they end up on top of the rest\n        plotinfo.draglayer = ensureSingle(fullLayout._draggers, 'g', name);\n    });\n};\n\nexports.rangePlot = function(gd, plotinfo, cdSubplot) {\n    makeSubplotLayer(gd, plotinfo);\n    plotOne(gd, plotinfo, cdSubplot);\n    Plots.style(gd);\n};\n\nfunction makeSubplotData(gd) {\n    var fullLayout = gd._fullLayout;\n    var subplotData = [];\n    var overlays = [];\n\n    for(var k in fullLayout._plots) {\n        var plotinfo = fullLayout._plots[k];\n        var xa2 = plotinfo.xaxis._mainAxis;\n        var ya2 = plotinfo.yaxis._mainAxis;\n        var mainplot = xa2._id + ya2._id;\n\n        if(mainplot !== k && fullLayout._plots[mainplot]) {\n            plotinfo.mainplot = mainplot;\n            plotinfo.mainplotinfo = fullLayout._plots[mainplot];\n            overlays.push(k);\n        } else {\n            subplotData.push(k);\n            plotinfo.mainplot = undefined;\n        }\n    }\n\n    // main subplots before overlays\n    subplotData = subplotData.concat(overlays);\n\n    return subplotData;\n}\n\nfunction makeSubplotLayer(gd, plotinfo) {\n    var plotgroup = plotinfo.plotgroup;\n    var id = plotinfo.id;\n    var xLayer = constants.layerValue2layerClass[plotinfo.xaxis.layer];\n    var yLayer = constants.layerValue2layerClass[plotinfo.yaxis.layer];\n    var hasOnlyLargeSploms = gd._fullLayout._hasOnlyLargeSploms;\n\n    if(!plotinfo.mainplot) {\n        if(hasOnlyLargeSploms) {\n            // TODO could do even better\n            // - we don't need plot (but we would have to mock it in lsInner\n            //   and other places\n            // - we don't (x|y)lines and (x|y)axislayer for most subplots\n            //   usually just the bottom x and left y axes.\n            plotinfo.plot = ensureSingle(plotgroup, 'g', 'plot');\n            plotinfo.xlines = ensureSingle(plotgroup, 'path', 'xlines-above');\n            plotinfo.ylines = ensureSingle(plotgroup, 'path', 'ylines-above');\n            plotinfo.xaxislayer = ensureSingle(plotgroup, 'g', 'xaxislayer-above');\n            plotinfo.yaxislayer = ensureSingle(plotgroup, 'g', 'yaxislayer-above');\n        }\n        else {\n            var backLayer = ensureSingle(plotgroup, 'g', 'layer-subplot');\n            plotinfo.shapelayer = ensureSingle(backLayer, 'g', 'shapelayer');\n            plotinfo.imagelayer = ensureSingle(backLayer, 'g', 'imagelayer');\n\n            plotinfo.gridlayer = ensureSingle(plotgroup, 'g', 'gridlayer');\n            plotinfo.zerolinelayer = ensureSingle(plotgroup, 'g', 'zerolinelayer');\n\n            ensureSingle(plotgroup, 'path', 'xlines-below');\n            ensureSingle(plotgroup, 'path', 'ylines-below');\n            plotinfo.overlinesBelow = ensureSingle(plotgroup, 'g', 'overlines-below');\n\n            ensureSingle(plotgroup, 'g', 'xaxislayer-below');\n            ensureSingle(plotgroup, 'g', 'yaxislayer-below');\n            plotinfo.overaxesBelow = ensureSingle(plotgroup, 'g', 'overaxes-below');\n\n            plotinfo.plot = ensureSingle(plotgroup, 'g', 'plot');\n            plotinfo.overplot = ensureSingle(plotgroup, 'g', 'overplot');\n\n            plotinfo.xlines = ensureSingle(plotgroup, 'path', 'xlines-above');\n            plotinfo.ylines = ensureSingle(plotgroup, 'path', 'ylines-above');\n            plotinfo.overlinesAbove = ensureSingle(plotgroup, 'g', 'overlines-above');\n\n            ensureSingle(plotgroup, 'g', 'xaxislayer-above');\n            ensureSingle(plotgroup, 'g', 'yaxislayer-above');\n            plotinfo.overaxesAbove = ensureSingle(plotgroup, 'g', 'overaxes-above');\n\n            // set refs to correct layers as determined by 'axis.layer'\n            plotinfo.xlines = plotgroup.select('.xlines-' + xLayer);\n            plotinfo.ylines = plotgroup.select('.ylines-' + yLayer);\n            plotinfo.xaxislayer = plotgroup.select('.xaxislayer-' + xLayer);\n            plotinfo.yaxislayer = plotgroup.select('.yaxislayer-' + yLayer);\n        }\n    }\n    else {\n        var mainplotinfo = plotinfo.mainplotinfo;\n        var mainplotgroup = mainplotinfo.plotgroup;\n        var xId = id + '-x';\n        var yId = id + '-y';\n\n        // now make the components of overlaid subplots\n        // overlays don't have backgrounds, and append all\n        // their other components to the corresponding\n        // extra groups of their main plots.\n\n        plotinfo.gridlayer = mainplotinfo.gridlayer;\n        plotinfo.zerolinelayer = mainplotinfo.zerolinelayer;\n\n        ensureSingle(mainplotinfo.overlinesBelow, 'path', xId);\n        ensureSingle(mainplotinfo.overlinesBelow, 'path', yId);\n        ensureSingle(mainplotinfo.overaxesBelow, 'g', xId);\n        ensureSingle(mainplotinfo.overaxesBelow, 'g', yId);\n\n        plotinfo.plot = ensureSingle(mainplotinfo.overplot, 'g', id);\n\n        ensureSingle(mainplotinfo.overlinesAbove, 'path', xId);\n        ensureSingle(mainplotinfo.overlinesAbove, 'path', yId);\n        ensureSingle(mainplotinfo.overaxesAbove, 'g', xId);\n        ensureSingle(mainplotinfo.overaxesAbove, 'g', yId);\n\n        // set refs to correct layers as determined by 'abovetraces'\n        plotinfo.xlines = mainplotgroup.select('.overlines-' + xLayer).select('.' + xId);\n        plotinfo.ylines = mainplotgroup.select('.overlines-' + yLayer).select('.' + yId);\n        plotinfo.xaxislayer = mainplotgroup.select('.overaxes-' + xLayer).select('.' + xId);\n        plotinfo.yaxislayer = mainplotgroup.select('.overaxes-' + yLayer).select('.' + yId);\n    }\n\n    // common attributes for all subplots, overlays or not\n\n    if(!hasOnlyLargeSploms) {\n        ensureSingleAndAddDatum(plotinfo.gridlayer, 'g', plotinfo.xaxis._id);\n        ensureSingleAndAddDatum(plotinfo.gridlayer, 'g', plotinfo.yaxis._id);\n        plotinfo.gridlayer.selectAll('g').sort(axisIds.idSort);\n    }\n\n    plotinfo.xlines\n        .style('fill', 'none')\n        .classed('crisp', true);\n\n    plotinfo.ylines\n        .style('fill', 'none')\n        .classed('crisp', true);\n}\n\nfunction purgeSubplotLayers(layers, fullLayout) {\n    if(!layers) return;\n\n    var overlayIdsToRemove = {};\n\n    layers.each(function(subplotId) {\n        var plotgroup = d3.select(this);\n\n        plotgroup.remove();\n        removeSubplotExtras(subplotId, fullLayout);\n\n        overlayIdsToRemove[subplotId] = true;\n\n        // do not remove individual axis <clipPath>s here\n        // as other subplots may need them\n    });\n\n    // must remove overlaid subplot trace layers 'manually'\n\n    for(var k in fullLayout._plots) {\n        var subplotInfo = fullLayout._plots[k];\n        var overlays = subplotInfo.overlays || [];\n\n        for(var j = 0; j < overlays.length; j++) {\n            var overlayInfo = overlays[j];\n\n            if(overlayIdsToRemove[overlayInfo.id]) {\n                overlayInfo.plot.selectAll('.trace').remove();\n            }\n        }\n    }\n}\n\nfunction removeSubplotExtras(subplotId, fullLayout) {\n    fullLayout._draggers.selectAll('g.' + subplotId).remove();\n    fullLayout._defs.select('#clip' + fullLayout._uid + subplotId + 'plot').remove();\n}\n\nexports.toSVG = function(gd) {\n    var imageRoot = gd._fullLayout._glimages;\n    var root = d3.select(gd).selectAll('.svg-container');\n    var canvases = root.filter(function(d, i) {return i === root.size() - 1;})\n        .selectAll('.gl-canvas-context, .gl-canvas-focus');\n\n    function canvasToImage() {\n        var canvas = this;\n        var imageData = canvas.toDataURL('image/png');\n        var image = imageRoot.append('svg:image');\n\n        image.attr({\n            xmlns: xmlnsNamespaces.svg,\n            'xlink:href': imageData,\n            preserveAspectRatio: 'none',\n            x: 0,\n            y: 0,\n            width: canvas.width,\n            height: canvas.height\n        });\n    }\n\n    canvases.each(canvasToImage);\n};\n\nexports.updateFx = require('./graph_interact').updateFx;\n",null]}