{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/contour/convert_to_constraints.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/contour/convert_to_constraints.js","mtime":1529418310712},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n// The contour extraction is great, except it totally fails for constraints because we\n// need weird range loops and flipped contours instead of the usual format. This function\n// does some weird manipulation of the extracted pathinfo data such that it magically\n// draws contours correctly *as* constraints.\nmodule.exports = function(pathinfo, operation) {\n    var i, pi0, pi1;\n\n    var op0 = function(arr) { return arr.reverse(); };\n    var op1 = function(arr) { return arr; };\n\n    switch(operation) {\n        case '=':\n        case '<':\n            return pathinfo;\n        case '>':\n            if(pathinfo.length !== 1) {\n                Lib.warn('Contour data invalid for the specified inequality operation.');\n            }\n\n            // In this case there should be exactly two contour levels in pathinfo. We\n            // simply concatenate the info into one pathinfo and flip all of the data\n            // in one. This will draw the contour as closed.\n            pi0 = pathinfo[0];\n\n            for(i = 0; i < pi0.edgepaths.length; i++) {\n                pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n            }\n\n            for(i = 0; i < pi0.paths.length; i++) {\n                pi0.paths[i] = op0(pi0.paths[i]);\n            }\n            return pathinfo;\n        case '][':\n            var tmp = op0;\n            op0 = op1;\n            op1 = tmp;\n            // It's a nice rule, except this definitely *is* what's intended here.\n            /* eslint-disable: no-fallthrough */\n        case '[]':\n            /* eslint-enable: no-fallthrough */\n            if(pathinfo.length !== 2) {\n                Lib.warn('Contour data invalid for the specified inequality range operation.');\n            }\n\n            // In this case there should be exactly two contour levels in pathinfo. We\n            // simply concatenate the info into one pathinfo and flip all of the data\n            // in one. This will draw the contour as closed.\n            pi0 = copyPathinfo(pathinfo[0]);\n            pi1 = copyPathinfo(pathinfo[1]);\n\n            for(i = 0; i < pi0.edgepaths.length; i++) {\n                pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n            }\n\n            for(i = 0; i < pi0.paths.length; i++) {\n                pi0.paths[i] = op0(pi0.paths[i]);\n            }\n\n            while(pi1.edgepaths.length) {\n                pi0.edgepaths.push(op1(pi1.edgepaths.shift()));\n            }\n            while(pi1.paths.length) {\n                pi0.paths.push(op1(pi1.paths.shift()));\n            }\n            return [pi0];\n    }\n};\n\nfunction copyPathinfo(pi) {\n    return Lib.extendFlat({}, pi, {\n        edgepaths: Lib.extendDeep([], pi.edgepaths),\n        paths: Lib.extendDeep([], pi.paths)\n    });\n}\n",null]}