{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/components/shapes/draw.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/components/shapes/draw.js","mtime":1529418310625},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\n\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\n\n// Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne\n};\n\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n    fullLayout._shapeUpperLayer.selectAll('path').remove();\n    fullLayout._shapeLowerLayer.selectAll('path').remove();\n\n    for(var k in fullLayout._plots) {\n        var shapelayer = fullLayout._plots[k].shapelayer;\n        if(shapelayer) shapelayer.selectAll('path').remove();\n    }\n\n    for(var i = 0; i < fullLayout.shapes.length; i++) {\n        if(fullLayout.shapes[i].visible) {\n            drawOne(gd, i);\n        }\n    }\n\n    // may need to resurrect this if we put text (LaTeX) in shapes\n    // return Plots.previousPromises(gd);\n}\n\nfunction drawOne(gd, index) {\n    // remove the existing shape if there is one.\n    // because indices can change, we need to look in all shape layers\n    gd._fullLayout._paperdiv\n        .selectAll('.shapelayer [data-index=\"' + index + '\"]')\n        .remove();\n\n    var optionsIn = (gd.layout.shapes || [])[index],\n        options = gd._fullLayout.shapes[index];\n\n    // this shape is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!optionsIn || options.visible === false) return;\n\n    if(options.layer !== 'below') {\n        drawShape(gd._fullLayout._shapeUpperLayer);\n    }\n    else if(options.xref === 'paper' || options.yref === 'paper') {\n        drawShape(gd._fullLayout._shapeLowerLayer);\n    }\n    else {\n        var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n        if(plotinfo) {\n            var mainPlot = plotinfo.mainplotinfo || plotinfo;\n            drawShape(mainPlot.shapelayer);\n        }\n        else {\n            // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n            // This can happen if you reference the shape to an x / y axis combination\n            // that doesn't have any data on it (and layer is below)\n            drawShape(gd._fullLayout._shapeLowerLayer);\n        }\n    }\n\n    function drawShape(shapeLayer) {\n        var attrs = {\n                'data-index': index,\n                'fill-rule': 'evenodd',\n                d: getPathString(gd, options)\n            },\n            lineColor = options.line.width ?\n                options.line.color : 'rgba(0,0,0,0)';\n\n        var path = shapeLayer.append('path')\n            .attr(attrs)\n            .style('opacity', options.opacity)\n            .call(Color.stroke, lineColor)\n            .call(Color.fill, options.fillcolor)\n            .call(Drawing.dashLine, options.line.dash, options.line.width);\n\n        setClipPath(path, gd, options);\n\n        if(gd._context.edits.shapePosition) setupDragElement(gd, path, options, index, shapeLayer);\n    }\n}\n\nfunction setClipPath(shapePath, gd, shapeOptions) {\n    // note that for layer=\"below\" the clipAxes can be different from the\n    // subplot we're drawing this in. This could cause problems if the shape\n    // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n    var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '');\n\n    shapePath.call(Drawing.setClipUrl, clipAxes ?\n      ('clip' + gd._fullLayout._uid + clipAxes) :\n      null\n    );\n}\n\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer) {\n    var MINWIDTH = 10,\n        MINHEIGHT = 10;\n\n    var xPixelSized = shapeOptions.xsizemode === 'pixel',\n        yPixelSized = shapeOptions.ysizemode === 'pixel',\n        isLine = shapeOptions.type === 'line',\n        isPath = shapeOptions.type === 'path';\n\n    var update;\n    var x0, y0, x1, y1, xAnchor, yAnchor, astrX0, astrY0, astrX1, astrY1, astrXAnchor, astrYAnchor;\n    var n0, s0, w0, e0, astrN, astrS, astrW, astrE, optN, optS, optW, optE;\n    var pathIn, astrPath;\n\n    // setup conversion functions\n    var xa = Axes.getFromId(gd, shapeOptions.xref),\n        ya = Axes.getFromId(gd, shapeOptions.yref),\n        x2p = helpers.getDataToPixel(gd, xa),\n        y2p = helpers.getDataToPixel(gd, ya, true),\n        p2x = helpers.getPixelToData(gd, xa),\n        p2y = helpers.getPixelToData(gd, ya, true);\n\n    var sensoryElement = obtainSensoryElement();\n    var dragOptions = {\n            element: sensoryElement.node(),\n            gd: gd,\n            prepFn: startDrag,\n            doneFn: endDrag,\n            clickFn: abortDrag\n        },\n        dragMode;\n\n    dragElement.init(dragOptions);\n\n    sensoryElement.node().onmousemove = updateDragMode;\n\n    function obtainSensoryElement() {\n        return isLine ? createLineDragHandles() : shapePath;\n    }\n\n    function createLineDragHandles() {\n        var minSensoryWidth = 10,\n            sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);\n\n        // Helper shapes group\n        // Note that by setting the `data-index` attr, it is ensured that\n        // the helper group is purged in this modules `draw` function\n        var g = shapeLayer.append('g')\n          .attr('data-index', index);\n\n        // Helper path for moving\n        g.append('path')\n          .attr('d', shapePath.attr('d'))\n          .style({\n              'cursor': 'move',\n              'stroke-width': sensoryWidth,\n              'stroke-opacity': '0' // ensure not visible\n          });\n\n        // Helper circles for resizing\n        var circleStyle = {\n            'fill-opacity': '0' // ensure not visible\n        };\n        var circleRadius = sensoryWidth / 2 > minSensoryWidth ? sensoryWidth / 2 : minSensoryWidth;\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'start-point',\n              'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n              'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n              'r': circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'end-point',\n              'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n              'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n              'r': circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        return g;\n    }\n\n    function updateDragMode(evt) {\n        if(isLine) {\n            if(evt.target.tagName === 'path') {\n                dragMode = 'move';\n            } else {\n                dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ?\n                  'resize-over-start-point' : 'resize-over-end-point';\n            }\n        } else {\n            // element might not be on screen at time of setup,\n            // so obtain bounding box here\n            var dragBBox = dragOptions.element.getBoundingClientRect();\n\n            // choose 'move' or 'resize'\n            // based on initial position of cursor within the drag element\n            var w = dragBBox.right - dragBBox.left,\n                h = dragBBox.bottom - dragBBox.top,\n                x = evt.clientX - dragBBox.left,\n                y = evt.clientY - dragBBox.top,\n                cursor = (!isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey) ?\n                    dragElement.getCursor(x / w, 1 - y / h) :\n                    'move';\n\n            setCursor(shapePath, cursor);\n\n            // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n            dragMode = cursor.split('-')[0];\n        }\n    }\n\n    function startDrag(evt) {\n        // setup update strings and initial values\n        var astr = 'shapes[' + index + ']';\n\n        if(xPixelSized) {\n            xAnchor = x2p(shapeOptions.xanchor);\n            astrXAnchor = astr + '.xanchor';\n        }\n        if(yPixelSized) {\n            yAnchor = y2p(shapeOptions.yanchor);\n            astrYAnchor = astr + '.yanchor';\n        }\n\n        if(shapeOptions.type === 'path') {\n            pathIn = shapeOptions.path;\n            astrPath = astr + '.path';\n        }\n        else {\n            x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n            y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n            x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n            y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n\n            astrX0 = astr + '.x0';\n            astrY0 = astr + '.y0';\n            astrX1 = astr + '.x1';\n            astrY1 = astr + '.y1';\n        }\n\n        if(x0 < x1) {\n            w0 = x0; astrW = astr + '.x0'; optW = 'x0';\n            e0 = x1; astrE = astr + '.x1'; optE = 'x1';\n        }\n        else {\n            w0 = x1; astrW = astr + '.x1'; optW = 'x1';\n            e0 = x0; astrE = astr + '.x0'; optE = 'x0';\n        }\n\n        // For fixed size shapes take opposing direction of y-axis into account.\n        // Hint: For data sized shapes this is done by the y2p function.\n        if((!yPixelSized && y0 < y1) || (yPixelSized && y0 > y1)) {\n            n0 = y0; astrN = astr + '.y0'; optN = 'y0';\n            s0 = y1; astrS = astr + '.y1'; optS = 'y1';\n        }\n        else {\n            n0 = y1; astrN = astr + '.y1'; optN = 'y1';\n            s0 = y0; astrS = astr + '.y0'; optS = 'y0';\n        }\n\n        update = {};\n\n        // setup dragMode and the corresponding handler\n        updateDragMode(evt);\n        renderVisualCues(shapeLayer, shapeOptions);\n        deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n        dragOptions.moveFn = (dragMode === 'move') ? moveShape : resizeShape;\n    }\n\n    function endDrag() {\n        setCursor(shapePath);\n        removeVisualCues(shapeLayer);\n\n        // Don't rely on clipPath being activated during re-layout\n        setClipPath(shapePath, gd, shapeOptions);\n        Registry.call('relayout', gd, update);\n    }\n\n    function abortDrag() {\n        removeVisualCues(shapeLayer);\n    }\n\n    function moveShape(dx, dy) {\n        if(shapeOptions.type === 'path') {\n            var noOp = function(coord) { return coord; },\n                moveX = noOp,\n                moveY = noOp;\n\n            if(xPixelSized) {\n                update[astrXAnchor] = shapeOptions.xanchor = p2x(xAnchor + dx);\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                update[astrYAnchor] = shapeOptions.yanchor = p2y(yAnchor + dy);\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            shapeOptions.path = movePath(pathIn, moveX, moveY);\n            update[astrPath] = shapeOptions.path;\n        }\n        else {\n            if(xPixelSized) {\n                update[astrXAnchor] = shapeOptions.xanchor = p2x(xAnchor + dx);\n            } else {\n                update[astrX0] = shapeOptions.x0 = p2x(x0 + dx);\n                update[astrX1] = shapeOptions.x1 = p2x(x1 + dx);\n            }\n\n            if(yPixelSized) {\n                update[astrYAnchor] = shapeOptions.yanchor = p2y(yAnchor + dy);\n            } else {\n                update[astrY0] = shapeOptions.y0 = p2y(y0 + dy);\n                update[astrY1] = shapeOptions.y1 = p2y(y1 + dy);\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n    }\n\n    function resizeShape(dx, dy) {\n        if(isPath) {\n            // TODO: implement path resize, don't forget to update dragMode code\n            var noOp = function(coord) { return coord; },\n                moveX = noOp,\n                moveY = noOp;\n\n            if(xPixelSized) {\n                update[astrXAnchor] = shapeOptions.xanchor = p2x(xAnchor + dx);\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                update[astrYAnchor] = shapeOptions.yanchor = p2y(yAnchor + dy);\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            shapeOptions.path = movePath(pathIn, moveX, moveY);\n            update[astrPath] = shapeOptions.path;\n        }\n        else if(isLine) {\n            if(dragMode === 'resize-over-start-point') {\n                var newX0 = x0 + dx;\n                var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n                update[astrX0] = shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0);\n                update[astrY0] = shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0);\n            } else if(dragMode === 'resize-over-end-point') {\n                var newX1 = x1 + dx;\n                var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n                update[astrX1] = shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1);\n                update[astrY1] = shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1);\n            }\n        }\n        else {\n            var newN = (~dragMode.indexOf('n')) ? n0 + dy : n0,\n                newS = (~dragMode.indexOf('s')) ? s0 + dy : s0,\n                newW = (~dragMode.indexOf('w')) ? w0 + dx : w0,\n                newE = (~dragMode.indexOf('e')) ? e0 + dx : e0;\n\n            // Do things in opposing direction for y-axis.\n            // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n            if(~dragMode.indexOf('n') && yPixelSized) newN = n0 - dy;\n            if(~dragMode.indexOf('s') && yPixelSized) newS = s0 - dy;\n\n            // Update shape eventually. Again, be aware of the\n            // opposing direction of the y-axis of fixed size shapes.\n            if((!yPixelSized && newS - newN > MINHEIGHT) ||\n              (yPixelSized && newN - newS > MINHEIGHT)) {\n                update[astrN] = shapeOptions[optN] = yPixelSized ? newN : p2y(newN);\n                update[astrS] = shapeOptions[optS] = yPixelSized ? newS : p2y(newS);\n            }\n            if(newE - newW > MINWIDTH) {\n                update[astrW] = shapeOptions[optW] = xPixelSized ? newW : p2x(newW);\n                update[astrE] = shapeOptions[optE] = xPixelSized ? newE : p2x(newE);\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n    }\n\n    function renderVisualCues(shapeLayer, shapeOptions) {\n        if(xPixelSized || yPixelSized) {\n            renderAnchor();\n        }\n\n        function renderAnchor() {\n            var isNotPath = shapeOptions.type !== 'path';\n\n            // d3 join with dummy data to satisfy d3 data-binding\n            var visualCues = shapeLayer.selectAll('.visual-cue').data([0]);\n\n            // Enter\n            var strokeWidth = 1;\n            visualCues.enter()\n              .append('path')\n              .attr({\n                  'fill': '#fff',\n                  'fill-rule': 'evenodd',\n                  'stroke': '#000',\n                  'stroke-width': strokeWidth\n              })\n              .classed('visual-cue', true);\n\n            // Update\n            var posX = x2p(\n              xPixelSized ?\n                shapeOptions.xanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.x0, shapeOptions.x1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsX))\n            );\n            var posY = y2p(\n              yPixelSized ?\n                shapeOptions.yanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.y0, shapeOptions.y1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsY))\n            );\n\n            posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n            posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n\n            if(xPixelSized && yPixelSized) {\n                var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n                visualCues.attr('d', crossPath);\n            } else if(xPixelSized) {\n                var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) +\n                  'v18 h2 v-18 Z';\n                visualCues.attr('d', vBarPath);\n            } else {\n                var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h18 v2 h-18 Z';\n                visualCues.attr('d', hBarPath);\n            }\n        }\n    }\n\n    function removeVisualCues(shapeLayer) {\n        shapeLayer.selectAll('.visual-cue').remove();\n    }\n\n    function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n        var xref = shapeOptions.xref,\n            yref = shapeOptions.yref,\n            xa = Axes.getFromId(gd, xref),\n            ya = Axes.getFromId(gd, yref);\n\n        var clipAxes = '';\n        if(xref !== 'paper' && !xa.autorange) clipAxes += xref;\n        if(yref !== 'paper' && !ya.autorange) clipAxes += yref;\n\n        shapePath.call(Drawing.setClipUrl, clipAxes ?\n          'clip' + gd._fullLayout._uid + clipAxes :\n          null\n        );\n    }\n}\n\nfunction getPathString(gd, options) {\n    var type = options.type,\n        xa = Axes.getFromId(gd, options.xref),\n        ya = Axes.getFromId(gd, options.yref),\n        gs = gd._fullLayout._size,\n        x2r, x2p, y2r, y2p,\n        x0, x1, y0, y1;\n\n    if(xa) {\n        x2r = helpers.shapePositionToRange(xa);\n        x2p = function(v) { return xa._offset + xa.r2p(x2r(v, true)); };\n    }\n    else {\n        x2p = function(v) { return gs.l + gs.w * v; };\n    }\n\n    if(ya) {\n        y2r = helpers.shapePositionToRange(ya);\n        y2p = function(v) { return ya._offset + ya.r2p(y2r(v, true)); };\n    }\n    else {\n        y2p = function(v) { return gs.t + gs.h * (1 - v); };\n    }\n\n    if(type === 'path') {\n        if(xa && xa.type === 'date') x2p = helpers.decodeDate(x2p);\n        if(ya && ya.type === 'date') y2p = helpers.decodeDate(y2p);\n        return convertPath(options, x2p, y2p);\n    }\n\n    if(options.xsizemode === 'pixel') {\n        var xAnchorPos = x2p(options.xanchor);\n        x0 = xAnchorPos + options.x0;\n        x1 = xAnchorPos + options.x1;\n    }\n    else {\n        x0 = x2p(options.x0);\n        x1 = x2p(options.x1);\n    }\n\n    if(options.ysizemode === 'pixel') {\n        var yAnchorPos = y2p(options.yanchor);\n        y0 = yAnchorPos - options.y0;\n        y1 = yAnchorPos - options.y1;\n    }\n    else {\n        y0 = y2p(options.y0);\n        y1 = y2p(options.y1);\n    }\n\n    if(type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n    if(type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z';\n    // circle\n    var cx = (x0 + x1) / 2,\n        cy = (y0 + y1) / 2,\n        rx = Math.abs(cx - x0),\n        ry = Math.abs(cy - y0),\n        rArc = 'A' + rx + ',' + ry,\n        rightPt = (cx + rx) + ',' + cy,\n        topPt = cx + ',' + (cy - ry);\n    return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt +\n        rArc + ' 0 0,1 ' + rightPt + 'Z';\n}\n\n\nfunction convertPath(options, x2p, y2p) {\n    var pathIn = options.path,\n        xSizemode = options.xsizemode,\n        ySizemode = options.ysizemode,\n        xAnchor = options.xanchor,\n        yAnchor = options.yanchor;\n\n\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0,\n            segmentType = segment.charAt(0),\n            xParams = constants.paramIsX[segmentType],\n            yParams = constants.paramIsY[segmentType],\n            nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(xParams[paramNumber]) {\n                if(xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);\n                else param = x2p(param);\n            }\n            else if(yParams[paramNumber]) {\n                if(ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);\n                else param = y2p(param);\n            }\n            paramNumber++;\n\n            if(paramNumber > nParams) param = 'X';\n            return param;\n        });\n\n        if(paramNumber > nParams) {\n            paramString = paramString.replace(/[\\s,]*X.*/, '');\n            Lib.log('Ignoring extra params in segment ' + segment);\n        }\n\n        return segmentType + paramString;\n    });\n}\n\nfunction movePath(pathIn, moveX, moveY) {\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0,\n            segmentType = segment.charAt(0),\n            xParams = constants.paramIsX[segmentType],\n            yParams = constants.paramIsY[segmentType],\n            nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(paramNumber >= nParams) return param;\n\n            if(xParams[paramNumber]) param = moveX(param);\n            else if(yParams[paramNumber]) param = moveY(param);\n\n            paramNumber++;\n\n            return param;\n        });\n\n        return segmentType + paramString;\n    });\n}\n",null]}