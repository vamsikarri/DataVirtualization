{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/command.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/command.js","mtime":1529418310686},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../registry');\nvar Lib = require('../lib');\n\n/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */\nexports.manageCommandObserver = function(gd, container, commandList, onchange) {\n    var ret = {};\n    var enabled = true;\n\n    if(container && container._commandObserver) {\n        ret = container._commandObserver;\n    }\n\n    if(!ret.cache) {\n        ret.cache = {};\n    }\n\n    // Either create or just recompute this:\n    ret.lookupTable = {};\n\n    var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);\n\n    if(container && container._commandObserver) {\n        if(!binding) {\n            // If container exists and there are no longer any bindings,\n            // remove existing:\n            if(container._commandObserver.remove) {\n                container._commandObserver.remove();\n                container._commandObserver = null;\n                return ret;\n            }\n        } else {\n            // If container exists and there *are* bindings, then the lookup\n            // table should have been updated and check is already attached,\n            // so there's nothing to be done:\n            return ret;\n\n\n        }\n    }\n\n    // Determine whether there's anything to do for this binding:\n\n    if(binding) {\n        // Build the cache:\n        bindingValueHasChanged(gd, binding, ret.cache);\n\n        ret.check = function check() {\n            if(!enabled) return;\n\n            var update = bindingValueHasChanged(gd, binding, ret.cache);\n\n            if(update.changed && onchange) {\n                // Disable checks for the duration of this command in order to avoid\n                // infinite loops:\n                if(ret.lookupTable[update.value] !== undefined) {\n                    ret.disable();\n                    Promise.resolve(onchange({\n                        value: update.value,\n                        type: binding.type,\n                        prop: binding.prop,\n                        traces: binding.traces,\n                        index: ret.lookupTable[update.value]\n                    })).then(ret.enable, ret.enable);\n                }\n            }\n\n            return update.changed;\n        };\n\n        var checkEvents = [\n            'plotly_relayout',\n            'plotly_redraw',\n            'plotly_restyle',\n            'plotly_update',\n            'plotly_animatingframe',\n            'plotly_afterplot'\n        ];\n\n        for(var i = 0; i < checkEvents.length; i++) {\n            gd._internalOn(checkEvents[i], ret.check);\n        }\n\n        ret.remove = function() {\n            for(var i = 0; i < checkEvents.length; i++) {\n                gd._removeInternalListener(checkEvents[i], ret.check);\n            }\n        };\n    } else {\n        // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n        // is a start\n        Lib.log('Unable to automatically bind plot updates to API command');\n\n        ret.lookupTable = {};\n        ret.remove = function() {};\n    }\n\n    ret.disable = function disable() {\n        enabled = false;\n    };\n\n    ret.enable = function enable() {\n        enabled = true;\n    };\n\n    if(container) {\n        container._commandObserver = ret;\n    }\n\n    return ret;\n};\n\n/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */\nexports.hasSimpleAPICommandBindings = function(gd, commandList, bindingsByValue) {\n    var i;\n    var n = commandList.length;\n\n    var refBinding;\n\n    for(i = 0; i < n; i++) {\n        var binding;\n        var command = commandList[i];\n        var method = command.method;\n        var args = command.args;\n\n        if(!Array.isArray(args)) args = [];\n\n        // If any command has no method, refuse to bind:\n        if(!method) {\n            return false;\n        }\n        var bindings = exports.computeAPICommandBindings(gd, method, args);\n\n        // Right now, handle one and *only* one property being set:\n        if(bindings.length !== 1) {\n            return false;\n        }\n\n        if(!refBinding) {\n            refBinding = bindings[0];\n            if(Array.isArray(refBinding.traces)) {\n                refBinding.traces.sort();\n            }\n        } else {\n            binding = bindings[0];\n            if(binding.type !== refBinding.type) {\n                return false;\n            }\n            if(binding.prop !== refBinding.prop) {\n                return false;\n            }\n            if(Array.isArray(refBinding.traces)) {\n                if(Array.isArray(binding.traces)) {\n                    binding.traces.sort();\n                    for(var j = 0; j < refBinding.traces.length; j++) {\n                        if(refBinding.traces[j] !== binding.traces[j]) {\n                            return false;\n                        }\n                    }\n                } else {\n                    return false;\n                }\n            } else {\n                if(binding.prop !== refBinding.prop) {\n                    return false;\n                }\n            }\n        }\n\n        binding = bindings[0];\n        var value = binding.value;\n        if(Array.isArray(value)) {\n            if(value.length === 1) {\n                value = value[0];\n            } else {\n                return false;\n            }\n        }\n        if(bindingsByValue) {\n            bindingsByValue[value] = i;\n        }\n    }\n\n    return refBinding;\n};\n\nfunction bindingValueHasChanged(gd, binding, cache) {\n    var container, value, obj;\n    var changed = false;\n\n    if(binding.type === 'data') {\n        // If it's data, we need to get a trace. Based on the limited scope\n        // of what we cover, we can just take the first trace from the list,\n        // or otherwise just the first trace:\n        container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];\n    } else if(binding.type === 'layout') {\n        container = gd._fullLayout;\n    } else {\n        return false;\n    }\n\n    value = Lib.nestedProperty(container, binding.prop).get();\n\n    obj = cache[binding.type] = cache[binding.type] || {};\n\n    if(obj.hasOwnProperty(binding.prop)) {\n        if(obj[binding.prop] !== value) {\n            changed = true;\n        }\n    }\n\n    obj[binding.prop] = value;\n\n    return {\n        changed: changed,\n        value: value\n    };\n}\n\n/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */\nexports.executeAPICommand = function(gd, method, args) {\n    if(method === 'skip') return Promise.resolve();\n\n    var _method = Registry.apiMethodRegistry[method];\n    var allArgs = [gd];\n    if(!Array.isArray(args)) args = [];\n\n    for(var i = 0; i < args.length; i++) {\n        allArgs.push(args[i]);\n    }\n\n    return _method.apply(null, allArgs).catch(function(err) {\n        Lib.warn('API call to Plotly.' + method + ' rejected.', err);\n        return Promise.reject(err);\n    });\n};\n\nexports.computeAPICommandBindings = function(gd, method, args) {\n    var bindings;\n\n    if(!Array.isArray(args)) args = [];\n\n    switch(method) {\n        case 'restyle':\n            bindings = computeDataBindings(gd, args);\n            break;\n        case 'relayout':\n            bindings = computeLayoutBindings(gd, args);\n            break;\n        case 'update':\n            bindings = computeDataBindings(gd, [args[0], args[2]])\n                .concat(computeLayoutBindings(gd, [args[1]]));\n            break;\n        case 'animate':\n            bindings = computeAnimateBindings(gd, args);\n            break;\n        default:\n            // This is the case where intelligent logic about what affects\n            // this command is not implemented. It causes no ill effects.\n            // For example, addFrames simply won't bind to a control component.\n            bindings = [];\n    }\n    return bindings;\n};\n\nfunction computeAnimateBindings(gd, args) {\n    // We'll assume that the only relevant modification an animation\n    // makes that's meaningfully tracked is the frame:\n    if(Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {\n        return [{type: 'layout', prop: '_currentFrame', value: args[0][0].toString()}];\n    } else {\n        return [];\n    }\n}\n\nfunction computeLayoutBindings(gd, args) {\n    var bindings = [];\n\n    var astr = args[0];\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = args[1];\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = astr;\n    } else {\n        return bindings;\n    }\n\n    crawl(aobj, function(path, attrName, attr) {\n        bindings.push({type: 'layout', prop: path, value: attr});\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction computeDataBindings(gd, args) {\n    var traces, astr, val, aobj;\n    var bindings = [];\n\n    // Logic copied from Plotly.restyle:\n    astr = args[0];\n    val = args[1];\n    traces = args[2];\n    aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = astr;\n\n        if(traces === undefined) {\n            traces = val;\n        }\n    } else {\n        return bindings;\n    }\n\n    if(traces === undefined) {\n        // Explicitly assign this to null instead of undefined:\n        traces = null;\n    }\n\n    crawl(aobj, function(path, attrName, attr) {\n        var thisTraces;\n        if(Array.isArray(attr)) {\n            var nAttr = Math.min(attr.length, gd.data.length);\n            if(traces) {\n                nAttr = Math.min(nAttr, traces.length);\n            }\n            thisTraces = [];\n            for(var j = 0; j < nAttr; j++) {\n                thisTraces[j] = traces ? traces[j] : j;\n            }\n        } else {\n            thisTraces = traces ? traces.slice(0) : null;\n        }\n\n        // Convert [7] to just 7 when traces is null:\n        if(thisTraces === null) {\n            if(Array.isArray(attr)) {\n                attr = attr[0];\n            }\n        } else if(Array.isArray(thisTraces)) {\n            if(!Array.isArray(attr)) {\n                var tmp = attr;\n                attr = [];\n                for(var i = 0; i < thisTraces.length; i++) {\n                    attr[i] = tmp;\n                }\n            }\n            attr.length = Math.min(thisTraces.length, attr.length);\n        }\n\n        bindings.push({\n            type: 'data',\n            prop: path,\n            traces: thisTraces,\n            value: attr\n        });\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction crawl(attrs, callback, path, depth) {\n    Object.keys(attrs).forEach(function(attrName) {\n        var attr = attrs[attrName];\n\n        if(attrName[0] === '_') return;\n\n        var thisPath = path + (depth > 0 ? '.' : '') + attrName;\n\n        if(Lib.isPlainObject(attr)) {\n            crawl(attr, callback, thisPath, depth + 1);\n        } else {\n            // Only execute the callback on leaf nodes:\n            callback(thisPath, attrName, attr);\n        }\n    });\n}\n",null]}