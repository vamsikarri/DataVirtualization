{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/turntable-camera-controller/turntable.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/turntable-camera-controller/turntable.js","mtime":1529418312355},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\n\nmodule.exports = createTurntableController\n\nvar filterVector = require('filtered-vector')\nvar invert44     = require('gl-mat4/invert')\nvar rotateM      = require('gl-mat4/rotate')\nvar cross        = require('gl-vec3/cross')\nvar normalize3   = require('gl-vec3/normalize')\nvar dot3         = require('gl-vec3/dot')\n\nfunction len3(x, y, z) {\n  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2))\n}\n\nfunction clamp1(x) {\n  return Math.min(1.0, Math.max(-1.0, x))\n}\n\nfunction findOrthoPair(v) {\n  var vx = Math.abs(v[0])\n  var vy = Math.abs(v[1])\n  var vz = Math.abs(v[2])\n\n  var u = [0,0,0]\n  if(vx > Math.max(vy, vz)) {\n    u[2] = 1\n  } else if(vy > Math.max(vx, vz)) {\n    u[0] = 1\n  } else {\n    u[1] = 1\n  }\n\n  var vv = 0\n  var uv = 0\n  for(var i=0; i<3; ++i ) {\n    vv += v[i] * v[i]\n    uv += u[i] * v[i]\n  }\n  for(var i=0; i<3; ++i) {\n    u[i] -= (uv / vv) *  v[i]\n  }\n  normalize3(u, u)\n  return u\n}\n\nfunction TurntableController(zoomMin, zoomMax, center, up, right, radius, theta, phi) {\n  this.center = filterVector(center)\n  this.up     = filterVector(up)\n  this.right  = filterVector(right)\n  this.radius = filterVector([radius])\n  this.angle  = filterVector([theta, phi])\n  this.angle.bounds = [[-Infinity,-Math.PI/2], [Infinity,Math.PI/2]]\n  this.setDistanceLimits(zoomMin, zoomMax)\n\n  this.computedCenter = this.center.curve(0)\n  this.computedUp     = this.up.curve(0)\n  this.computedRight  = this.right.curve(0)\n  this.computedRadius = this.radius.curve(0)\n  this.computedAngle  = this.angle.curve(0)\n  this.computedToward = [0,0,0]\n  this.computedEye    = [0,0,0]\n  this.computedMatrix = new Array(16)\n  for(var i=0; i<16; ++i) {\n    this.computedMatrix[i] = 0.5\n  }\n\n  this.recalcMatrix(0)\n}\n\nvar proto = TurntableController.prototype\n\nproto.setDistanceLimits = function(minDist, maxDist) {\n  if(minDist > 0) {\n    minDist = Math.log(minDist)\n  } else {\n    minDist = -Infinity\n  }\n  if(maxDist > 0) {\n    maxDist = Math.log(maxDist)\n  } else {\n    maxDist = Infinity\n  }\n  maxDist = Math.max(maxDist, minDist)\n  this.radius.bounds[0][0] = minDist\n  this.radius.bounds[1][0] = maxDist\n}\n\nproto.getDistanceLimits = function(out) {\n  var bounds = this.radius.bounds[0]\n  if(out) {\n    out[0] = Math.exp(bounds[0][0])\n    out[1] = Math.exp(bounds[1][0])\n    return out\n  }\n  return [ Math.exp(bounds[0][0]), Math.exp(bounds[1][0]) ]\n}\n\nproto.recalcMatrix = function(t) {\n  //Recompute curves\n  this.center.curve(t)\n  this.up.curve(t)\n  this.right.curve(t)\n  this.radius.curve(t)\n  this.angle.curve(t)\n\n  //Compute frame for camera matrix\n  var up     = this.computedUp\n  var right  = this.computedRight\n  var uu = 0.0\n  var ur = 0.0\n  for(var i=0; i<3; ++i) {\n    ur += up[i] * right[i]\n    uu += up[i] * up[i]\n  }\n  var ul = Math.sqrt(uu)\n  var rr = 0.0\n  for(var i=0; i<3; ++i) {\n    right[i] -= up[i] * ur / uu\n    rr       += right[i] * right[i]\n    up[i]    /= ul\n  }\n  var rl = Math.sqrt(rr)\n  for(var i=0; i<3; ++i) {\n    right[i] /= rl\n  }\n\n  //Compute toward vector\n  var toward = this.computedToward\n  cross(toward, up, right)\n  normalize3(toward, toward)\n\n  //Compute angular parameters\n  var radius = Math.exp(this.computedRadius[0])\n  var theta  = this.computedAngle[0]\n  var phi    = this.computedAngle[1]\n\n  var ctheta = Math.cos(theta)\n  var stheta = Math.sin(theta)\n  var cphi   = Math.cos(phi)\n  var sphi   = Math.sin(phi)\n\n  var center = this.computedCenter\n\n  var wx = ctheta * cphi \n  var wy = stheta * cphi\n  var wz = sphi\n\n  var sx = -ctheta * sphi\n  var sy = -stheta * sphi\n  var sz = cphi\n\n  var eye = this.computedEye\n  var mat = this.computedMatrix\n  for(var i=0; i<3; ++i) {\n    var x      = wx * right[i] + wy * toward[i] + wz * up[i]\n    mat[4*i+1] = sx * right[i] + sy * toward[i] + sz * up[i]\n    mat[4*i+2] = x\n    mat[4*i+3] = 0.0\n  }\n\n  var ax = mat[1]\n  var ay = mat[5]\n  var az = mat[9]\n  var bx = mat[2]\n  var by = mat[6]\n  var bz = mat[10]\n  var cx = ay * bz - az * by\n  var cy = az * bx - ax * bz\n  var cz = ax * by - ay * bx\n  var cl = len3(cx, cy, cz)\n  cx /= cl\n  cy /= cl\n  cz /= cl\n  mat[0] = cx\n  mat[4] = cy\n  mat[8] = cz\n\n  for(var i=0; i<3; ++i) {\n    eye[i] = center[i] + mat[2+4*i]*radius\n  }\n\n  for(var i=0; i<3; ++i) {\n    var rr = 0.0\n    for(var j=0; j<3; ++j) {\n      rr += mat[i+4*j] * eye[j]\n    }\n    mat[12+i] = -rr\n  }\n  mat[15] = 1.0\n}\n\nproto.getMatrix = function(t, result) {\n  this.recalcMatrix(t)\n  var mat = this.computedMatrix\n  if(result) {\n    for(var i=0; i<16; ++i) {\n      result[i] = mat[i]\n    }\n    return result\n  }\n  return mat\n}\n\nvar zAxis = [0,0,0]\nproto.rotate = function(t, dtheta, dphi, droll) {\n  this.angle.move(t, dtheta, dphi)\n  if(droll) {\n    this.recalcMatrix(t)\n\n    var mat = this.computedMatrix\n    zAxis[0] = mat[2]\n    zAxis[1] = mat[6]\n    zAxis[2] = mat[10]\n\n    var up     = this.computedUp\n    var right  = this.computedRight\n    var toward = this.computedToward\n\n    for(var i=0; i<3; ++i) {\n      mat[4*i]   = up[i]\n      mat[4*i+1] = right[i]\n      mat[4*i+2] = toward[i]\n    }\n    rotateM(mat, mat, droll, zAxis)\n    for(var i=0; i<3; ++i) {\n      up[i] =    mat[4*i]\n      right[i] = mat[4*i+1]\n    }\n\n    this.up.set(t, up[0], up[1], up[2])\n    this.right.set(t, right[0], right[1], right[2])\n  }\n}\n\nproto.pan = function(t, dx, dy, dz) {\n  dx = dx || 0.0\n  dy = dy || 0.0\n  dz = dz || 0.0\n\n  this.recalcMatrix(t)\n  var mat = this.computedMatrix\n\n  var dist = Math.exp(this.computedRadius[0])\n\n  var ux = mat[1]\n  var uy = mat[5]\n  var uz = mat[9]\n  var ul = len3(ux, uy, uz)\n  ux /= ul\n  uy /= ul\n  uz /= ul\n\n  var rx = mat[0]\n  var ry = mat[4]\n  var rz = mat[8]\n  var ru = rx * ux + ry * uy + rz * uz\n  rx -= ux * ru\n  ry -= uy * ru\n  rz -= uz * ru\n  var rl = len3(rx, ry, rz)\n  rx /= rl\n  ry /= rl\n  rz /= rl\n\n  var vx = rx * dx + ux * dy\n  var vy = ry * dx + uy * dy\n  var vz = rz * dx + uz * dy\n  this.center.move(t, vx, vy, vz)\n\n  //Update z-component of radius\n  var radius = Math.exp(this.computedRadius[0])\n  radius = Math.max(1e-4, radius + dz)\n  this.radius.set(t, Math.log(radius))\n}\n\nproto.translate = function(t, dx, dy, dz) {\n  this.center.move(t,\n    dx||0.0,\n    dy||0.0,\n    dz||0.0)\n}\n\n//Recenters the coordinate axes\nproto.setMatrix = function(t, mat, axes, noSnap) {\n  \n  //Get the axes for tare\n  var ushift = 1\n  if(typeof axes === 'number') {\n    ushift = (axes)|0\n  } \n  if(ushift < 0 || ushift > 3) {\n    ushift = 1\n  }\n  var vshift = (ushift + 2) % 3\n  var fshift = (ushift + 1) % 3\n\n  //Recompute state for new t value\n  if(!mat) { \n    this.recalcMatrix(t)\n    mat = this.computedMatrix\n  }\n\n  //Get right and up vectors\n  var ux = mat[ushift]\n  var uy = mat[ushift+4]\n  var uz = mat[ushift+8]\n  if(!noSnap) {\n    var ul = len3(ux, uy, uz)\n    ux /= ul\n    uy /= ul\n    uz /= ul\n  } else {\n    var ax = Math.abs(ux)\n    var ay = Math.abs(uy)\n    var az = Math.abs(uz)\n    var am = Math.max(ax,ay,az)\n    if(ax === am) {\n      ux = (ux < 0) ? -1 : 1\n      uy = uz = 0\n    } else if(az === am) {\n      uz = (uz < 0) ? -1 : 1\n      ux = uy = 0\n    } else {\n      uy = (uy < 0) ? -1 : 1\n      ux = uz = 0\n    }\n  }\n\n  var rx = mat[vshift]\n  var ry = mat[vshift+4]\n  var rz = mat[vshift+8]\n  var ru = rx * ux + ry * uy + rz * uz\n  rx -= ux * ru\n  ry -= uy * ru\n  rz -= uz * ru\n  var rl = len3(rx, ry, rz)\n  rx /= rl\n  ry /= rl\n  rz /= rl\n  \n  var fx = uy * rz - uz * ry\n  var fy = uz * rx - ux * rz\n  var fz = ux * ry - uy * rx\n  var fl = len3(fx, fy, fz)\n  fx /= fl\n  fy /= fl\n  fz /= fl\n\n  this.center.jump(t, ex, ey, ez)\n  this.radius.idle(t)\n  this.up.jump(t, ux, uy, uz)\n  this.right.jump(t, rx, ry, rz)\n\n  var phi, theta\n  if(ushift === 2) {\n    var cx = mat[1]\n    var cy = mat[5]\n    var cz = mat[9]\n    var cr = cx * rx + cy * ry + cz * rz\n    var cf = cx * fx + cy * fy + cz * fz\n    if(tu < 0) {\n      phi = -Math.PI/2\n    } else {\n      phi = Math.PI/2\n    }\n    theta = Math.atan2(cf, cr)\n  } else {\n    var tx = mat[2]\n    var ty = mat[6]\n    var tz = mat[10]\n    var tu = tx * ux + ty * uy + tz * uz\n    var tr = tx * rx + ty * ry + tz * rz\n    var tf = tx * fx + ty * fy + tz * fz\n\n    phi = Math.asin(clamp1(tu))\n    theta = Math.atan2(tf, tr)\n  }\n\n  this.angle.jump(t, theta, phi)\n\n  this.recalcMatrix(t)\n  var dx = mat[2]\n  var dy = mat[6]\n  var dz = mat[10]\n\n  var imat = this.computedMatrix\n  invert44(imat, mat)\n  var w  = imat[15]\n  var ex = imat[12] / w\n  var ey = imat[13] / w\n  var ez = imat[14] / w\n\n  var gs = Math.exp(this.computedRadius[0])\n  this.center.jump(t, ex-dx*gs, ey-dy*gs, ez-dz*gs)\n}\n\nproto.lastT = function() {\n  return Math.max(\n    this.center.lastT(),\n    this.up.lastT(),\n    this.right.lastT(),\n    this.radius.lastT(),\n    this.angle.lastT())\n}\n\nproto.idle = function(t) {\n  this.center.idle(t)\n  this.up.idle(t)\n  this.right.idle(t)\n  this.radius.idle(t)\n  this.angle.idle(t)\n}\n\nproto.flush = function(t) {\n  this.center.flush(t)\n  this.up.flush(t)\n  this.right.flush(t)\n  this.radius.flush(t)\n  this.angle.flush(t)\n}\n\nproto.setDistance = function(t, d) {\n  if(d > 0) {\n    this.radius.set(t, Math.log(d))\n  }\n}\n\nproto.lookAt = function(t, eye, center, up) {\n  this.recalcMatrix(t)\n\n  eye    = eye    || this.computedEye\n  center = center || this.computedCenter\n  up     = up     || this.computedUp\n\n  var ux = up[0]\n  var uy = up[1]\n  var uz = up[2]\n  var ul = len3(ux, uy, uz)\n  if(ul < 1e-6) {\n    return\n  }\n  ux /= ul\n  uy /= ul\n  uz /= ul\n\n  var tx = eye[0] - center[0]\n  var ty = eye[1] - center[1]\n  var tz = eye[2] - center[2]\n  var tl = len3(tx, ty, tz)\n  if(tl < 1e-6) {\n    return\n  }\n  tx /= tl\n  ty /= tl\n  tz /= tl\n\n  var right = this.computedRight\n  var rx = right[0]\n  var ry = right[1]\n  var rz = right[2]\n  var ru = ux*rx + uy*ry + uz*rz\n  rx -= ru * ux\n  ry -= ru * uy\n  rz -= ru * uz\n  var rl = len3(rx, ry, rz)\n\n  if(rl < 0.01) {\n    rx = uy * tz - uz * ty\n    ry = uz * tx - ux * tz\n    rz = ux * ty - uy * tx\n    rl = len3(rx, ry, rz)\n    if(rl < 1e-6) {\n      return\n    }\n  }\n  rx /= rl\n  ry /= rl\n  rz /= rl\n\n  this.up.set(t, ux, uy, uz)\n  this.right.set(t, rx, ry, rz)\n  this.center.set(t, center[0], center[1], center[2])\n  this.radius.set(t, Math.log(tl))\n\n  var fx = uy * rz - uz * ry\n  var fy = uz * rx - ux * rz\n  var fz = ux * ry - uy * rx\n  var fl = len3(fx, fy, fz)\n  fx /= fl\n  fy /= fl\n  fz /= fl\n\n  var tu = ux*tx + uy*ty + uz*tz\n  var tr = rx*tx + ry*ty + rz*tz\n  var tf = fx*tx + fy*ty + fz*tz\n\n  var phi   = Math.asin(clamp1(tu))\n  var theta = Math.atan2(tf, tr)\n\n  var angleState = this.angle._state\n  var lastTheta  = angleState[angleState.length-1]\n  var lastPhi    = angleState[angleState.length-2]\n  lastTheta      = lastTheta % (2.0 * Math.PI)\n  var dp = Math.abs(lastTheta + 2.0 * Math.PI - theta)\n  var d0 = Math.abs(lastTheta - theta)\n  var dn = Math.abs(lastTheta - 2.0 * Math.PI - theta)\n  if(dp < d0) {\n    lastTheta += 2.0 * Math.PI\n  }\n  if(dn < d0) {\n    lastTheta -= 2.0 * Math.PI\n  }\n\n  this.angle.jump(this.angle.lastT(), lastTheta, lastPhi)\n  this.angle.set(t, theta, phi)\n}\n\nfunction createTurntableController(options) {\n  options = options || {}\n\n  var center = options.center || [0,0,0]\n  var up     = options.up     || [0,1,0]\n  var right  = options.right  || findOrthoPair(up)\n  var radius = options.radius || 1.0\n  var theta  = options.theta  || 0.0\n  var phi    = options.phi    || 0.0\n\n  center = [].slice.call(center, 0, 3)\n\n  up = [].slice.call(up, 0, 3)\n  normalize3(up, up)\n\n  right = [].slice.call(right, 0, 3)\n  normalize3(right, right)\n\n  if('eye' in options) {\n    var eye = options.eye\n    var toward = [\n      eye[0]-center[0],\n      eye[1]-center[1],\n      eye[2]-center[2]\n    ]\n    cross(right, toward, up)\n    if(len3(right[0], right[1], right[2]) < 1e-6) {\n      right = findOrthoPair(up)\n    } else {\n      normalize3(right, right)\n    }\n\n    radius = len3(toward[0], toward[1], toward[2])\n\n    var ut = dot3(up, toward) / radius\n    var rt = dot3(right, toward) / radius\n    phi    = Math.acos(ut)\n    theta  = Math.acos(rt)\n  }\n\n  //Use logarithmic coordinates for radius\n  radius = Math.log(radius)\n\n  //Return the controller\n  return new TurntableController(\n    options.zoomMin,\n    options.zoomMax,\n    center,\n    up,\n    right,\n    radius,\n    theta,\n    phi)\n}",null]}