{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/planar-graph-to-polyline/pg2pl.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/planar-graph-to-polyline/pg2pl.js","mtime":1529418310337},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\n\nmodule.exports = planarGraphToPolyline\n\nvar e2a = require('edges-to-adjacency-list')\nvar planarDual = require('planar-dual')\nvar preprocessPolygon = require('point-in-big-polygon')\nvar twoProduct = require('two-product')\nvar robustSum = require('robust-sum')\nvar uniq = require('uniq')\nvar trimLeaves = require('./lib/trim-leaves')\n\nfunction makeArray(length, fill) {\n  var result = new Array(length)\n  for(var i=0; i<length; ++i) {\n    result[i] = fill\n  }\n  return result\n}\n\nfunction makeArrayOfArrays(length) {\n  var result = new Array(length)\n  for(var i=0; i<length; ++i) {\n    result[i] = []\n  }\n  return result\n}\n\n\nfunction planarGraphToPolyline(edges, positions) {\n\n  //Trim leaves\n  var result = trimLeaves(edges, positions)\n  edges = result[0]\n  positions = result[1]\n\n  var numVertices = positions.length\n  var numEdges = edges.length\n\n  //Calculate adjacency list, check manifold\n  var adj = e2a(edges, positions.length)\n  for(var i=0; i<numVertices; ++i) {\n    if(adj[i].length % 2 === 1) {\n      throw new Error('planar-graph-to-polyline: graph must be manifold')\n    }\n  }\n\n  //Get faces\n  var faces = planarDual(edges, positions)\n\n  //Check orientation of a polygon using exact arithmetic\n  function ccw(c) {\n    var n = c.length\n    var area = [0]\n    for(var j=0; j<n; ++j) {\n      var a = positions[c[j]]\n      var b = positions[c[(j+1)%n]]\n      var t00 = twoProduct(-a[0], a[1])\n      var t01 = twoProduct(-a[0], b[1])\n      var t10 = twoProduct( b[0], a[1])\n      var t11 = twoProduct( b[0], b[1])\n      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)))\n    }\n    return area[area.length-1] > 0\n  }\n\n  //Extract all clockwise faces\n  faces = faces.filter(ccw)\n\n  //Detect which loops are contained in one another to handle parent-of relation\n  var numFaces = faces.length\n  var parent = new Array(numFaces)\n  var containment = new Array(numFaces)\n  for(var i=0; i<numFaces; ++i) {\n    parent[i] = i\n    var row = new Array(numFaces)\n    var loopVertices = faces[i].map(function(v) {\n      return positions[v]\n    })\n    var pmc = preprocessPolygon([loopVertices])\n    var count = 0\n    outer:\n    for(var j=0; j<numFaces; ++j) {\n      row[j] = 0\n      if(i === j) {\n        continue\n      }\n      var c = faces[j]\n      var n = c.length\n      for(var k=0; k<n; ++k) {\n        var d = pmc(positions[c[k]])\n        if(d !== 0) {\n          if(d < 0) {\n            row[j] = 1\n            count += 1\n          }\n          continue outer\n        }\n      }\n      row[j] = 1\n      count += 1\n    }\n    containment[i] = [count, i, row]\n  }\n  containment.sort(function(a,b) {\n    return b[0] - a[0]\n  })\n  for(var i=0; i<numFaces; ++i) {\n    var row = containment[i]\n    var idx = row[1]\n    var children = row[2]\n    for(var j=0; j<numFaces; ++j) {\n      if(children[j]) {\n        parent[j] = idx\n      }\n    }\n  }\n\n  //Initialize face adjacency list\n  var fadj = makeArrayOfArrays(numFaces)\n  for(var i=0; i<numFaces; ++i) {\n    fadj[i].push(parent[i])\n    fadj[parent[i]].push(i)\n  }\n\n  //Build adjacency matrix for edges\n  var edgeAdjacency = {}\n  var internalVertices = makeArray(numVertices, false)\n  for(var i=0; i<numFaces; ++i) {\n    var c = faces[i]\n    var n = c.length\n    for(var j=0; j<n; ++j) {\n      var a = c[j]\n      var b = c[(j+1)%n]\n      var key = Math.min(a,b) + \":\" + Math.max(a,b)\n      if(key in edgeAdjacency) {\n        var neighbor = edgeAdjacency[key]\n        fadj[neighbor].push(i)\n        fadj[i].push(neighbor)\n        internalVertices[a] = internalVertices[b] = true\n      } else {\n        edgeAdjacency[key] = i\n      }\n    }\n  }\n\n  function sharedBoundary(c) {\n    var n = c.length\n    for(var i=0; i<n; ++i) {\n      if(!internalVertices[c[i]]) {\n        return false\n      }\n    }\n    return true\n  }\n\n  var toVisit = []\n  var parity = makeArray(numFaces, -1)\n  for(var i=0; i<numFaces; ++i) {\n    if(parent[i] === i && !sharedBoundary(faces[i])) {\n      toVisit.push(i)\n      parity[i] = 0\n    } else {\n      parity[i] = -1\n    }\n  }\n\n  //Using face adjacency, classify faces as in/out\n  var result = []\n  while(toVisit.length > 0) {\n    var top = toVisit.pop()\n    var nbhd = fadj[top]\n    uniq(nbhd, function(a,b) {\n      return a-b\n    })\n    var nnbhr = nbhd.length\n    var p = parity[top]\n    var polyline\n    if(p === 0) {\n      var c = faces[top]\n      polyline = [c]\n    }\n    for(var i=0; i<nnbhr; ++i) {\n      var f = nbhd[i]\n      if(parity[f] >= 0) {\n        continue\n      }\n      parity[f] = p^1\n      toVisit.push(f)\n      if(p === 0) {\n        var c = faces[f]\n        if(!sharedBoundary(c)) {\n          c.reverse()\n          polyline.push(c)\n        }\n      }\n    }\n    if(p === 0) {\n      result.push(polyline)\n    }\n  }\n\n  return result\n}",null]}