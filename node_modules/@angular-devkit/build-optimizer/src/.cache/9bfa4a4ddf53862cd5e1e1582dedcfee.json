{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/splom/index.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/splom/index.js","mtime":1529418310746},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar createMatrix = require('regl-splom');\nvar arrayRange = require('array-range');\n\nvar Registry = require('../../registry');\nvar Grid = require('../../components/grid');\nvar Lib = require('../../lib');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar subTypes = require('../scatter/subtypes');\nvar calcMarkerSize = require('../scatter/calc').calcMarkerSize;\nvar calcAxisExpansion = require('../scatter/calc').calcAxisExpansion;\nvar calcColorscales = require('../scatter/colorscale_calc');\nvar convertMarkerSelection = require('../scattergl/convert').convertMarkerSelection;\nvar convertMarkerStyle = require('../scattergl/convert').convertMarkerStyle;\nvar calcHover = require('../scattergl').calcHover;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar TOO_MANY_POINTS = require('../scattergl/constants').TOO_MANY_POINTS;\n\nfunction calc(gd, trace) {\n    var dimensions = trace.dimensions;\n    var commonLength = trace._length;\n    var stash = {};\n    var opts = {};\n    // 'c' for calculated, 'l' for linear,\n    // only differ here for log axes, pass ldata to createMatrix as 'data'\n    var cdata = opts.cdata = [];\n    var ldata = opts.data = [];\n    var i, k, dim;\n\n    for(i = 0; i < dimensions.length; i++) {\n        dim = dimensions[i];\n\n        if(dim.visible) {\n            var axId = trace._diag[i][0] || trace._diag[i][1];\n            var ax = AxisIDs.getFromId(gd, axId);\n            if(ax) {\n                var ccol = makeCalcdata(ax, trace, dim);\n                var lcol = ax.type === 'log' ? Lib.simpleMap(ccol, ax.c2l) : ccol;\n                cdata.push(ccol);\n                ldata.push(lcol);\n            }\n        }\n    }\n\n    calcColorscales(trace);\n    Lib.extendFlat(opts, convertMarkerStyle(trace));\n\n    var visibleLength = cdata.length;\n    var hasTooManyPoints = (visibleLength * commonLength) > TOO_MANY_POINTS;\n\n    for(i = 0, k = 0; i < dimensions.length; i++) {\n        dim = dimensions[i];\n\n        if(dim.visible) {\n            var xa = AxisIDs.getFromId(gd, trace._diag[i][0]) || {};\n            var ya = AxisIDs.getFromId(gd, trace._diag[i][1]) || {};\n\n            // Re-use SVG scatter axis expansion routine except\n            // for graph with very large number of points where it\n            // performs poorly.\n            // In big data case, fake Axes.expand outputs with data bounds,\n            // and an average size for array marker.size inputs.\n            var ppad;\n            if(hasTooManyPoints) {\n                ppad = 2 * (opts.sizeAvg || Math.max(opts.size, 3));\n            } else {\n                ppad = calcMarkerSize(trace, commonLength);\n            }\n\n            calcAxisExpansion(gd, trace, xa, ya, cdata[k], cdata[k], ppad);\n            k++;\n        }\n    }\n\n    var scene = stash._scene = sceneUpdate(gd, stash);\n    if(!scene.matrix) scene.matrix = true;\n    scene.matrixOptions = opts;\n\n    scene.selectedOptions = convertMarkerSelection(trace, trace.selected);\n    scene.unselectedOptions = convertMarkerSelection(trace, trace.unselected);\n\n    return [{x: false, y: false, t: stash, trace: trace}];\n}\n\nfunction makeCalcdata(ax, trace, dim) {\n    // call makeCalcdata with fake input\n    var ccol = ax.makeCalcdata({\n        v: dim.values,\n        vcalendar: trace.calendar\n    }, 'v');\n\n    for(var i = 0; i < ccol.length; i++) {\n        ccol[i] = ccol[i] === BADNUM ? NaN : ccol[i];\n    }\n\n    return ccol;\n}\n\nfunction sceneUpdate(gd, stash) {\n    var scene = stash._scene;\n\n    var reset = {\n        dirty: true\n    };\n\n    var first = {\n        selectBatch: null,\n        unselectBatch: null,\n        matrix: false,\n        select: null\n    };\n\n    if(!scene) {\n        scene = stash._scene = Lib.extendFlat({}, reset, first);\n\n        scene.draw = function draw() {\n            // draw traces in selection mode\n            if(scene.matrix && scene.selectBatch) {\n                scene.matrix.draw(scene.unselectBatch, scene.selectBatch);\n            }\n\n            else if(scene.matrix) {\n                scene.matrix.draw();\n            }\n\n            scene.dirty = false;\n        };\n\n        // remove scene resources\n        scene.destroy = function destroy() {\n            if(scene.matrix) scene.matrix.destroy();\n\n            scene.matrixOptions = null;\n            scene.selectBatch = null;\n            scene.unselectBatch = null;\n\n            stash._scene = null;\n        };\n    }\n\n    // In case if we have scene from the last calc - reset data\n    if(!scene.dirty) {\n        Lib.extendFlat(scene, reset);\n    }\n\n    return scene;\n}\n\nfunction plot(gd, _, splomCalcData) {\n    if(!splomCalcData.length) return;\n\n    for(var i = 0; i < splomCalcData.length; i++) {\n        plotOne(gd, splomCalcData[i][0]);\n    }\n}\n\nfunction plotOne(gd, cd0) {\n    var fullLayout = gd._fullLayout;\n    var gs = fullLayout._size;\n    var trace = cd0.trace;\n    var stash = cd0.t;\n    var scene = stash._scene;\n    var matrixOpts = scene.matrixOptions;\n    var cdata = matrixOpts.cdata;\n    var regl = fullLayout._glcanvas.data()[0].regl;\n    var dragmode = fullLayout.dragmode;\n    var xa, ya;\n    var i, j, k;\n\n    if(cdata.length === 0) return;\n\n    // augment options with proper upper/lower halves\n    // regl-splom's default grid starts from bottom-left\n    matrixOpts.lower = trace.showupperhalf;\n    matrixOpts.upper = trace.showlowerhalf;\n    matrixOpts.diagonal = trace.diagonal.visible;\n\n    var dimensions = trace.dimensions;\n    var visibleLength = cdata.length;\n    var viewOpts = {};\n    viewOpts.ranges = new Array(visibleLength);\n    viewOpts.domains = new Array(visibleLength);\n\n    for(i = 0, k = 0; i < dimensions.length; i++) {\n        if(trace.dimensions[i].visible) {\n            var rng = viewOpts.ranges[k] = new Array(4);\n            var dmn = viewOpts.domains[k] = new Array(4);\n\n            xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n            if(xa) {\n                rng[0] = xa._rl[0];\n                rng[2] = xa._rl[1];\n                dmn[0] = xa.domain[0];\n                dmn[2] = xa.domain[1];\n            }\n\n            ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n            if(ya) {\n                rng[1] = ya._rl[0];\n                rng[3] = ya._rl[1];\n                dmn[1] = ya.domain[0];\n                dmn[3] = ya.domain[1];\n            }\n\n            k++;\n        }\n    }\n\n    viewOpts.viewport = [gs.l, gs.b, gs.w + gs.l, gs.h + gs.b];\n\n    if(scene.matrix === true) {\n        scene.matrix = createMatrix(regl);\n    }\n\n    var selectMode = dragmode === 'lasso' || dragmode === 'select' || !!trace.selectedpoints;\n    scene.selectBatch = null;\n    scene.unselectBatch = null;\n\n    if(selectMode) {\n        var commonLength = trace._length;\n\n        if(!scene.selectBatch) {\n            scene.selectBatch = [];\n            scene.unselectBatch = [];\n        }\n\n        // regenerate scene batch, if traces number changed during selection\n        if(trace.selectedpoints) {\n            scene.selectBatch = trace.selectedpoints;\n\n            var selPts = trace.selectedpoints;\n            var selDict = {};\n            for(i = 0; i < selPts.length; i++) {\n                selDict[selPts[i]] = true;\n            }\n            var unselPts = [];\n            for(i = 0; i < commonLength; i++) {\n                if(!selDict[i]) unselPts.push(i);\n            }\n            scene.unselectBatch = unselPts;\n        }\n\n        // precalculate px coords since we are not going to pan during select\n        var xpx = stash.xpx = new Array(visibleLength);\n        var ypx = stash.ypx = new Array(visibleLength);\n\n        for(i = 0, k = 0; i < dimensions.length; i++) {\n            if(trace.dimensions[i].visible) {\n                xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n                if(xa) {\n                    xpx[k] = new Array(commonLength);\n                    for(j = 0; j < commonLength; j++) {\n                        xpx[k][j] = xa.c2p(cdata[k][j]);\n                    }\n                }\n\n                ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n                if(ya) {\n                    ypx[k] = new Array(commonLength);\n                    for(j = 0; j < commonLength; j++) {\n                        ypx[k][j] = ya.c2p(cdata[k][j]);\n                    }\n                }\n\n                k++;\n            }\n        }\n\n        if(scene.selectBatch) {\n            scene.matrix.update(matrixOpts, matrixOpts);\n            scene.matrix.update(scene.unselectedOptions, scene.selectedOptions);\n            scene.matrix.update(viewOpts, viewOpts);\n        }\n        else {\n            // delete selection pass\n            scene.matrix.update(viewOpts, null);\n        }\n    }\n    else {\n        scene.matrix.update(matrixOpts);\n        scene.matrix.update(viewOpts);\n        stash.xpx = stash.ypx = null;\n    }\n\n    scene.draw();\n}\n\nfunction hoverPoints(pointData, xval, yval) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var stash = cd[0].t;\n    var scene = stash._scene;\n    var cdata = scene.matrixOptions.cdata;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var xpx = xa.c2p(xval);\n    var ypx = ya.c2p(yval);\n    var maxDistance = pointData.distance;\n\n    var xi = getDimIndex(trace, xa);\n    var yi = getDimIndex(trace, ya);\n    if(xi === false || yi === false) return [pointData];\n\n    var x = cdata[xi];\n    var y = cdata[yi];\n\n    var id, dxy;\n    var minDist = maxDistance;\n\n    for(var i = 0; i < x.length; i++) {\n        var ptx = x[i];\n        var pty = y[i];\n        var dx = xa.c2p(ptx) - xpx;\n        var dy = ya.c2p(pty) - ypx;\n        var dist = Math.sqrt(dx * dx + dy * dy);\n\n        if(dist < minDist) {\n            minDist = dxy = dist;\n            id = i;\n        }\n    }\n\n    pointData.index = id;\n    pointData.distance = minDist;\n    pointData.dxy = dxy;\n\n    if(id === undefined) return [pointData];\n\n    calcHover(pointData, x, y, trace);\n\n    return [pointData];\n}\n\nfunction selectPoints(searchInfo, polygon) {\n    var cd = searchInfo.cd;\n    var trace = cd[0].trace;\n    var stash = cd[0].t;\n    var scene = stash._scene;\n    var cdata = scene.matrixOptions.cdata;\n    var xa = searchInfo.xaxis;\n    var ya = searchInfo.yaxis;\n    var selection = [];\n    var i;\n\n    if(!scene) return selection;\n\n    var hasOnlyLines = (!subTypes.hasMarkers(trace) && !subTypes.hasText(trace));\n    if(trace.visible !== true || hasOnlyLines) return selection;\n\n    var xi = getDimIndex(trace, xa);\n    var yi = getDimIndex(trace, ya);\n    if(xi === false || yi === false) return selection;\n\n    var xpx = stash.xpx[xi];\n    var ypx = stash.ypx[yi];\n    var x = cdata[xi];\n    var y = cdata[yi];\n\n    // degenerate polygon does not enable selection\n    // filter out points by visible scatter ones\n    var els = null;\n    var unels = null;\n    if(polygon !== false && !polygon.degenerate) {\n        els = [], unels = [];\n        for(i = 0; i < x.length; i++) {\n            if(polygon.contains([xpx[i], ypx[i]])) {\n                els.push(i);\n                selection.push({\n                    pointNumber: i,\n                    x: x[i],\n                    y: y[i]\n                });\n            }\n            else {\n                unels.push(i);\n            }\n        }\n    } else {\n        unels = arrayRange(stash.count);\n    }\n\n    // make sure selectBatch is created\n    if(!scene.selectBatch) {\n        scene.selectBatch = [];\n        scene.unselectBatch = [];\n    }\n\n    if(!scene.selectBatch) {\n        // enter every trace select mode\n        for(i = 0; i < scene.count; i++) {\n            scene.selectBatch = [];\n            scene.unselectBatch = [];\n        }\n        // we should turn scatter2d into unselected once we have any points selected\n        scene.matrix.update(scene.unselectedOptions, scene.selectedOptions);\n    }\n\n    scene.selectBatch = els;\n    scene.unselectBatch = unels;\n\n\n    return selection;\n}\n\nfunction style(gd, cds) {\n    if(!cds) return;\n\n    var fullLayout = gd._fullLayout;\n    var cd0 = cds[0];\n    var scene0 = cd0[0].t._scene;\n    scene0.matrix.regl.clear({color: true, depth: true});\n\n    if(fullLayout._splomGrid) {\n        fullLayout._splomGrid.draw();\n    }\n\n    for(var i = 0; i < cds.length; i++) {\n        var scene = cds[i][0].t._scene;\n        scene.draw();\n    }\n\n    // redraw all subplot with scattergl traces,\n    // as we cleared the whole canvas above\n    if(fullLayout._has('cartesian')) {\n        for(var k in fullLayout._plots) {\n            var sp = fullLayout._plots[k];\n            if(sp._scene) sp._scene.draw();\n        }\n    }\n}\n\nfunction getDimIndex(trace, ax) {\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var ind = {x: 0, y: 1}[axLetter];\n    var dimensions = trace.dimensions;\n\n    for(var i = 0, k = 0; i < dimensions.length; i++) {\n        if(dimensions[i].visible) {\n            if(trace._diag[i][ind] === axId) return k;\n            k++;\n        }\n    }\n    return false;\n}\n\nmodule.exports = {\n    moduleType: 'trace',\n    name: 'splom',\n\n    basePlotModule: require('./base_plot'),\n    categories: ['gl', 'regl', 'cartesian', 'symbols', 'markerColorscale', 'showLegend', 'scatter-like'],\n\n    attributes: require('./attributes'),\n    supplyDefaults: require('./defaults'),\n\n    calc: calc,\n    plot: plot,\n    hoverPoints: hoverPoints,\n    selectPoints: selectPoints,\n    style: style,\n\n    meta: {\n        description: [\n            'Splom traces generate scatter plot matrix visualizations.',\n            'Each splom `dimensions` items correspond to a generated axis.',\n            'Values for each of those dimensions are set in `dimensions[i].values`.',\n            'Splom traces support all `scattergl` marker style attributes.',\n            'Specify `layout.grid` attributes and/or layout x-axis and y-axis attributes',\n            'for more control over the axis positioning and style. '\n        ].join(' ')\n    }\n};\n\n// splom traces use the 'grid' component to generate their axes,\n// register it here\nRegistry.register(Grid);\n",null]}