{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/violin/helpers.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/violin/helpers.js","mtime":1529418310750},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n// Maybe add kernels more down the road,\n// but note that the default `spanmode: 'soft'` bounds might have\n// to become kernel-dependent\nvar kernels = {\n    gaussian: function(v) {\n        return (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * v * v);\n    }\n};\n\nexports.makeKDE = function(calcItem, trace, vals) {\n    var len = vals.length;\n    var kernel = kernels.gaussian;\n    var bandwidth = calcItem.bandwidth;\n    var factor = 1 / (len * bandwidth);\n\n    // don't use Lib.aggNums to skip isNumeric checks\n    return function(x) {\n        var sum = 0;\n        for(var i = 0; i < len; i++) {\n            sum += kernel((x - vals[i]) / bandwidth);\n        }\n        return factor * sum;\n    };\n};\n\nexports.getPositionOnKdePath = function(calcItem, trace, valuePx) {\n    var posLetter, valLetter;\n\n    if(trace.orientation === 'h') {\n        posLetter = 'y';\n        valLetter = 'x';\n    } else {\n        posLetter = 'x';\n        valLetter = 'y';\n    }\n\n    var pointOnPath = Lib.findPointOnPath(\n        calcItem.path,\n        valuePx,\n        valLetter,\n        {pathLength: calcItem.pathLength}\n    );\n\n    var posCenterPx = calcItem.posCenterPx;\n    var posOnPath0 = pointOnPath[posLetter];\n    var posOnPath1 = trace.side === 'both' ?\n        2 * posCenterPx - posOnPath0 :\n        posCenterPx;\n\n    return [posOnPath0, posOnPath1];\n};\n\nexports.getKdeValue = function(calcItem, trace, valueDist) {\n    var vals = calcItem.pts.map(exports.extractVal);\n    var kde = exports.makeKDE(calcItem, trace, vals);\n    return kde(valueDist) / calcItem.posDensityScale;\n};\n\nexports.extractVal = function(o) { return o.v; };\n",null]}