{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/box/plot.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/box/plot.js","mtime":1529418310702},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\n\n// constants for dynamic jitter (ie less jitter for sparser points)\nvar JITTERCOUNT = 5; // points either side of this to include\nvar JITTERSPREAD = 0.01; // fraction of IQR to count as \"dense\"\n\nfunction plot(gd, plotinfo, cdbox, boxLayer) {\n    var fullLayout = gd._fullLayout;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var boxtraces = boxLayer.selectAll('g.trace.boxes')\n        .data(cdbox, function(d) { return d[0].trace.uid; });\n\n    boxtraces.enter().append('g')\n        .attr('class', 'trace boxes');\n\n    boxtraces.exit().remove();\n\n    boxtraces.order();\n\n    boxtraces.each(function(d) {\n        var cd0 = d[0];\n        var t = cd0.t;\n        var trace = cd0.trace;\n        var sel = d3.select(this);\n        if(!plotinfo.isRangePlot) cd0.node3 = sel;\n        var numBoxes = fullLayout._numBoxes;\n\n        var groupFraction = (1 - fullLayout.boxgap);\n\n        var group = (fullLayout.boxmode === 'group' && numBoxes > 1);\n        // box half width\n        var bdPos = t.dPos * groupFraction * (1 - fullLayout.boxgroupgap) / (group ? numBoxes : 1);\n        // box center offset\n        var bPos = group ? 2 * t.dPos * (-0.5 + (t.num + 0.5) / numBoxes) * groupFraction : 0;\n        // whisker width\n        var wdPos = bdPos * trace.whiskerwidth;\n\n        if(trace.visible !== true || t.empty) {\n            sel.remove();\n            return;\n        }\n\n        var posAxis, valAxis;\n\n        if(trace.orientation === 'h') {\n            posAxis = ya;\n            valAxis = xa;\n        } else {\n            posAxis = xa;\n            valAxis = ya;\n        }\n\n        // save the box size and box position for use by hover\n        t.bPos = bPos;\n        t.bdPos = bdPos;\n        t.wdPos = wdPos;\n        // half-width within which to accept hover for this box\n        // always split the distance to the closest box\n        t.wHover = t.dPos * (group ? groupFraction / numBoxes : 1);\n\n        // boxes and whiskers\n        plotBoxAndWhiskers(sel, {pos: posAxis, val: valAxis}, trace, t);\n\n        // draw points, if desired\n        if(trace.boxpoints) {\n            plotPoints(sel, {x: xa, y: ya}, trace, t);\n        }\n\n        // draw mean (and stdev diamond) if desired\n        if(trace.boxmean) {\n            plotBoxMean(sel, {pos: posAxis, val: valAxis}, trace, t);\n        }\n    });\n}\n\nfunction plotBoxAndWhiskers(sel, axes, trace, t) {\n    var posAxis = axes.pos;\n    var valAxis = axes.val;\n    var bPos = t.bPos;\n    var wdPos = t.wdPos || 0;\n    var bPosPxOffset = t.bPosPxOffset || 0;\n    var whiskerWidth = trace.whiskerwidth || 0;\n    var notched = trace.notched || false;\n    var nw = notched ? 1 - 2 * trace.notchwidth : 1;\n\n    // to support for one-sided box\n    var bdPos0;\n    var bdPos1;\n    if(Array.isArray(t.bdPos)) {\n        bdPos0 = t.bdPos[0];\n        bdPos1 = t.bdPos[1];\n    } else {\n        bdPos0 = t.bdPos;\n        bdPos1 = t.bdPos;\n    }\n\n    var paths = sel.selectAll('path.box').data(Lib.identity);\n\n    paths.enter().append('path')\n        .style('vector-effect', 'non-scaling-stroke')\n        .attr('class', 'box');\n\n    paths.exit().remove();\n\n    paths.each(function(d) {\n        var pos = d.pos;\n        var posc = posAxis.c2p(pos + bPos, true) + bPosPxOffset;\n        var pos0 = posAxis.c2p(pos + bPos - bdPos0, true) + bPosPxOffset;\n        var pos1 = posAxis.c2p(pos + bPos + bdPos1, true) + bPosPxOffset;\n        var posw0 = posAxis.c2p(pos + bPos - wdPos, true) + bPosPxOffset;\n        var posw1 = posAxis.c2p(pos + bPos + wdPos, true) + bPosPxOffset;\n        var posm0 = posAxis.c2p(pos + bPos - bdPos0 * nw, true) + bPosPxOffset;\n        var posm1 = posAxis.c2p(pos + bPos + bdPos1 * nw, true) + bPosPxOffset;\n        var q1 = valAxis.c2p(d.q1, true);\n        var q3 = valAxis.c2p(d.q3, true);\n        // make sure median isn't identical to either of the\n        // quartiles, so we can see it\n        var m = Lib.constrain(\n            valAxis.c2p(d.med, true),\n            Math.min(q1, q3) + 1, Math.max(q1, q3) - 1\n        );\n\n        // for compatibility with box, violin, and candlestick\n        // perhaps we should put this into cd0.t instead so it's more explicit,\n        // but what we have now is:\n        // - box always has d.lf, but boxpoints can be anything\n        // - violin has d.lf and should always use it (boxpoints is undefined)\n        // - candlestick has only min/max\n        var useExtremes = (d.lf === undefined) || (trace.boxpoints === false);\n        var lf = valAxis.c2p(useExtremes ? d.min : d.lf, true);\n        var uf = valAxis.c2p(useExtremes ? d.max : d.uf, true);\n        var ln = valAxis.c2p(d.ln, true);\n        var un = valAxis.c2p(d.un, true);\n\n        if(trace.orientation === 'h') {\n            d3.select(this).attr('d',\n                'M' + m + ',' + posm0 + 'V' + posm1 + // median line\n                'M' + q1 + ',' + pos0 + 'V' + pos1 + // left edge\n                (notched ? 'H' + ln + 'L' + m + ',' + posm1 + 'L' + un + ',' + pos1 : '') + // top notched edge\n                'H' + q3 + // end of the top edge\n                'V' + pos0 + // right edge\n                (notched ? 'H' + un + 'L' + m + ',' + posm0 + 'L' + ln + ',' + pos0 : '') + // bottom notched edge\n                'Z' + // end of the box\n                'M' + q1 + ',' + posc + 'H' + lf + 'M' + q3 + ',' + posc + 'H' + uf + // whiskers\n                ((whiskerWidth === 0) ? '' : // whisker caps\n                    'M' + lf + ',' + posw0 + 'V' + posw1 + 'M' + uf + ',' + posw0 + 'V' + posw1));\n        } else {\n            d3.select(this).attr('d',\n                'M' + posm0 + ',' + m + 'H' + posm1 + // median line\n                'M' + pos0 + ',' + q1 + 'H' + pos1 + // top of the box\n                (notched ? 'V' + ln + 'L' + posm1 + ',' + m + 'L' + pos1 + ',' + un : '') + // notched right edge\n                'V' + q3 + // end of the right edge\n                'H' + pos0 + // bottom of the box\n                (notched ? 'V' + un + 'L' + posm0 + ',' + m + 'L' + pos0 + ',' + ln : '') + // notched left edge\n                'Z' + // end of the box\n                'M' + posc + ',' + q1 + 'V' + lf + 'M' + posc + ',' + q3 + 'V' + uf + // whiskers\n                ((whiskerWidth === 0) ? '' : // whisker caps\n                    'M' + posw0 + ',' + lf + 'H' + posw1 + 'M' + posw0 + ',' + uf + 'H' + posw1));\n        }\n    });\n}\n\nfunction plotPoints(sel, axes, trace, t) {\n    var xa = axes.x;\n    var ya = axes.y;\n    var bdPos = t.bdPos;\n    var bPos = t.bPos;\n\n    // to support violin points\n    var mode = trace.boxpoints || trace.points;\n\n    // repeatable pseudo-random number generator\n    Lib.seedPseudoRandom();\n\n    var gPoints = sel.selectAll('g.points')\n        // since box plot points get an extra level of nesting, each\n        // box needs the trace styling info\n        .data(function(d) {\n            d.forEach(function(v) {\n                v.t = t;\n                v.trace = trace;\n            });\n            return d;\n        });\n\n    gPoints.enter().append('g')\n        .attr('class', 'points');\n\n    gPoints.exit().remove();\n\n    var paths = gPoints.selectAll('path')\n        .data(function(d) {\n            var i;\n\n            var pts = mode === 'all' ?\n                d.pts :\n                d.pts.filter(function(pt) { return (pt.v < d.lf || pt.v > d.uf); });\n\n            // normally use IQR, but if this is 0 or too small, use max-min\n            var typicalSpread = Math.max((d.max - d.min) / 10, d.q3 - d.q1);\n            var minSpread = typicalSpread * 1e-9;\n            var spreadLimit = typicalSpread * JITTERSPREAD;\n            var jitterFactors = [];\n            var maxJitterFactor = 0;\n            var newJitter;\n\n            // dynamic jitter\n            if(trace.jitter) {\n                if(typicalSpread === 0) {\n                    // edge case of no spread at all: fall back to max jitter\n                    maxJitterFactor = 1;\n                    jitterFactors = new Array(pts.length);\n                    for(i = 0; i < pts.length; i++) {\n                        jitterFactors[i] = 1;\n                    }\n                } else {\n                    for(i = 0; i < pts.length; i++) {\n                        var i0 = Math.max(0, i - JITTERCOUNT);\n                        var pmin = pts[i0].v;\n                        var i1 = Math.min(pts.length - 1, i + JITTERCOUNT);\n                        var pmax = pts[i1].v;\n\n                        if(mode !== 'all') {\n                            if(pts[i].v < d.lf) pmax = Math.min(pmax, d.lf);\n                            else pmin = Math.max(pmin, d.uf);\n                        }\n\n                        var jitterFactor = Math.sqrt(spreadLimit * (i1 - i0) / (pmax - pmin + minSpread)) || 0;\n                        jitterFactor = Lib.constrain(Math.abs(jitterFactor), 0, 1);\n\n                        jitterFactors.push(jitterFactor);\n                        maxJitterFactor = Math.max(jitterFactor, maxJitterFactor);\n                    }\n                }\n                newJitter = trace.jitter * 2 / (maxJitterFactor || 1);\n            }\n\n            // fills in 'x' and 'y' in calcdata 'pts' item\n            for(i = 0; i < pts.length; i++) {\n                var pt = pts[i];\n                var v = pt.v;\n\n                var jitterOffset = trace.jitter ?\n                    (newJitter * jitterFactors[i] * (Lib.pseudoRandom() - 0.5)) :\n                    0;\n\n                var posPx = d.pos + bPos + bdPos * (trace.pointpos + jitterOffset);\n\n                if(trace.orientation === 'h') {\n                    pt.y = posPx;\n                    pt.x = v;\n                } else {\n                    pt.x = posPx;\n                    pt.y = v;\n                }\n\n                // tag suspected outliers\n                if(mode === 'suspectedoutliers' && v < d.uo && v > d.lo) {\n                    pt.so = true;\n                }\n            }\n\n            return pts;\n        });\n\n    paths.enter().append('path')\n        .classed('point', true);\n\n    paths.exit().remove();\n\n    paths.call(Drawing.translatePoints, xa, ya);\n}\n\nfunction plotBoxMean(sel, axes, trace, t) {\n    var posAxis = axes.pos;\n    var valAxis = axes.val;\n    var bPos = t.bPos;\n    var bPosPxOffset = t.bPosPxOffset || 0;\n\n    // to support for one-sided box\n    var bdPos0;\n    var bdPos1;\n    if(Array.isArray(t.bdPos)) {\n        bdPos0 = t.bdPos[0];\n        bdPos1 = t.bdPos[1];\n    } else {\n        bdPos0 = t.bdPos;\n        bdPos1 = t.bdPos;\n    }\n\n    var paths = sel.selectAll('path.mean').data(Lib.identity);\n\n    paths.enter().append('path')\n        .attr('class', 'mean')\n        .style({\n            fill: 'none',\n            'vector-effect': 'non-scaling-stroke'\n        });\n\n    paths.exit().remove();\n\n    paths.each(function(d) {\n        var posc = posAxis.c2p(d.pos + bPos, true) + bPosPxOffset;\n        var pos0 = posAxis.c2p(d.pos + bPos - bdPos0, true) + bPosPxOffset;\n        var pos1 = posAxis.c2p(d.pos + bPos + bdPos1, true) + bPosPxOffset;\n        var m = valAxis.c2p(d.mean, true);\n        var sl = valAxis.c2p(d.mean - d.sd, true);\n        var sh = valAxis.c2p(d.mean + d.sd, true);\n\n        if(trace.orientation === 'h') {\n            d3.select(this).attr('d',\n                'M' + m + ',' + pos0 + 'V' + pos1 +\n                (trace.boxmean === 'sd' ?\n                    'm0,0L' + sl + ',' + posc + 'L' + m + ',' + pos0 + 'L' + sh + ',' + posc + 'Z' :\n                    '')\n            );\n        } else {\n            d3.select(this).attr('d',\n                'M' + pos0 + ',' + m + 'H' + pos1 +\n                (trace.boxmean === 'sd' ?\n                    'm0,0L' + posc + ',' + sl + 'L' + pos0 + ',' + m + 'L' + posc + ',' + sh + 'Z' :\n                    '')\n            );\n        }\n    });\n}\n\nmodule.exports = {\n    plot: plot,\n    plotBoxAndWhiskers: plotBoxAndWhiskers,\n    plotPoints: plotPoints,\n    plotBoxMean: plotBoxMean\n};\n",null]}