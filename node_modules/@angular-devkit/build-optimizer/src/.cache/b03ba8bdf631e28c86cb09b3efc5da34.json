{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/regl-scatter2d/scatter.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/regl-scatter2d/scatter.js","mtime":1529418310999},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\r\n\r\nconst rgba = require('color-normalize')\r\nconst getBounds = require('array-bounds')\r\nconst colorId = require('color-id')\r\nconst cluster = require('point-cluster')\r\nconst extend = require('object-assign')\r\nconst glslify = require('glslify')\r\nconst pick = require('pick-by-alias')\r\nconst updateDiff = require('update-diff')\r\nconst flatten = require('flatten-vertex-data')\r\nconst ie = require('is-iexplorer')\r\nconst {float32, fract32} = require('to-float32')\r\nconst parseRect = require('parse-rect')\r\n\r\n\r\nmodule.exports = Scatter\r\n\r\n\r\nfunction Scatter (regl, options) {\r\n\tif (!(this instanceof Scatter)) return new Scatter(regl, options)\r\n\r\n\tif (typeof regl === 'function') {\r\n\t\tif (!options) options = {}\r\n\t\toptions.regl = regl\r\n\t}\r\n\telse {\r\n\t\toptions = regl\r\n\t\tregl = null\r\n\t}\r\n\r\n\tif (options && options.length) options.positions = options\r\n\r\n\tregl = options.regl\r\n\r\n\t// persistent variables\r\n\tlet gl = regl._gl, paletteTexture, palette = [], paletteIds = {},\r\n\r\n\t\t// state\r\n\t\tgroups = [],\r\n\r\n\t\t// textures for marker keys\r\n\t\tmarkerTextures = [null],\r\n\t\tmarkerCache = [null]\r\n\r\n\tconst maxColors = 255, maxSize = 100\r\n\r\n\t// direct color buffer mode\r\n\t// IE does not support palette anyways\r\n\tthis.tooManyColors = ie\r\n\r\n\t// texture with color palette\r\n\tpaletteTexture = regl.texture({\r\n\t\tdata: new Uint8Array(maxColors * 4),\r\n\t\twidth: maxColors,\r\n\t\theight: 1,\r\n\t\ttype: 'uint8',\r\n\t\tformat: 'rgba',\r\n\t\twrapS: 'clamp',\r\n\t\twrapT: 'clamp',\r\n\t\tmag: 'nearest',\r\n\t\tmin: 'nearest'\r\n\t})\r\n\r\n\textend(this, {\r\n\t\tregl,\r\n\t\tgl,\r\n\t\tgroups,\r\n\t\tmarkerCache,\r\n\t\tmarkerTextures,\r\n\t\tpalette,\r\n\t\tpaletteIds,\r\n\t\tpaletteTexture,\r\n\t\tmaxColors,\r\n\t\tmaxSize,\r\n\t\tcanvas: gl.canvas\r\n\t})\r\n\r\n\tthis.update(options)\r\n\r\n\t// common shader options\r\n\tlet shaderOptions = {\r\n\t\tuniforms: {\r\n\t\t\tpixelRatio: regl.context('pixelRatio'),\r\n\t\t\tpalette: paletteTexture,\r\n\t\t\tpaletteSize: (ctx, prop) => [this.tooManyColors ? 0 : maxColors, paletteTexture.height],\r\n\t\t\tscale: regl.prop('scale'),\r\n\t\t\tscaleFract: regl.prop('scaleFract'),\r\n\t\t\ttranslate: regl.prop('translate'),\r\n\t\t\ttranslateFract: regl.prop('translateFract'),\r\n\t\t\topacity: regl.prop('opacity'),\r\n\t\t\tmarker: regl.prop('markerTexture'),\r\n\t\t},\r\n\r\n\t\tattributes: {\r\n\t\t\t// FIXME: optimize these parts\r\n\t\t\tx: (ctx, prop) => prop.xAttr || {\r\n\t\t\t\tbuffer: prop.positionBuffer,\r\n\t\t\t\tstride: 8,\r\n\t\t\t\toffset: 0\r\n\t\t\t},\r\n\t\t\ty: (ctx, prop) => prop.yAttr || {\r\n\t\t\t\tbuffer: prop.positionBuffer,\r\n\t\t\t\tstride: 8,\r\n\t\t\t\toffset: 4\r\n\t\t\t},\r\n\t\t\txFract: (ctx, prop) => prop.xAttr ? { constant: [0, 0] } : {\r\n\t\t\t\tbuffer: prop.positionFractBuffer,\r\n\t\t\t\tstride: 8,\r\n\t\t\t\toffset: 0\r\n\t\t\t},\r\n\t\t\tyFract: (ctx, prop) => prop.yAttr ? { constant: [0, 0] } : {\r\n\t\t\t\tbuffer: prop.positionFractBuffer,\r\n\t\t\t\tstride: 8,\r\n\t\t\t\toffset: 4\r\n\t\t\t},\r\n\t\t\tsize: (ctx, prop) => prop.size.length ? {\r\n\t\t\t\tbuffer: prop.sizeBuffer,\r\n\t\t\t\tstride: 2,\r\n\t\t\t\toffset: 0\r\n\t\t\t} : {\r\n\t\t\t\tconstant: [ Math.round(prop.size * 255 / this.maxSize) ]\r\n\t\t\t},\r\n\t\t\tborderSize: (ctx, prop) => prop.borderSize.length ? {\r\n\t\t\t\tbuffer: prop.sizeBuffer,\r\n\t\t\t\tstride: 2,\r\n\t\t\t\toffset: 1\r\n\t\t\t} : {\r\n\t\t\t\tconstant: [ Math.round(prop.borderSize * 255 / this.maxSize) ]\r\n\t\t\t},\r\n\t\t\tcolorId: (ctx, prop) => prop.color.length ? {\r\n\t\t\t\tbuffer: prop.colorBuffer,\r\n\t\t\t\tstride: this.tooManyColors ? 8 : 4,\r\n\t\t\t\toffset: 0\r\n\t\t\t} : {\r\n\t\t\t\tconstant: this.tooManyColors ? palette.slice(prop.color * 4, prop.color * 4 + 4) : [ prop.color ]\r\n\t\t\t},\r\n\t\t\tborderColorId: (ctx, prop) => prop.borderColor.length ? {\r\n\t\t\t\tbuffer: prop.colorBuffer,\r\n\t\t\t\tstride: this.tooManyColors ? 8 : 4,\r\n\t\t\t\toffset: this.tooManyColors ? 4 : 2\r\n\t\t\t} : {\r\n\t\t\t\tconstant: this.tooManyColors ? palette.slice(prop.borderColor * 4, prop.borderColor * 4 + 4) : [ prop.borderColor ]\r\n\t\t\t},\r\n\t\t\tisActive: (ctx, prop) => prop.activation === true ? { constant: [1] } : prop.activation ? prop.activation : { constant: [0] }\r\n\t\t},\r\n\r\n\t\tblend: {\r\n\t\t\tenable: true,\r\n\t\t\tcolor: [0,0,0,1],\r\n\r\n\t\t\t// photoshop blending\r\n\t\t\tfunc: {\r\n\t\t\t\tsrcRGB: 'src alpha',\r\n\t\t\t\tdstRGB: 'one minus src alpha',\r\n\t\t\t\tsrcAlpha: 'one minus dst alpha',\r\n\t\t\t\tdstAlpha: 'one'\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tscissor: {\r\n\t\t\tenable: true,\r\n\t\t\tbox: regl.prop('viewport')\r\n\t\t},\r\n\t\tviewport: regl.prop('viewport'),\r\n\r\n\t\tstencil: {enable: false},\r\n\t\tdepth: {enable: false},\r\n\r\n\t\telements: regl.prop('elements'),\r\n\t\tcount: regl.prop('count'),\r\n\t\toffset: regl.prop('offset'),\r\n\r\n\t\tprimitive: 'points'\r\n\t}\r\n\r\n\t// draw sdf-marker\r\n\tlet markerOptions = extend({}, shaderOptions)\r\n\tmarkerOptions.frag = glslify('./marker-frag.glsl')\r\n\tmarkerOptions.vert = glslify('./marker-vert.glsl')\r\n\r\n\ttry {\r\n\t\tthis.drawMarker = regl(markerOptions)\r\n\t} catch (e) {\r\n\t}\r\n\r\n\t// draw circle\r\n\tlet circleOptions = extend({}, shaderOptions)\r\n\tcircleOptions.frag = glslify('./circle-frag.glsl')\r\n\tcircleOptions.vert = glslify('./circle-vert.glsl')\r\n\r\n\t// polyfill IE\r\n\tif (ie) circleOptions.frag = circleOptions.frag.replace('smoothstep', 'smoothStep')\r\n\r\n\tthis.drawCircle = regl(circleOptions)\r\n}\r\n\r\n// single pass defaults\r\nScatter.defaults = {\r\n\tcolor: 'black',\r\n\tborderColor: 'transparent',\r\n\tborderSize: 0,\r\n\tsize: 12,\r\n\topacity: 1,\r\n\tmarker: undefined,\r\n\tviewport: null,\r\n\trange: null,\r\n\tpixelSize: null,\r\n\tcount: 0,\r\n\toffset: 0,\r\n\tbounds: null,\r\n\tpositions: [],\r\n\tsnap: 1e4\r\n}\r\n\r\n\r\n// update & redraw\r\nScatter.prototype.render = function (...args) {\r\n\tif (args.length) {\r\n\t\tthis.update(...args)\r\n\t}\r\n\r\n\tthis.draw()\r\n\r\n\treturn this\r\n}\r\n\r\n\r\n// draw all groups or only indicated ones\r\nScatter.prototype.draw = function (...args) {\r\n\tlet { groups } = this\r\n\r\n\t// if directly array passed - treat as passes\r\n\tif (args.length === 1 && Array.isArray(args[0])  && (args[0][0] === null || Array.isArray(args[0][0]))) {\r\n\t\targs = args[0]\r\n\t}\r\n\r\n\t// FIXME: remove once https://github.com/regl-project/regl/issues/474 resolved\r\n\tthis.regl._refresh()\r\n\r\n\tif (args.length) {\r\n\t\tfor (let i = 0; i < args.length; i++) {\r\n\t\t\tthis.drawItem(i, args[i])\r\n\t\t}\r\n\t}\r\n\t// draw all passes\r\n\telse {\r\n\t\tgroups.forEach((group, i) => {\r\n\t\t\tthis.drawItem(i)\r\n\t\t})\r\n\t}\r\n\r\n\treturn this\r\n}\r\n\r\n// draw specific scatter group\r\nScatter.prototype.drawItem = function (id, els) {\r\n\tlet { groups } = this\r\n\tlet group = groups[id]\r\n\r\n\t// debug viewport\r\n\t// let { viewport } = group\r\n\t// gl.enable(gl.SCISSOR_TEST);\r\n\t// gl.scissor(viewport.x, viewport.y, viewport.width, viewport.height);\r\n\t// gl.clearColor(0, 0, 0, .5);\r\n\t// gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n\tif (typeof els === 'number') {\r\n\t\tid = els\r\n\t\tgroup = groups[els]\r\n\t\tels = null\r\n\t}\r\n\r\n\tif (!(group && group.count && group.opacity)) return\r\n\r\n\t// draw circles\r\n\tif (group.activation[0]) {\r\n\t\t// TODO: optimize this performance by making groups and regl.this props\r\n\t\tthis.drawCircle(this.getMarkerDrawOptions(0, group, els))\r\n\t}\r\n\r\n\t// draw all other available markers\r\n\tlet batch = []\r\n\r\n\tfor (let i = 1; i < group.activation.length; i++) {\r\n\t\tif (!group.activation[i] || (group.activation[i] !== true && !group.activation[i].data.length)) continue\r\n\r\n\t\tbatch.push(...this.getMarkerDrawOptions(i, group, els))\r\n\t}\r\n\r\n\tif (batch.length) {\r\n\t\tthis.drawMarker(batch)\r\n\t}\r\n}\r\n\r\n// get options for the marker ids\r\nScatter.prototype.getMarkerDrawOptions = function(markerId, group, elements) {\r\n\tlet { range, tree, viewport, activation, selectionBuffer, count } = group\r\n\tlet { regl } = this\r\n\r\n\t// direct points\r\n\tif (!tree) {\r\n\t\t// if elements array - draw unclustered points\r\n\t\tif (elements) {\r\n\t\t\treturn [extend({}, group, {\r\n\t\t\t\tmarkerTexture: this.markerTextures[markerId],\r\n\t\t\t\tactivation: activation[markerId],\r\n\t\t\t\tcount: elements.length,\r\n\t\t\t\telements,\r\n\t\t\t\toffset: 0\r\n\t\t\t})]\r\n\t\t}\r\n\r\n\t\treturn [ extend({}, group, {\r\n\t\t\tmarkerTexture: this.markerTextures[markerId],\r\n\t\t\tactivation: activation[markerId],\r\n\t\t\toffset: 0\r\n\t\t}) ]\r\n\t}\r\n\r\n\t// clustered points\r\n\tlet batch = []\r\n\r\n\tlet lod = tree.range(range, { lod: true, px: [\r\n\t\t(range[2] - range[0]) / viewport.width,\r\n\t\t(range[3] - range[1]) / viewport.height\r\n\t]})\r\n\r\n\t// enable elements by using selection buffer\r\n\tif (elements) {\r\n\t\tlet markerActivation = activation[markerId]\r\n\t\tlet mask = markerActivation.data\r\n\t\tlet data = new Uint8Array(count)\r\n\t\tfor (let i = 0; i < elements.length; i++) {\r\n\t\t\tlet id = elements[i]\r\n\t\t\tdata[id] = mask ? mask[id] : 1\r\n\t\t}\r\n\t\tselectionBuffer.subdata(data)\r\n\t}\r\n\r\n\tfor (let l = lod.length; l--;) {\r\n\t\tlet [from, to] = lod[l]\r\n\r\n\t\tbatch.push(extend({}, group, {\r\n\t\t\tmarkerTexture: this.markerTextures[markerId],\r\n\t\t\tactivation: elements ? selectionBuffer : activation[markerId],\r\n\t\t\toffset: from,\r\n\t\t\tcount: to - from\r\n\t\t}))\r\n\t}\r\n\r\n\treturn batch\r\n}\r\n\r\n// update groups options\r\nScatter.prototype.update = function (...args) {\r\n\tif (!args.length) return\r\n\r\n\t// passes are as single array\r\n\tif (args.length === 1 && Array.isArray(args[0])) args = args[0]\r\n\r\n\tlet { groups, gl, regl, maxSize, maxColors, palette } = this\r\n\r\n\tthis.groups = groups = args.map((options, i) => {\r\n\t\tlet group = groups[i]\r\n\r\n\t\tif (options === undefined) return group\r\n\r\n\t\tif (options === null) options = { positions: null }\r\n\t\telse if (typeof options === 'function') options = { ondraw: options }\r\n\t\telse if (typeof options[0] === 'number') options = { positions: options }\r\n\r\n\t\t// copy options to avoid mutation & handle aliases\r\n\t\toptions = pick(options, {\r\n\t\t\tpositions: 'positions data points',\r\n\t\t\tsnap: 'snap cluster lod tree',\r\n\t\t\tsize: 'sizes size radius',\r\n\t\t\tborderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\r\n\t\t\tcolor: 'colors color fill fill-color fillColor',\r\n\t\t\tborderColor: 'borderColors borderColor stroke stroke-color strokeColor',\r\n\t\t\tmarker: 'markers marker shape',\r\n\t\t\trange: 'range dataBox databox',\r\n\t\t\tviewport: 'viewport viewPort viewBox viewbox',\r\n\t\t\topacity: 'opacity alpha transparency',\r\n\t\t\tbounds: 'bound bounds boundaries limits'\r\n\t\t})\r\n\r\n\t\tif (options.positions === null) options.positions = []\r\n\r\n\t\tif (!group) {\r\n\t\t\tgroups[i] = group = {\r\n\t\t\t\tid: i,\r\n\t\t\t\tscale: null,\r\n\t\t\t\ttranslate: null,\r\n\t\t\t\tscaleFract: null,\r\n\t\t\t\ttranslateFract: null,\r\n\r\n\t\t\t\t// buffers for active markers\r\n\t\t\t\tactivation: [],\r\n\r\n\t\t\t\t// buffer for filtered markers\r\n\t\t\t\tselectionBuffer: regl.buffer({\r\n\t\t\t\t\tdata: new Uint8Array(0),\r\n\t\t\t\t\tusage: 'stream',\r\n\t\t\t\t\ttype: 'uint8'\r\n\t\t\t\t}),\r\n\r\n\t\t\t\t// buffers with data: it is faster to switch them per-pass\r\n\t\t\t\t// than provide one congregate buffer\r\n\t\t\t\tsizeBuffer: regl.buffer({\r\n\t\t\t\t\tdata: new Uint8Array(0),\r\n\t\t\t\t\tusage: 'dynamic',\r\n\t\t\t\t\ttype: 'uint8'\r\n\t\t\t\t}),\r\n\t\t\t\tcolorBuffer: regl.buffer({\r\n\t\t\t\t\tdata: new Uint8Array(0),\r\n\t\t\t\t\tusage: 'dynamic',\r\n\t\t\t\t\ttype: 'uint8'\r\n\t\t\t\t}),\r\n\t\t\t\tpositionBuffer: regl.buffer({\r\n\t\t\t\t\tdata: new Uint8Array(0),\r\n\t\t\t\t\tusage: 'dynamic',\r\n\t\t\t\t\ttype: 'float'\r\n\t\t\t\t}),\r\n\t\t\t\tpositionFractBuffer: regl.buffer({\r\n\t\t\t\t\tdata: new Uint8Array(0),\r\n\t\t\t\t\tusage: 'dynamic',\r\n\t\t\t\t\ttype: 'float'\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\toptions = extend({}, Scatter.defaults, options)\r\n\t\t}\r\n\r\n\t\t// force update triggers\r\n\t\tif (options.positions && !('marker' in options)) {\r\n\t\t\toptions.marker = group.marker\r\n\t\t\tdelete group.marker\r\n\t\t}\r\n\r\n\t\t// updating markers cause recalculating snapping\r\n\t\tif (options.marker && !('positions' in options)) {\r\n\t\t\toptions.positions = group.positions\r\n\t\t\tdelete group.positions\r\n\t\t}\r\n\r\n\t\t// global count of points\r\n\t\tlet hasSize = 0, hasColor = 0\r\n\r\n\t\tupdateDiff(group, options, [{\r\n\t\t\tsnap: true,\r\n\t\t\tsize: (s, group) => {\r\n\t\t\t\tif (s == null) s = Scatter.defaults.size\r\n\t\t\t\thasSize += s && s.length ? 1 : 0\r\n\t\t\t\treturn s\r\n\t\t\t},\r\n\t\t\tborderSize: (s, group) => {\r\n\t\t\t\tif (s == null) s = Scatter.defaults.borderSize\r\n\t\t\t\thasSize += s && s.length ? 1 : 0\r\n\t\t\t\treturn s\r\n\t\t\t},\r\n\t\t\topacity: parseFloat,\r\n\r\n\t\t\t// add colors to palette, save references\r\n\t\t\tcolor: (c, group) => {\r\n\t\t\t\tif (c == null) c = Scatter.defaults.color\r\n\t\t\t\tc = this.updateColor(c)\r\n\t\t\t\thasColor++\r\n\t\t\t\treturn c\r\n\t\t\t},\r\n\t\t\tborderColor: (c, group) => {\r\n\t\t\t\tif (c == null) c = Scatter.defaults.borderColor\r\n\t\t\t\tc = this.updateColor(c)\r\n\t\t\t\thasColor++\r\n\t\t\t\treturn c\r\n\t\t\t},\r\n\r\n\t\t\tbounds: (bounds, group, options) => {\r\n\t\t\t\tif (!('range' in options)) options.range = null\r\n\t\t\t\treturn bounds\r\n\t\t\t},\r\n\r\n\t\t\tpositions: (positions, group, options) => {\r\n\t\t\t\tlet { snap } = group\r\n\t\t\t\tlet { positionBuffer, positionFractBuffer, selectionBuffer } = group\r\n\r\n\t\t\t\t// separate buffers for x/y coordinates\r\n\t\t\t\tif (positions.x || positions.y) {\r\n\t\t\t\t\tif (positions.x.length) {\r\n\t\t\t\t\t\tgroup.xAttr = {\r\n\t\t\t\t\t\t\tbuffer: regl.buffer(positions.x),\r\n\t\t\t\t\t\t\toffset: 0,\r\n\t\t\t\t\t\t\tstride: 4,\r\n\t\t\t\t\t\t\tcount: positions.x.length\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tgroup.xAttr = {\r\n\t\t\t\t\t\t\tbuffer: positions.x.buffer,\r\n\t\t\t\t\t\t\toffset: positions.x.offset * 4 || 0,\r\n\t\t\t\t\t\t\tstride: (positions.x.stride || 1) * 4,\r\n\t\t\t\t\t\t\tcount: positions.x.count\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (positions.y.length) {\r\n\t\t\t\t\t\tgroup.yAttr = {\r\n\t\t\t\t\t\t\tbuffer: regl.buffer(positions.y),\r\n\t\t\t\t\t\t\toffset: 0,\r\n\t\t\t\t\t\t\tstride: 4,\r\n\t\t\t\t\t\t\tcount: positions.y.length\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tgroup.yAttr = {\r\n\t\t\t\t\t\t\tbuffer: positions.y.buffer,\r\n\t\t\t\t\t\t\toffset: positions.y.offset * 4 || 0,\r\n\t\t\t\t\t\t\tstride: (positions.y.stride || 1) * 4,\r\n\t\t\t\t\t\t\tcount: positions.y.count\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.count = Math.max(group.xAttr.count, group.yAttr.count)\r\n\r\n\t\t\t\t\treturn positions\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpositions = flatten(positions, 'float64')\r\n\r\n\t\t\t\tlet count = group.count = Math.floor(positions.length / 2)\r\n\t\t\t\tlet bounds = group.bounds = count ? getBounds(positions, 2) : null\r\n\r\n\t\t\t\t// if range is not provided updated - recalc it\r\n\t\t\t\tif (!options.range && !group.range) {\r\n\t\t\t\t\tdelete group.range\r\n\t\t\t\t\toptions.range = bounds\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// reset marker\r\n\t\t\t\tif (!options.marker && !group.marker) {\r\n\t\t\t\t\tdelete group.marker;\r\n\t\t\t\t\toptions.marker = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// build cluster tree if required\r\n\t\t\t\tif (snap && (snap === true || count > snap)) {\r\n\t\t\t\t\tgroup.tree = cluster(positions, { bounds })\r\n\t\t\t\t}\r\n\t\t\t\t// existing tree instance\r\n\t\t\t\telse if (snap && snap.length) {\r\n\t\t\t\t\tgroup.tree = snap\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (group.tree) {\r\n\t\t\t\t\tlet opts = {\r\n\t\t\t\t\t\tprimitive: 'points',\r\n\t\t\t\t\t\tusage: 'static',\r\n\t\t\t\t\t\tdata: group.tree,\r\n\t\t\t\t\t\ttype: 'uint32'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (group.elements) group.elements(opts)\r\n\t\t\t\t\telse group.elements = regl.elements(opts)\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// update position buffers\r\n\t\t\t\tpositionBuffer({\r\n\t\t\t\t\tdata: float32(positions),\r\n\t\t\t\t\tusage: 'dynamic'\r\n\t\t\t\t})\r\n\t\t\t\tpositionFractBuffer({\r\n\t\t\t\t\tdata: fract32(positions),\r\n\t\t\t\t\tusage: 'dynamic'\r\n\t\t\t\t})\r\n\r\n\t\t\t\t// expand selectionBuffer\r\n\t\t\t\tselectionBuffer({\r\n\t\t\t\t\tdata: new Uint8Array(count),\r\n\t\t\t\t\ttype: 'uint8',\r\n\t\t\t\t\tusage: 'stream'\r\n\t\t\t\t})\r\n\r\n\t\t\t\treturn positions\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\t// create marker ids corresponding to known marker textures\r\n\t\t\tmarker: (markers, group, options) => {\r\n\t\t\t\tlet { activation } = group\r\n\r\n\t\t\t\t// reset marker elements\r\n\t\t\t\tactivation.forEach(buffer => buffer && buffer.destroy && buffer.destroy())\r\n\t\t\t\tactivation.length = 0\r\n\r\n\t\t\t\t// single sdf marker\r\n\t\t\t\tif (!markers || typeof markers[0] === 'number') {\r\n\t\t\t\t\tlet id = this.addMarker(markers)\r\n\t\t\t\t\tactivation[id] = true\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// per-point markers use mask buffers to enable markers in vert shader\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet markerMasks = []\r\n\r\n\t\t\t\t\tfor (let i = 0, l = Math.min(markers.length, group.count); i < l; i++) {\r\n\t\t\t\t\t\tlet id = this.addMarker(markers[i])\r\n\r\n\t\t\t\t\t\tif (!markerMasks[id]) markerMasks[id] = new Uint8Array(group.count)\r\n\r\n\t\t\t\t\t\t// enable marker by default\r\n\t\t\t\t\t\tmarkerMasks[id][i] = 1\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (let id = 0; id < markerMasks.length; id++) {\r\n\t\t\t\t\t\tif (!markerMasks[id]) continue\r\n\r\n\t\t\t\t\t\tlet opts = {\r\n\t\t\t\t\t\t\tdata: markerMasks[id],\r\n\t\t\t\t\t\t\ttype: 'uint8',\r\n\t\t\t\t\t\t\tusage: 'static'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!activation[id]) {\r\n\t\t\t\t\t\t\tactivation[id] = regl.buffer(opts)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tactivation[id](opts)\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tactivation[id].data = markerMasks[id]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn markers\r\n\t\t\t},\r\n\r\n\t\t\trange: (range, group, options) => {\r\n\t\t\t\tlet bounds = group.bounds\r\n\r\n\t\t\t\t// FIXME: why do we need this?\r\n\t\t\t\tif (!bounds) return\r\n\t\t\t\tif (!range) range = bounds\r\n\r\n\t\t\t\tgroup.scale = [1 / (range[2] - range[0]), 1 / (range[3] - range[1])]\r\n\t\t\t\tgroup.translate = [-range[0], -range[1]]\r\n\r\n\t\t\t\tgroup.scaleFract = fract32(group.scale)\r\n\t\t\t\tgroup.translateFract = fract32(group.translate)\r\n\r\n\t\t\t\treturn range\r\n\t\t\t},\r\n\r\n\t\t\tviewport: vp => {\r\n\t\t\t\tlet rect = parseRect(vp || [\r\n\t\t\t\t\tgl.drawingBufferWidth,\r\n\t\t\t\t\tgl.drawingBufferHeight\r\n\t\t\t\t])\r\n\r\n\t\t\t\t// normalize viewport to the canvas coordinates\r\n\t\t\t\t// rect.y = gl.drawingBufferHeight - rect.height - rect.y\r\n\r\n\t\t\t\treturn rect\r\n\t\t\t}\r\n\t\t}])\r\n\r\n\t\t// update size buffer, if needed\r\n\t\tif (hasSize) {\r\n\t\t\tlet { count, size, borderSize, sizeBuffer } = group\r\n\r\n\t\t\tlet sizes = new Uint8Array(count*2)\r\n\t\t\tif (size.length || borderSize.length) {\r\n\t\t\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\t\t\t// we downscale size to allow for fractions\r\n\t\t\t\t\tsizes[i*2] = Math.round((size[i] == null ? size : size[i]) * 255 / maxSize)\r\n\t\t\t\t\tsizes[i*2 + 1] = Math.round((borderSize[i] == null ? borderSize : borderSize[i]) * 255 / maxSize)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsizeBuffer({\r\n\t\t\t\tdata: sizes,\r\n\t\t\t\tusage: 'dynamic'\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\t// update color buffer if needed\r\n\t\tif (hasColor) {\r\n\t\t\tlet {count, color, borderColor, colorBuffer } = group\r\n\t\t\tlet colors\r\n\r\n\t\t\t// if too many colors - put colors to buffer directly\r\n\t\t\tif (this.tooManyColors) {\r\n\t\t\t\tif (color.length || borderColor.length) {\r\n\t\t\t\t\tcolors = new Uint8Array(count * 8)\r\n\t\t\t\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\t\t\t\tlet colorId = color[i]\r\n\t\t\t\t\t\tcolors[i*8] = palette[colorId*4]\r\n\t\t\t\t\t\tcolors[i*8 + 1] = palette[colorId*4 + 1]\r\n\t\t\t\t\t\tcolors[i*8 + 2] = palette[colorId*4 + 2]\r\n\t\t\t\t\t\tcolors[i*8 + 3] = palette[colorId*4 + 3]\r\n\r\n\t\t\t\t\t\tlet borderColorId = borderColor[i]\r\n\t\t\t\t\t\tcolors[i*8 + 4] = palette[borderColorId*4]\r\n\t\t\t\t\t\tcolors[i*8 + 5] = palette[borderColorId*4 + 1]\r\n\t\t\t\t\t\tcolors[i*8 + 6] = palette[borderColorId*4 + 2]\r\n\t\t\t\t\t\tcolors[i*8 + 7] = palette[borderColorId*4 + 3]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if limited amount of colors - keep palette color picking\r\n\t\t\t// that saves significant memory\r\n\t\t\telse {\r\n\t\t\t\tif (color.length || borderColor.length) {\r\n\t\t\t\t\t// we need slight data increase by 2 due to vec4 borderId in shader\r\n\t\t\t\t\tcolors = new Uint8Array(count * 4 + 2)\r\n\t\t\t\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\t\t\t\t// put color coords in palette texture\r\n\t\t\t\t\t\tif (color[i] != null) {\r\n\t\t\t\t\t\t\tcolors[i*4] = color[i] % maxColors\r\n\t\t\t\t\t\t\tcolors[i*4 + 1] = Math.floor(color[i] / maxColors)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (borderColor[i] != null) {\r\n\t\t\t\t\t\t\tcolors[i*4 + 2] = borderColor[i] % maxColors\r\n\t\t\t\t\t\t\tcolors[i*4 + 3] = Math.floor(borderColor[i] / maxColors)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcolorBuffer({\r\n\t\t\t\tdata: colors || new Uint8Array(0),\r\n\t\t\t\ttype: 'uint8',\r\n\t\t\t\tusage: 'dynamic'\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\treturn group\r\n\t})\r\n}\r\n\r\n\r\n// get (and create) marker texture id\r\nScatter.prototype.addMarker = function (sdf) {\r\n\tlet { markerTextures, regl, markerCache } = this\r\n\r\n\tlet pos = sdf == null ? 0 : markerCache.indexOf(sdf)\r\n\r\n\tif (pos >= 0) return pos\r\n\r\n\t// convert sdf to 0..255 range\r\n\tlet distArr\r\n\tif (sdf instanceof Uint8Array || sdf instanceof Uint8ClampedArray) {\r\n\t\tdistArr = sdf\r\n\t}\r\n\telse {\r\n\t\tdistArr = new Uint8Array(sdf.length)\r\n\t\tfor (let i = 0, l = sdf.length; i < l; i++) {\r\n\t\t\tdistArr[i] = sdf[i] * 255\r\n\t\t}\r\n\t}\r\n\r\n\tlet radius = Math.floor(Math.sqrt(distArr.length))\r\n\r\n\tpos = markerTextures.length\r\n\r\n\tmarkerCache.push(sdf)\r\n\tmarkerTextures.push(regl.texture({\r\n\t\tchannels: 1,\r\n\t\tdata: distArr,\r\n\t\tradius: radius,\r\n\t\tmag: 'linear',\r\n\t\tmin: 'linear'\r\n\t}))\r\n\r\n\treturn pos\r\n}\r\n\r\n// register color to palette, return it's index or list of indexes\r\nScatter.prototype.updateColor = function (colors) {\r\n\tlet { paletteIds, palette, maxColors } = this\r\n\r\n\tif (!Array.isArray(colors)) {\r\n\t\tcolors = [colors]\r\n\t}\r\n\r\n\tlet idx = []\r\n\r\n\t// if color groups - flatten them\r\n\tif (typeof colors[0] === 'number') {\r\n\t\tlet grouped = []\r\n\r\n\t\tif (Array.isArray(colors)) {\r\n\t\t\tfor (let i = 0; i < colors.length; i+=4) {\r\n\t\t\t\tgrouped.push(colors.slice(i, i+4))\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfor (let i = 0; i < colors.length; i+=4) {\r\n\t\t\t\tgrouped.push(colors.subarray(i, i+4))\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcolors = grouped\r\n\t}\r\n\r\n\tfor (let i = 0; i < colors.length; i++) {\r\n\t\tlet color = colors[i]\r\n\r\n\t\tcolor = rgba(color, 'uint8')\r\n\r\n\t\tlet id = colorId(color, false)\r\n\r\n\t\t// if new color - save it\r\n\t\tif (paletteIds[id] == null) {\r\n\t\t\tlet pos = palette.length\r\n\t\t\tpaletteIds[id] = Math.floor(pos / 4)\r\n\t\t\tpalette[pos] = color[0]\r\n\t\t\tpalette[pos+1] = color[1]\r\n\t\t\tpalette[pos+2] = color[2]\r\n\t\t\tpalette[pos+3] = color[3]\r\n\t\t}\r\n\r\n\t\tidx[i] = paletteIds[id]\r\n\t}\r\n\r\n\t// detect if too many colors in palette\r\n\tif (!this.tooManyColors && palette.length > maxColors * maxColors * 4) this.tooManyColors = true\r\n\r\n\t// limit max color\r\n\tthis.updatePalette(palette)\r\n\r\n\t// keep static index for single-color property\r\n\treturn idx.length === 1 ? idx[0] : idx\r\n}\r\n\r\nScatter.prototype.updatePalette = function (palette) {\r\n\tif (this.tooManyColors) return\r\n\r\n\tlet { maxColors, paletteTexture } = this\r\n\r\n\tlet requiredHeight = Math.ceil(palette.length * .25 / maxColors)\r\n\r\n\t// pad data\r\n\tif (requiredHeight > 1) {\r\n\t\tpalette = palette.slice()\r\n\t\tfor (let i = (palette.length * .25) % maxColors; i < requiredHeight * maxColors; i++) {\r\n\t\t\tpalette.push(0, 0, 0, 0)\r\n\t\t}\r\n\t}\r\n\r\n\t// ensure height\r\n\tif (paletteTexture.height < requiredHeight) {\r\n\t\tpaletteTexture.resize(maxColors, requiredHeight)\r\n\t}\r\n\r\n\t// update full data\r\n\tpaletteTexture.subimage({\r\n\t\twidth: Math.min(palette.length * .25, maxColors),\r\n\t\theight: requiredHeight,\r\n\t\tdata: palette\r\n\t}, 0, 0)\r\n}\r\n\r\n// remove unused stuff\r\nScatter.prototype.destroy = function () {\r\n\tthis.groups.forEach(group => {\r\n\t\tgroup.sizeBuffer.destroy()\r\n\t\tgroup.positionBuffer.destroy()\r\n\t\tgroup.positionFractBuffer.destroy()\r\n\t\tgroup.colorBuffer.destroy()\r\n\t\tgroup.activation.forEach(b => b && b.destroy && b.destroy())\r\n\t\tgroup.selectionBuffer.destroy()\r\n\r\n\t\tif (group.elements) group.elements.destroy()\r\n\t})\r\n\tthis.groups.length = 0\r\n\r\n\tthis.paletteTexture.destroy()\r\n\r\n\tthis.markerTextures.forEach(txt => txt && txt.destroy && txt.destroy())\r\n\r\n\treturn this\r\n}\r\n",null]}