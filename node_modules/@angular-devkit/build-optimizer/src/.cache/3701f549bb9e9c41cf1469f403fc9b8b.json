{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/cone/convert.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/cone/convert.js","mtime":1529418310710},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar createScatterPlot = require('gl-scatter3d');\nvar conePlot = require('gl-cone3d');\nvar createConeMesh = require('gl-cone3d').createConeMesh;\n\nvar simpleMap = require('../../lib').simpleMap;\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\n\nfunction Cone(scene, uid) {\n    this.scene = scene;\n    this.uid = uid;\n    this.mesh = null;\n    this.pts = null;\n    this.data = null;\n}\n\nvar proto = Cone.prototype;\n\nproto.handlePick = function(selection) {\n    if(selection.object === this.pts) {\n        var selectIndex = selection.index = selection.data.index;\n        var xx = this.data.x[selectIndex];\n        var yy = this.data.y[selectIndex];\n        var zz = this.data.z[selectIndex];\n        var uu = this.data.u[selectIndex];\n        var vv = this.data.v[selectIndex];\n        var ww = this.data.w[selectIndex];\n\n        selection.traceCoordinate = [\n            xx, yy, zz,\n            uu, vv, ww,\n            Math.sqrt(uu * uu + vv * vv + ww * ww)\n        ];\n\n        var text = this.data.text;\n        if(Array.isArray(text) && text[selectIndex] !== undefined) {\n            selection.textLabel = text[selectIndex];\n        } else if(text) {\n            selection.textLabel = text;\n        }\n\n        return true;\n    }\n};\n\nfunction zip3(x, y, z) {\n    var result = new Array(x.length);\n    for(var i = 0; i < x.length; i++) {\n        result[i] = [x[i], y[i], z[i]];\n    }\n    return result;\n}\n\nvar axisName2scaleIndex = {xaxis: 0, yaxis: 1, zaxis: 2};\nvar sizeMode2sizeKey = {scaled: 'coneSize', absolute: 'absoluteConeSize'};\nvar anchor2coneOffset = {tip: 1, tail: 0, cm: 0.25, center: 0.5};\nvar anchor2coneSpan = {tip: 1, tail: 1, cm: 0.75, center: 0.5};\n\nfunction convert(scene, trace) {\n    var sceneLayout = scene.fullSceneLayout;\n    var dataScale = scene.dataScale;\n    var coneOpts = {};\n\n    function toDataCoords(arr, axisName) {\n        var ax = sceneLayout[axisName];\n        var scale = dataScale[axisName2scaleIndex[axisName]];\n        return simpleMap(arr, function(v) { return ax.d2l(v) * scale; });\n    }\n\n    coneOpts.vectors = zip3(\n        toDataCoords(trace.u, 'xaxis'),\n        toDataCoords(trace.v, 'yaxis'),\n        toDataCoords(trace.w, 'zaxis')\n    );\n\n    coneOpts.positions = zip3(\n        toDataCoords(trace.x, 'xaxis'),\n        toDataCoords(trace.y, 'yaxis'),\n        toDataCoords(trace.z, 'zaxis')\n    );\n\n    coneOpts.colormap = parseColorScale(trace.colorscale);\n    coneOpts.vertexIntensityBounds = [trace.cmin / trace._normMax, trace.cmax / trace._normMax];\n\n    coneOpts[sizeMode2sizeKey[trace.sizemode]] = trace.sizeref;\n    coneOpts.coneOffset = anchor2coneOffset[trace.anchor];\n\n    var meshData = conePlot(coneOpts);\n\n    // stash positions for gl-scatter3d 'hover' trace\n    meshData._pts = coneOpts.positions;\n\n    // pass gl-mesh3d lighting attributes\n    meshData.lightPosition = [trace.lightposition.x, trace.lightposition.y, trace.lightposition.z];\n    meshData.ambient = trace.lighting.ambient;\n    meshData.diffuse = trace.lighting.diffuse;\n    meshData.specular = trace.lighting.specular;\n    meshData.roughness = trace.lighting.roughness;\n    meshData.fresnel = trace.lighting.fresnel;\n    meshData.opacity = trace.opacity;\n\n    // stash autorange pad value\n    trace._pad = anchor2coneSpan[trace.anchor] * meshData.vectorScale * trace.sizeref;\n    if(trace.sizemode === 'scaled') trace._pad *= trace._normMax;\n\n    return meshData;\n}\n\nproto.update = function(data) {\n    this.data = data;\n\n    var meshData = convert(this.scene, data);\n\n    this.mesh.update(meshData);\n    this.pts.update({position: meshData._pts});\n};\n\nproto.dispose = function() {\n    this.scene.glplot.remove(this.pts);\n    this.pts.dispose();\n    this.scene.glplot.remove(this.mesh);\n    this.mesh.dispose();\n};\n\nfunction createConeTrace(scene, data) {\n    var gl = scene.glplot.gl;\n\n    var meshData = convert(scene, data);\n    var mesh = createConeMesh(gl, meshData);\n\n    var pts = createScatterPlot({\n        gl: gl,\n        position: meshData._pts,\n        project: false,\n        opacity: 0\n    });\n\n    var cone = new Cone(scene, data.uid);\n    cone.mesh = mesh;\n    cone.pts = pts;\n    cone.data = data;\n    mesh._trace = cone;\n    pts._trace = cone;\n\n    scene.glplot.add(pts);\n    scene.glplot.add(mesh);\n\n    return cone;\n}\n\nmodule.exports = createConeTrace;\n",null]}