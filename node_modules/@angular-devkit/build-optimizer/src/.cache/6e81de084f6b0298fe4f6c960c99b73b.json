{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/gl3d/camera.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/gl3d/camera.js","mtime":1529418310690},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = createCamera;\n\nvar now = require('right-now');\nvar createView = require('3d-view');\nvar mouseChange = require('mouse-change');\nvar mouseWheel = require('mouse-wheel');\nvar mouseOffset = require('mouse-event-offset');\nvar supportsPassive = require('has-passive-events');\n\nfunction createCamera(element, options) {\n    element = element || document.body;\n    options = options || {};\n\n    var limits = [ 0.01, Infinity ];\n    if('distanceLimits' in options) {\n        limits[0] = options.distanceLimits[0];\n        limits[1] = options.distanceLimits[1];\n    }\n    if('zoomMin' in options) {\n        limits[0] = options.zoomMin;\n    }\n    if('zoomMax' in options) {\n        limits[1] = options.zoomMax;\n    }\n\n    var view = createView({\n        center: options.center || [0, 0, 0],\n        up: options.up || [0, 1, 0],\n        eye: options.eye || [0, 0, 10],\n        mode: options.mode || 'orbit',\n        distanceLimits: limits\n    });\n\n    var pmatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var distance = 0.0;\n    var width = element.clientWidth;\n    var height = element.clientHeight;\n\n    var camera = {\n        keyBindingMode: 'rotate',\n        view: view,\n        element: element,\n        delay: options.delay || 16,\n        rotateSpeed: options.rotateSpeed || 1,\n        zoomSpeed: options.zoomSpeed || 1,\n        translateSpeed: options.translateSpeed || 1,\n        flipX: !!options.flipX,\n        flipY: !!options.flipY,\n        modes: view.modes,\n        tick: function() {\n            var t = now();\n            var delay = this.delay;\n            var ctime = t - 2 * delay;\n            view.idle(t - delay);\n            view.recalcMatrix(ctime);\n            view.flush(t - (100 + delay * 2));\n            var allEqual = true;\n            var matrix = view.computedMatrix;\n            for(var i = 0; i < 16; ++i) {\n                allEqual = allEqual && (pmatrix[i] === matrix[i]);\n                pmatrix[i] = matrix[i];\n            }\n            var sizeChanged =\n                element.clientWidth === width &&\n                element.clientHeight === height;\n            width = element.clientWidth;\n            height = element.clientHeight;\n            if(allEqual) return !sizeChanged;\n            distance = Math.exp(view.computedRadius[0]);\n            return true;\n        },\n        lookAt: function(center, eye, up) {\n            view.lookAt(view.lastT(), center, eye, up);\n        },\n        rotate: function(pitch, yaw, roll) {\n            view.rotate(view.lastT(), pitch, yaw, roll);\n        },\n        pan: function(dx, dy, dz) {\n            view.pan(view.lastT(), dx, dy, dz);\n        },\n        translate: function(dx, dy, dz) {\n            view.translate(view.lastT(), dx, dy, dz);\n        }\n    };\n\n    Object.defineProperties(camera, {\n        matrix: {\n            get: function() {\n                return view.computedMatrix;\n            },\n            set: function(mat) {\n                view.setMatrix(view.lastT(), mat);\n                return view.computedMatrix;\n            },\n            enumerable: true\n        },\n        mode: {\n            get: function() {\n                return view.getMode();\n            },\n            set: function(mode) {\n                var curUp = view.computedUp.slice();\n                var curEye = view.computedEye.slice();\n                var curCenter = view.computedCenter.slice();\n                view.setMode(mode);\n                if(mode === 'turntable') {\n                    // Hacky time warping stuff to generate smooth animation\n                    var t0 = now();\n                    view._active.lookAt(t0, curEye, curCenter, curUp);\n                    view._active.lookAt(t0 + 500, curEye, curCenter, [0, 0, 1]);\n                    view._active.flush(t0);\n                }\n                return view.getMode();\n            },\n            enumerable: true\n        },\n        center: {\n            get: function() {\n                return view.computedCenter;\n            },\n            set: function(ncenter) {\n                view.lookAt(view.lastT(), null, ncenter);\n                return view.computedCenter;\n            },\n            enumerable: true\n        },\n        eye: {\n            get: function() {\n                return view.computedEye;\n            },\n            set: function(neye) {\n                view.lookAt(view.lastT(), neye);\n                return view.computedEye;\n            },\n            enumerable: true\n        },\n        up: {\n            get: function() {\n                return view.computedUp;\n            },\n            set: function(nup) {\n                view.lookAt(view.lastT(), null, null, nup);\n                return view.computedUp;\n            },\n            enumerable: true\n        },\n        distance: {\n            get: function() {\n                return distance;\n            },\n            set: function(d) {\n                view.setDistance(view.lastT(), d);\n                return d;\n            },\n            enumerable: true\n        },\n        distanceLimits: {\n            get: function() {\n                return view.getDistanceLimits(limits);\n            },\n            set: function(v) {\n                view.setDistanceLimits(v);\n                return v;\n            },\n            enumerable: true\n        }\n    });\n\n    element.addEventListener('contextmenu', function(ev) {\n        ev.preventDefault();\n        return false;\n    });\n\n    var lastX = 0, lastY = 0, lastMods = {shift: false, control: false, alt: false, meta: false};\n    camera.mouseListener = mouseChange(element, handleInteraction);\n\n    // enable simple touch interactions\n    element.addEventListener('touchstart', function(ev) {\n        var xy = mouseOffset(ev.changedTouches[0], element);\n        handleInteraction(0, xy[0], xy[1], lastMods);\n        handleInteraction(1, xy[0], xy[1], lastMods);\n\n        ev.preventDefault();\n    }, supportsPassive ? {passive: false} : false);\n    element.addEventListener('touchmove', function(ev) {\n        var xy = mouseOffset(ev.changedTouches[0], element);\n        handleInteraction(1, xy[0], xy[1], lastMods);\n\n        ev.preventDefault();\n    }, supportsPassive ? {passive: false} : false);\n    element.addEventListener('touchend', function(ev) {\n        handleInteraction(0, lastX, lastY, lastMods);\n\n        ev.preventDefault();\n    }, supportsPassive ? {passive: false} : false);\n\n    function handleInteraction(buttons, x, y, mods) {\n        var keyBindingMode = camera.keyBindingMode;\n\n        if(keyBindingMode === false) return;\n\n        var rotate = keyBindingMode === 'rotate';\n        var pan = keyBindingMode === 'pan';\n        var zoom = keyBindingMode === 'zoom';\n\n        var ctrl = !!mods.control;\n        var alt = !!mods.alt;\n        var shift = !!mods.shift;\n        var left = !!(buttons & 1);\n        var right = !!(buttons & 2);\n        var middle = !!(buttons & 4);\n\n        var scale = 1.0 / element.clientHeight;\n        var dx = scale * (x - lastX);\n        var dy = scale * (y - lastY);\n\n        var flipX = camera.flipX ? 1 : -1;\n        var flipY = camera.flipY ? 1 : -1;\n\n        var t = now();\n\n        var drot = Math.PI * camera.rotateSpeed;\n\n        if((rotate && left && !ctrl && !alt && !shift) || (left && !ctrl && !alt && shift)) {\n            // Rotate\n            view.rotate(t, flipX * drot * dx, -flipY * drot * dy, 0);\n        }\n\n        if((pan && left && !ctrl && !alt && !shift) || right || (left && ctrl && !alt && !shift)) {\n            // Pan\n            view.pan(t, -camera.translateSpeed * dx * distance, camera.translateSpeed * dy * distance, 0);\n        }\n\n        if((zoom && left && !ctrl && !alt && !shift) || middle || (left && !ctrl && alt && !shift)) {\n            // Zoom\n            var kzoom = -camera.zoomSpeed * dy / window.innerHeight * (t - view.lastT()) * 100;\n            view.pan(t, 0, 0, distance * (Math.exp(kzoom) - 1));\n        }\n\n        lastX = x;\n        lastY = y;\n        lastMods = mods;\n\n        return true;\n    }\n\n    camera.wheelListener = mouseWheel(element, function(dx, dy) {\n        if(camera.keyBindingMode === false) return;\n\n        var flipX = camera.flipX ? 1 : -1;\n        var flipY = camera.flipY ? 1 : -1;\n        var t = now();\n        if(Math.abs(dx) > Math.abs(dy)) {\n            view.rotate(t, 0, 0, -dx * flipX * Math.PI * camera.rotateSpeed / window.innerWidth);\n        } else {\n            var kzoom = -camera.zoomSpeed * flipY * dy / window.innerHeight * (t - view.lastT()) / 20.0;\n            view.pan(t, 0, 0, distance * (Math.exp(kzoom) - 1));\n        }\n    }, true);\n\n    return camera;\n}\n",null]}