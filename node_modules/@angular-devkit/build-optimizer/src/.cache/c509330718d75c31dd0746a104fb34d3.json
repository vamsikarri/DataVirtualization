{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-axes3d/lib/cube.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-axes3d/lib/cube.js","mtime":1529418308593},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["\"use strict\"\r\n\r\nmodule.exports = getCubeEdges\r\n\r\nvar bits      = require('bit-twiddle')\r\nvar multiply  = require('gl-mat4/multiply')\r\nvar invert    = require('gl-mat4/invert')\r\nvar splitPoly = require('split-polygon')\r\nvar orient    = require('robust-orientation')\r\n\r\nvar mvp        = new Array(16)\r\nvar imvp       = new Array(16)\r\nvar pCubeVerts = new Array(8)\r\nvar cubeVerts  = new Array(8)\r\nvar x          = new Array(3)\r\nvar zero3      = [0,0,0]\r\n\r\n;(function() {\r\n  for(var i=0; i<8; ++i) {\r\n    pCubeVerts[i] =[1,1,1,1]\r\n    cubeVerts[i] = [1,1,1]\r\n  }\r\n})()\r\n\r\n\r\nfunction transformHg(result, x, mat) {\r\n  for(var i=0; i<4; ++i) {\r\n    result[i] = mat[12+i]\r\n    for(var j=0; j<3; ++j) {\r\n      result[i] += x[j]*mat[4*j+i]\r\n    }\r\n  }\r\n}\r\n\r\nvar FRUSTUM_PLANES = [\r\n  [ 0, 0, 1, 0, 0],\r\n  [ 0, 0,-1, 1, 0],\r\n  [ 0,-1, 0, 1, 0],\r\n  [ 0, 1, 0, 1, 0],\r\n  [-1, 0, 0, 1, 0],\r\n  [ 1, 0, 0, 1, 0]\r\n]\r\n\r\nfunction polygonArea(p) {\r\n  for(var i=0; i<FRUSTUM_PLANES.length; ++i) {\r\n    p = splitPoly.positive(p, FRUSTUM_PLANES[i])\r\n    if(p.length < 3) {\r\n      return 0\r\n    }\r\n  }\r\n\r\n  var base = p[0]\r\n  var ax = base[0] / base[3]\r\n  var ay = base[1] / base[3]\r\n  var area = 0.0\r\n  for(var i=1; i+1<p.length; ++i) {\r\n    var b = p[i]\r\n    var c = p[i+1]\r\n\r\n    var bx = b[0]/b[3]\r\n    var by = b[1]/b[3]\r\n    var cx = c[0]/c[3]\r\n    var cy = c[1]/c[3]\r\n\r\n    var ux = bx - ax\r\n    var uy = by - ay\r\n\r\n    var vx = cx - ax\r\n    var vy = cy - ay\r\n\r\n    area += Math.abs(ux * vy - uy * vx)\r\n  }\r\n\r\n  return area\r\n}\r\n\r\nvar CUBE_EDGES = [1,1,1]\r\nvar CUBE_AXIS  = [0,0,0]\r\nvar CUBE_RESULT = {\r\n  cubeEdges: CUBE_EDGES,\r\n  axis: CUBE_AXIS\r\n}\r\n\r\nfunction getCubeEdges(model, view, projection, bounds) {\r\n\r\n  //Concatenate matrices\r\n  multiply(mvp, view, model)\r\n  multiply(mvp, projection, mvp)\r\n  \r\n  //First project cube vertices\r\n  var ptr = 0\r\n  for(var i=0; i<2; ++i) {\r\n    x[2] = bounds[i][2]\r\n    for(var j=0; j<2; ++j) {\r\n      x[1] = bounds[j][1]\r\n      for(var k=0; k<2; ++k) {\r\n        x[0] = bounds[k][0]\r\n        transformHg(pCubeVerts[ptr], x, mvp)\r\n        ptr += 1\r\n      }\r\n    }\r\n  }\r\n\r\n  //Classify camera against cube faces\r\n  var closest = -1\r\n\r\n  for(var i=0; i<8; ++i) {\r\n    var w = pCubeVerts[i][3]\r\n    for(var l=0; l<3; ++l) {\r\n      cubeVerts[i][l] = pCubeVerts[i][l] / w\r\n    }\r\n    if(w < 0) {\r\n      if(closest < 0) {\r\n        closest = i\r\n      } else if(cubeVerts[i][2] < cubeVerts[closest][2]) {\r\n        closest = i\r\n      }\r\n    }    \r\n  }\r\n\r\n  if(closest < 0) {\r\n    closest = 0\r\n    for(var d=0; d<3; ++d) {\r\n      var u = (d+2) % 3\r\n      var v = (d+1) % 3\r\n      var o0 = -1\r\n      var o1 = -1\r\n      for(var s=0; s<2; ++s) {\r\n        var f0 = (s<<d)\r\n        var f1 = f0 + (s << u) + ((1-s) << v)\r\n        var f2 = f0 + ((1-s) << u) + (s << v)\r\n        if(orient(cubeVerts[f0], cubeVerts[f1], cubeVerts[f2], zero3) < 0) {\r\n          continue\r\n        }\r\n        if(s) {\r\n          o0 = 1\r\n        } else {\r\n          o1 = 1\r\n        }\r\n      }\r\n      if(o0 < 0 || o1 < 0) {\r\n        if(o1 > o0) {\r\n          closest |= 1<<d\r\n        }\r\n        continue\r\n      } \r\n      for(var s=0; s<2; ++s) {\r\n        var f0 = (s<<d)\r\n        var f1 = f0 + (s << u) + ((1-s) << v)\r\n        var f2 = f0 + ((1-s) << u) + (s << v)    \r\n        var o = polygonArea([\r\n            pCubeVerts[f0], \r\n            pCubeVerts[f1], \r\n            pCubeVerts[f2], \r\n            pCubeVerts[f0+(1<<u)+(1<<v)]])\r\n        if(s) {\r\n          o0 = o\r\n        } else {\r\n          o1 = o\r\n        }\r\n      }\r\n      if(o1 > o0) {\r\n        closest |= 1<<d\r\n        continue\r\n      }\r\n    }\r\n  }\r\n\r\n  var farthest = 7^closest\r\n\r\n  //Find lowest vertex which is not closest closest\r\n  var bottom = -1\r\n  for(var i=0; i<8; ++i) {\r\n    if(i === closest || i === farthest) {\r\n      continue\r\n    }\r\n    if(bottom < 0) {\r\n      bottom = i\r\n    } else if(cubeVerts[bottom][1] > cubeVerts[i][1]) {\r\n      bottom = i\r\n    }\r\n  }\r\n\r\n  //Find left/right neighbors of bottom vertex\r\n  var left = -1\r\n  for(var i=0; i<3; ++i) {\r\n    var idx = bottom ^ (1<<i)\r\n    if(idx === closest || idx === farthest) {\r\n      continue\r\n    }\r\n    if(left < 0) {\r\n      left = idx\r\n    }\r\n    var v = cubeVerts[idx]\r\n    if(v[0] < cubeVerts[left][0]) {\r\n      left = idx\r\n    }\r\n  }\r\n  var right = -1\r\n  for(var i=0; i<3; ++i) {\r\n    var idx = bottom ^ (1<<i)\r\n    if(idx === closest || idx === farthest || idx === left) {\r\n      continue\r\n    }\r\n    if(right < 0) {\r\n      right = idx\r\n    }\r\n    var v = cubeVerts[idx]\r\n    if(v[0] > cubeVerts[right][0]) {\r\n      right = idx\r\n    }\r\n  }\r\n\r\n  //Determine edge axis coordinates\r\n  var cubeEdges = CUBE_EDGES\r\n  cubeEdges[0] = cubeEdges[1] = cubeEdges[2] = 0\r\n  cubeEdges[bits.log2(left^bottom)] = bottom&left\r\n  cubeEdges[bits.log2(bottom^right)] = bottom&right\r\n  var top = right ^ 7\r\n  if(top === closest || top === farthest) {\r\n    top = left ^ 7\r\n    cubeEdges[bits.log2(right^top)] = top&right\r\n  } else {\r\n    cubeEdges[bits.log2(left^top)] = top&left\r\n  }\r\n\r\n  //Determine visible faces\r\n  var axis = CUBE_AXIS\r\n  var cutCorner = closest\r\n  for(var d=0; d<3; ++d) {\r\n    if(cutCorner & (1<<d)) {\r\n      axis[d] = -1\r\n    } else {\r\n      axis[d] = 1\r\n    }\r\n  }\r\n\r\n  //Return result\r\n  return CUBE_RESULT\r\n}",null]}