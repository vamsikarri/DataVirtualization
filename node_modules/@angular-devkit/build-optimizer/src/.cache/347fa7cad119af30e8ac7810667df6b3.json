{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scattergeo/plot.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scattergeo/plot.js","mtime":1529418310740},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\nvar locationToFeature = require('../../lib/geo_location_utils').locationToFeature;\nvar geoJsonUtils = require('../../lib/geojson_utils');\nvar subTypes = require('../scatter/subtypes');\nvar style = require('./style');\n\nmodule.exports = function plot(gd, geo, calcData) {\n    for(var i = 0; i < calcData.length; i++) {\n        calcGeoJSON(calcData[i], geo.topojson);\n    }\n\n    function keyFunc(d) { return d[0].trace.uid; }\n\n    function removeBADNUM(d, node) {\n        if(d.lonlat[0] === BADNUM) {\n            d3.select(node).remove();\n        }\n    }\n\n    var gTraces = geo.layers.frontplot.select('.scatterlayer')\n        .selectAll('g.trace.scattergeo')\n        .data(calcData, keyFunc);\n\n    gTraces.enter().append('g')\n        .attr('class', 'trace scattergeo');\n\n    gTraces.exit().remove();\n\n    // TODO find a way to order the inner nodes on update\n    gTraces.selectAll('*').remove();\n\n    gTraces.each(function(calcTrace) {\n        var s = calcTrace[0].node3 = d3.select(this);\n        var trace = calcTrace[0].trace;\n\n        if(subTypes.hasLines(trace) || trace.fill !== 'none') {\n            var lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n\n            var lineData = (trace.fill !== 'none') ?\n                geoJsonUtils.makePolygon(lineCoords) :\n                geoJsonUtils.makeLine(lineCoords);\n\n            s.selectAll('path.js-line')\n                .data([{geojson: lineData, trace: trace}])\n              .enter().append('path')\n                .classed('js-line', true)\n                .style('stroke-miterlimit', 2);\n        }\n\n        if(subTypes.hasMarkers(trace)) {\n            s.selectAll('path.point')\n                .data(Lib.identity)\n             .enter().append('path')\n                .classed('point', true)\n                .each(function(calcPt) { removeBADNUM(calcPt, this); });\n        }\n\n        if(subTypes.hasText(trace)) {\n            s.selectAll('g')\n                .data(Lib.identity)\n              .enter().append('g')\n                .append('text')\n                .each(function(calcPt) { removeBADNUM(calcPt, this); });\n        }\n\n        // call style here within topojson request callback\n        style(gd, calcTrace);\n    });\n};\n\nfunction calcGeoJSON(calcTrace, topojson) {\n    var trace = calcTrace[0].trace;\n\n    if(!Array.isArray(trace.locations)) return;\n\n    var features = getTopojsonFeatures(trace, topojson);\n    var locationmode = trace.locationmode;\n\n    for(var i = 0; i < calcTrace.length; i++) {\n        var calcPt = calcTrace[i];\n        var feature = locationToFeature(locationmode, calcPt.loc, features);\n\n        calcPt.lonlat = feature ? feature.properties.ct : [BADNUM, BADNUM];\n    }\n}\n",null]}