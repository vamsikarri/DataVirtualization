{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/contour/close_boundaries.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/contour/close_boundaries.js","mtime":1529418310711},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = function(pathinfo, operation, perimeter, trace) {\n    // Abandon all hope, ye who enter here.\n    var i, v1, v2;\n    var pi0 = pathinfo[0];\n    var na = pi0.x.length;\n    var nb = pi0.y.length;\n    var z = pi0.z;\n    var contours = trace.contours;\n\n    var boundaryMax = -Infinity;\n    var boundaryMin = Infinity;\n\n    for(i = 0; i < nb; i++) {\n        boundaryMin = Math.min(boundaryMin, z[i][0]);\n        boundaryMin = Math.min(boundaryMin, z[i][na - 1]);\n        boundaryMax = Math.max(boundaryMax, z[i][0]);\n        boundaryMax = Math.max(boundaryMax, z[i][na - 1]);\n    }\n\n    for(i = 1; i < na - 1; i++) {\n        boundaryMin = Math.min(boundaryMin, z[0][i]);\n        boundaryMin = Math.min(boundaryMin, z[nb - 1][i]);\n        boundaryMax = Math.max(boundaryMax, z[0][i]);\n        boundaryMax = Math.max(boundaryMax, z[nb - 1][i]);\n    }\n\n    pi0.prefixBoundary = false;\n\n    switch(operation) {\n        case '>':\n            if(contours.value > boundaryMax) {\n                pi0.prefixBoundary = true;\n            }\n            break;\n        case '<':\n            if(contours.value < boundaryMin) {\n                pi0.prefixBoundary = true;\n            }\n            break;\n        case '[]':\n            v1 = Math.min.apply(null, contours.value);\n            v2 = Math.max.apply(null, contours.value);\n            if(v2 < boundaryMin || v1 > boundaryMax) {\n                pi0.prefixBoundary = true;\n            }\n            break;\n        case '][':\n            v1 = Math.min.apply(null, contours.value);\n            v2 = Math.max.apply(null, contours.value);\n            if(v1 < boundaryMin && v2 > boundaryMax) {\n                pi0.prefixBoundary = true;\n            }\n            break;\n    }\n};\n",null]}