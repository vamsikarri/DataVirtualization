{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/lib/coerce.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/lib/coerce.js","mtime":1529418310671},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar baseTraceAttrs = require('../plots/attributes');\nvar getColorscale = require('../components/colorscale/get_scale');\nvar colorscaleNames = Object.keys(require('../components/colorscale/scales'));\nvar nestedProperty = require('./nested_property');\nvar counterRegex = require('./regex').counter;\nvar DESELECTDIM = require('../constants/interactions').DESELECTDIM;\nvar wrap180 = require('./angles').wrap180;\nvar isArrayOrTypedArray = require('./is_array').isArrayOrTypedArray;\n\nexports.valObjectMeta = {\n    data_array: {\n        // You can use *dflt=[] to force said array to exist though.\n        description: [\n            'An {array} of data.',\n            'The value MUST be an {array}, or we ignore it.',\n            'Note that typed arrays (e.g. Float32Array) are supported.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt'],\n        coerceFunction: function(v, propOut, dflt) {\n            // TODO maybe `v: {type: 'float32', vals: [/* ... */]}` also\n            if(isArrayOrTypedArray(v)) propOut.set(v);\n            else if(dflt !== undefined) propOut.set(dflt);\n        }\n    },\n    enumerated: {\n        description: [\n            'Enumerated value type. The available values are listed',\n            'in `values`.'\n        ].join(' '),\n        requiredOpts: ['values'],\n        otherOpts: ['dflt', 'coerceNumber', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(opts.coerceNumber) v = +v;\n            if(opts.values.indexOf(v) === -1) propOut.set(dflt);\n            else propOut.set(v);\n        },\n        validateFunction: function(v, opts) {\n            if(opts.coerceNumber) v = +v;\n\n            var values = opts.values;\n            for(var i = 0; i < values.length; i++) {\n                var k = String(values[i]);\n\n                if((k.charAt(0) === '/' && k.charAt(k.length - 1) === '/')) {\n                    var regex = new RegExp(k.substr(1, k.length - 2));\n                    if(regex.test(v)) return true;\n                } else if(v === values[i]) return true;\n            }\n            return false;\n        }\n    },\n    'boolean': {\n        description: 'A boolean (true/false) value.',\n        requiredOpts: [],\n        otherOpts: ['dflt'],\n        coerceFunction: function(v, propOut, dflt) {\n            if(v === true || v === false) propOut.set(v);\n            else propOut.set(dflt);\n        }\n    },\n    number: {\n        description: [\n            'A number or a numeric value',\n            '(e.g. a number inside a string).',\n            'When applicable, values greater (less) than `max` (`min`)',\n            'are coerced to the `dflt`.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt', 'min', 'max', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(!isNumeric(v) ||\n                    (opts.min !== undefined && v < opts.min) ||\n                    (opts.max !== undefined && v > opts.max)) {\n                propOut.set(dflt);\n            }\n            else propOut.set(+v);\n        }\n    },\n    integer: {\n        description: [\n            'An integer or an integer inside a string.',\n            'When applicable, values greater (less) than `max` (`min`)',\n            'are coerced to the `dflt`.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt', 'min', 'max', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(v % 1 || !isNumeric(v) ||\n                    (opts.min !== undefined && v < opts.min) ||\n                    (opts.max !== undefined && v > opts.max)) {\n                propOut.set(dflt);\n            }\n            else propOut.set(+v);\n        }\n    },\n    string: {\n        description: [\n            'A string value.',\n            'Numbers are converted to strings except for attributes with',\n            '`strict` set to true.'\n        ].join(' '),\n        requiredOpts: [],\n        // TODO 'values shouldn't be in there (edge case: 'dash' in Scatter)\n        otherOpts: ['dflt', 'noBlank', 'strict', 'arrayOk', 'values'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(typeof v !== 'string') {\n                var okToCoerce = (typeof v === 'number');\n\n                if(opts.strict === true || !okToCoerce) propOut.set(dflt);\n                else propOut.set(String(v));\n            }\n            else if(opts.noBlank && !v) propOut.set(dflt);\n            else propOut.set(v);\n        }\n    },\n    color: {\n        description: [\n            'A string describing color.',\n            'Supported formats:',\n            '- hex (e.g. \\'#d3d3d3\\')',\n            '- rgb (e.g. \\'rgb(255, 0, 0)\\')',\n            '- rgba (e.g. \\'rgb(255, 0, 0, 0.5)\\')',\n            '- hsl (e.g. \\'hsl(0, 100%, 50%)\\')',\n            '- hsv (e.g. \\'hsv(0, 100%, 100%)\\')',\n            '- named colors (full list: http://www.w3.org/TR/css3-color/#svg-color)'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt) {\n            if(tinycolor(v).isValid()) propOut.set(v);\n            else propOut.set(dflt);\n        }\n    },\n    colorlist: {\n        description: [\n            'A list of colors.',\n            'Must be an {array} containing valid colors.',\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt'],\n        coerceFunction: function(v, propOut, dflt) {\n            function isColor(color) {\n                return tinycolor(color).isValid();\n            }\n            if(!Array.isArray(v) || !v.length) propOut.set(dflt);\n            else if(v.every(isColor)) propOut.set(v);\n            else propOut.set(dflt);\n        }\n    },\n    colorscale: {\n        description: [\n            'A Plotly colorscale either picked by a name:',\n            '(any of', colorscaleNames.join(', '), ')',\n            'customized as an {array} of 2-element {arrays} where',\n            'the first element is the normalized color level value',\n            '(starting at *0* and ending at *1*),',\n            'and the second item is a valid color string.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt'],\n        coerceFunction: function(v, propOut, dflt) {\n            propOut.set(getColorscale(v, dflt));\n        }\n    },\n    angle: {\n        description: [\n            'A number (in degree) between -180 and 180.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt'],\n        coerceFunction: function(v, propOut, dflt) {\n            if(v === 'auto') propOut.set('auto');\n            else if(!isNumeric(v)) propOut.set(dflt);\n            else propOut.set(wrap180(+v));\n        }\n    },\n    subplotid: {\n        description: [\n            'An id string of a subplot type (given by dflt), optionally',\n            'followed by an integer >1. e.g. if dflt=\\'geo\\', we can have',\n            '\\'geo\\', \\'geo2\\', \\'geo3\\', ...'\n        ].join(' '),\n        requiredOpts: ['dflt'],\n        otherOpts: ['regex'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            var regex = opts.regex || counterRegex(dflt);\n            if(typeof v === 'string' && regex.test(v)) {\n                propOut.set(v);\n                return;\n            }\n            propOut.set(dflt);\n        },\n        validateFunction: function(v, opts) {\n            var dflt = opts.dflt;\n\n            if(v === dflt) return true;\n            if(typeof v !== 'string') return false;\n            if(counterRegex(dflt).test(v)) return true;\n\n            return false;\n        }\n    },\n    flaglist: {\n        description: [\n            'A string representing a combination of flags',\n            '(order does not matter here).',\n            'Combine any of the available `flags` with *+*.',\n            '(e.g. (\\'lines+markers\\')).',\n            'Values in `extras` cannot be combined.'\n        ].join(' '),\n        requiredOpts: ['flags'],\n        otherOpts: ['dflt', 'extras', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(typeof v !== 'string') {\n                propOut.set(dflt);\n                return;\n            }\n            if((opts.extras || []).indexOf(v) !== -1) {\n                propOut.set(v);\n                return;\n            }\n            var vParts = v.split('+'),\n                i = 0;\n            while(i < vParts.length) {\n                var vi = vParts[i];\n                if(opts.flags.indexOf(vi) === -1 || vParts.indexOf(vi) < i) {\n                    vParts.splice(i, 1);\n                }\n                else i++;\n            }\n            if(!vParts.length) propOut.set(dflt);\n            else propOut.set(vParts.join('+'));\n        }\n    },\n    any: {\n        description: 'Any type.',\n        requiredOpts: [],\n        otherOpts: ['dflt', 'values', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt) {\n            if(v === undefined) propOut.set(dflt);\n            else propOut.set(v);\n        }\n    },\n    info_array: {\n        description: [\n            'An {array} of plot information.'\n        ].join(' '),\n        requiredOpts: ['items'],\n        // set `dimensions=2` for a 2D array or '1-2' for either\n        // `items` may be a single object instead of an array, in which case\n        // `freeLength` must be true.\n        // if `dimensions='1-2'` and items is a 1D array, then the value can\n        // either be a matching 1D array or an array of such matching 1D arrays\n        otherOpts: ['dflt', 'freeLength', 'dimensions'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n\n            // simplified coerce function just for array items\n            function coercePart(v, opts, dflt) {\n                var out;\n                var propPart = {set: function(v) { out = v; }};\n\n                if(dflt === undefined) dflt = opts.dflt;\n\n                exports.valObjectMeta[opts.valType].coerceFunction(v, propPart, dflt, opts);\n\n                return out;\n            }\n\n            var twoD = opts.dimensions === 2 || (opts.dimensions === '1-2' && Array.isArray(v) && Array.isArray(v[0]));\n\n            if(!Array.isArray(v)) {\n                propOut.set(dflt);\n                return;\n            }\n\n            var items = opts.items;\n            var vOut = [];\n            var arrayItems = Array.isArray(items);\n            var arrayItems2D = arrayItems && twoD && Array.isArray(items[0]);\n            var innerItemsOnly = twoD && arrayItems && !arrayItems2D;\n            var len = (arrayItems && !innerItemsOnly) ? items.length : v.length;\n\n            var i, j, row, item, len2, vNew;\n\n            dflt = Array.isArray(dflt) ? dflt : [];\n\n            if(twoD) {\n                for(i = 0; i < len; i++) {\n                    vOut[i] = [];\n                    row = Array.isArray(v[i]) ? v[i] : [];\n                    if(innerItemsOnly) len2 = items.length;\n                    else if(arrayItems) len2 = items[i].length;\n                    else len2 = row.length;\n\n                    for(j = 0; j < len2; j++) {\n                        if(innerItemsOnly) item = items[j];\n                        else if(arrayItems) item = items[i][j];\n                        else item = items;\n\n                        vNew = coercePart(row[j], item, (dflt[i] || [])[j]);\n                        if(vNew !== undefined) vOut[i][j] = vNew;\n                    }\n                }\n            }\n            else {\n                for(i = 0; i < len; i++) {\n                    vNew = coercePart(v[i], arrayItems ? items[i] : items, dflt[i]);\n                    if(vNew !== undefined) vOut[i] = vNew;\n                }\n            }\n\n            propOut.set(vOut);\n        },\n        validateFunction: function(v, opts) {\n            if(!Array.isArray(v)) return false;\n\n            var items = opts.items;\n            var arrayItems = Array.isArray(items);\n            var twoD = opts.dimensions === 2;\n\n            // when free length is off, input and declared lengths must match\n            if(!opts.freeLength && v.length !== items.length) return false;\n\n            // valid when all input items are valid\n            for(var i = 0; i < v.length; i++) {\n                if(twoD) {\n                    if(!Array.isArray(v[i]) || (!opts.freeLength && v[i].length !== items[i].length)) {\n                        return false;\n                    }\n                    for(var j = 0; j < v[i].length; j++) {\n                        if(!exports.validate(v[i][j], arrayItems ? items[i][j] : items)) {\n                            return false;\n                        }\n                    }\n                }\n                else if(!exports.validate(v[i], arrayItems ? items[i] : items)) return false;\n            }\n\n            return true;\n        }\n    }\n};\n\n/**\n * Ensures that container[attribute] has a valid value.\n *\n * attributes[attribute] is an object with possible keys:\n * - valType: data_array, enumerated, boolean, ... as in valObjectMeta\n * - values: (enumerated only) array of allowed vals\n * - min, max: (number, integer only) inclusive bounds on allowed vals\n *      either or both may be omitted\n * - dflt: if attribute is invalid or missing, use this default\n *      if dflt is provided as an argument to lib.coerce it takes precedence\n *      as a convenience, returns the value it finally set\n */\nexports.coerce = function(containerIn, containerOut, attributes, attribute, dflt) {\n    var opts = nestedProperty(attributes, attribute).get(),\n        propIn = nestedProperty(containerIn, attribute),\n        propOut = nestedProperty(containerOut, attribute),\n        v = propIn.get();\n\n    if(dflt === undefined) dflt = opts.dflt;\n\n    /**\n     * arrayOk: value MAY be an array, then we do no value checking\n     * at this point, because it can be more complicated than the\n     * individual form (eg. some array vals can be numbers, even if the\n     * single values must be color strings)\n     */\n    if(opts.arrayOk && isArrayOrTypedArray(v)) {\n        propOut.set(v);\n        return v;\n    }\n\n    exports.valObjectMeta[opts.valType].coerceFunction(v, propOut, dflt, opts);\n\n    return propOut.get();\n};\n\n/**\n * Variation on coerce\n *\n * Uses coerce to get attribute value if user input is valid,\n * returns attribute default if user input it not valid or\n * returns false if there is no user input.\n */\nexports.coerce2 = function(containerIn, containerOut, attributes, attribute, dflt) {\n    var propIn = nestedProperty(containerIn, attribute),\n        propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt),\n        valIn = propIn.get();\n\n    return (valIn !== undefined && valIn !== null) ? propOut : false;\n};\n\n/*\n * Shortcut to coerce the three font attributes\n *\n * 'coerce' is a lib.coerce wrapper with implied first three arguments\n */\nexports.coerceFont = function(coerce, attr, dfltObj) {\n    var out = {};\n\n    dfltObj = dfltObj || {};\n\n    out.family = coerce(attr + '.family', dfltObj.family);\n    out.size = coerce(attr + '.size', dfltObj.size);\n    out.color = coerce(attr + '.color', dfltObj.color);\n\n    return out;\n};\n\n/** Coerce shortcut for 'hoverinfo'\n * handling 1-vs-multi-trace dflt logic\n *\n * @param {object} traceIn : user trace object\n * @param {object} traceOut : full trace object (requires _module ref)\n * @param {object} layoutOut : full layout object (require _dataLength ref)\n * @return {any} : the coerced value\n */\nexports.coerceHoverinfo = function(traceIn, traceOut, layoutOut) {\n    var moduleAttrs = traceOut._module.attributes;\n    var attrs = moduleAttrs.hoverinfo ? moduleAttrs : baseTraceAttrs;\n\n    var valObj = attrs.hoverinfo;\n    var dflt;\n\n    if(layoutOut._dataLength === 1) {\n        var flags = valObj.dflt === 'all' ?\n            valObj.flags.slice() :\n            valObj.dflt.split('+');\n\n        flags.splice(flags.indexOf('name'), 1);\n        dflt = flags.join('+');\n    }\n\n    return exports.coerce(traceIn, traceOut, attrs, 'hoverinfo', dflt);\n};\n\n/** Coerce shortcut for [un]selected.marker.opacity,\n *  which has special default logic, to ensure that it corresponds to the\n *  default selection behavior while allowing to be overtaken by any other\n *  [un]selected attribute.\n *\n *  N.B. This must be called *after* coercing all the other [un]selected attrs,\n *  to give the intended result.\n *\n * @param {object} traceOut : fullData item\n * @param {function} coerce : lib.coerce wrapper with implied first three arguments\n */\nexports.coerceSelectionMarkerOpacity = function(traceOut, coerce) {\n    if(!traceOut.marker) return;\n\n    var mo = traceOut.marker.opacity;\n    // you can still have a `marker` container with no markers if there's text\n    if(mo === undefined) return;\n\n    var smoDflt;\n    var usmoDflt;\n\n    // Don't give [un]selected.marker.opacity a default value if\n    // marker.opacity is an array: handle this during style step.\n    //\n    // Only give [un]selected.marker.opacity a default value if you don't\n    // set any other [un]selected attributes.\n    if(!isArrayOrTypedArray(mo) && !traceOut.selected && !traceOut.unselected) {\n        smoDflt = mo;\n        usmoDflt = DESELECTDIM * mo;\n    }\n\n    coerce('selected.marker.opacity', smoDflt);\n    coerce('unselected.marker.opacity', usmoDflt);\n};\n\nexports.validate = function(value, opts) {\n    var valObjectDef = exports.valObjectMeta[opts.valType];\n\n    if(opts.arrayOk && isArrayOrTypedArray(value)) return true;\n\n    if(valObjectDef.validateFunction) {\n        return valObjectDef.validateFunction(value, opts);\n    }\n\n    var failed = {},\n        out = failed,\n        propMock = { set: function(v) { out = v; } };\n\n    // 'failed' just something mutable that won't be === anything else\n\n    valObjectDef.coerceFunction(value, propMock, failed, opts);\n    return out !== failed;\n};\n",null]}