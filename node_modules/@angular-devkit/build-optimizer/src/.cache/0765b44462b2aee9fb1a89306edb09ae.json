{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/heatmap/interp2d.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/heatmap/interp2d.js","mtime":1529418310717},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar INTERPTHRESHOLD = 1e-2,\n    NEIGHBORSHIFTS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\nfunction correctionOvershoot(maxFractionalChange) {\n    // start with less overshoot, until we know it's converging,\n    // then ramp up the overshoot for faster convergence\n    return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);\n}\n\nmodule.exports = function interp2d(z, emptyPoints, savedInterpZ) {\n    // fill in any missing data in 2D array z using an iterative\n    // poisson equation solver with zero-derivative BC at edges\n    // amazingly, this just amounts to repeatedly averaging all the existing\n    // nearest neighbors (at least if we don't take x/y scaling into account)\n    var maxFractionalChange = 1,\n        i,\n        thisPt;\n\n    if(Array.isArray(savedInterpZ)) {\n        for(i = 0; i < emptyPoints.length; i++) {\n            thisPt = emptyPoints[i];\n            z[thisPt[0]][thisPt[1]] = savedInterpZ[thisPt[0]][thisPt[1]];\n        }\n    }\n    else {\n        // one pass to fill in a starting value for all the empties\n        iterateInterp2d(z, emptyPoints);\n    }\n\n    // we're don't need to iterate lone empties - remove them\n    for(i = 0; i < emptyPoints.length; i++) {\n        if(emptyPoints[i][2] < 4) break;\n    }\n    // but don't remove these points from the original array,\n    // we'll use them for masking, so make a copy.\n    emptyPoints = emptyPoints.slice(i);\n\n    for(i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {\n        maxFractionalChange = iterateInterp2d(z, emptyPoints,\n            correctionOvershoot(maxFractionalChange));\n    }\n    if(maxFractionalChange > INTERPTHRESHOLD) {\n        Lib.log('interp2d didn\\'t converge quickly', maxFractionalChange);\n    }\n\n    return z;\n};\n\nfunction iterateInterp2d(z, emptyPoints, overshoot) {\n    var maxFractionalChange = 0,\n        thisPt,\n        i,\n        j,\n        p,\n        q,\n        neighborShift,\n        neighborRow,\n        neighborVal,\n        neighborCount,\n        neighborSum,\n        initialVal,\n        minNeighbor,\n        maxNeighbor;\n\n    for(p = 0; p < emptyPoints.length; p++) {\n        thisPt = emptyPoints[p];\n        i = thisPt[0];\n        j = thisPt[1];\n        initialVal = z[i][j];\n        neighborSum = 0;\n        neighborCount = 0;\n\n        for(q = 0; q < 4; q++) {\n            neighborShift = NEIGHBORSHIFTS[q];\n            neighborRow = z[i + neighborShift[0]];\n            if(!neighborRow) continue;\n            neighborVal = neighborRow[j + neighborShift[1]];\n            if(neighborVal !== undefined) {\n                if(neighborSum === 0) {\n                    minNeighbor = maxNeighbor = neighborVal;\n                }\n                else {\n                    minNeighbor = Math.min(minNeighbor, neighborVal);\n                    maxNeighbor = Math.max(maxNeighbor, neighborVal);\n                }\n                neighborCount++;\n                neighborSum += neighborVal;\n            }\n        }\n\n        if(neighborCount === 0) {\n            throw 'iterateInterp2d order is wrong: no defined neighbors';\n        }\n\n        // this is the laplace equation interpolation:\n        // each point is just the average of its neighbors\n        // note that this ignores differential x/y scaling\n        // which I think is the right approach, since we\n        // don't know what that scaling means\n        z[i][j] = neighborSum / neighborCount;\n\n        if(initialVal === undefined) {\n            if(neighborCount < 4) maxFractionalChange = 1;\n        }\n        else {\n            // we can make large empty regions converge faster\n            // if we overshoot the change vs the previous value\n            z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;\n\n            if(maxNeighbor > minNeighbor) {\n                maxFractionalChange = Math.max(maxFractionalChange,\n                    Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor));\n            }\n        }\n    }\n\n    return maxFractionalChange;\n}\n",null]}