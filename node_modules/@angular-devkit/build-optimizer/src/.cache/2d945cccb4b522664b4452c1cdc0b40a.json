{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/regl-error2d/index.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/regl-error2d/index.js","mtime":1529418310988},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\r\n\r\nconst getBounds = require('array-bounds')\r\nconst rgba = require('color-normalize')\r\nconst updateDiff = require('update-diff')\r\nconst pick = require('pick-by-alias')\r\nconst extend = require('object-assign')\r\nconst flatten = require('flatten-vertex-data')\r\nconst {float32, fract32} = require('to-float32')\r\n\r\nmodule.exports = Error2D\r\n\r\nconst WEIGHTS = [\r\n\t//direction, lineWidth shift, capSize shift\r\n\r\n\t// x-error bar\r\n\t[1, 0, 0, 1, 0, 0],\r\n\t[1, 0, 0, -1, 0, 0],\r\n\t[-1, 0, 0, -1, 0, 0],\r\n\r\n\t[-1, 0, 0, -1, 0, 0],\r\n\t[-1, 0, 0, 1, 0, 0],\r\n\t[1, 0, 0, 1, 0, 0],\r\n\r\n\t// x-error right cap\r\n\t[1, 0, -1, 0, 0, 1],\r\n\t[1, 0, -1, 0, 0, -1],\r\n\t[1, 0, 1, 0, 0, -1],\r\n\r\n\t[1, 0, 1, 0, 0, -1],\r\n\t[1, 0, 1, 0, 0, 1],\r\n\t[1, 0, -1, 0, 0, 1],\r\n\r\n\t// x-error left cap\r\n\t[-1, 0, -1, 0, 0, 1],\r\n\t[-1, 0, -1, 0, 0, -1],\r\n\t[-1, 0, 1, 0, 0, -1],\r\n\r\n\t[-1, 0, 1, 0, 0, -1],\r\n\t[-1, 0, 1, 0, 0, 1],\r\n\t[-1, 0, -1, 0, 0, 1],\r\n\r\n\t// y-error bar\r\n\t[0, 1, 1, 0, 0, 0],\r\n\t[0, 1, -1, 0, 0, 0],\r\n\t[0, -1, -1, 0, 0, 0],\r\n\r\n\t[0, -1, -1, 0, 0, 0],\r\n\t[0, 1, 1, 0, 0, 0],\r\n\t[0, -1, 1, 0, 0, 0],\r\n\r\n\t// y-error top cap\r\n\t[0, 1, 0, -1, 1, 0],\r\n\t[0, 1, 0, -1, -1, 0],\r\n\t[0, 1, 0, 1, -1, 0],\r\n\r\n\t[0, 1, 0, 1, 1, 0],\r\n\t[0, 1, 0, -1, 1, 0],\r\n\t[0, 1, 0, 1, -1, 0],\r\n\r\n\t// y-error bottom cap\r\n\t[0, -1, 0, -1, 1, 0],\r\n\t[0, -1, 0, -1, -1, 0],\r\n\t[0, -1, 0, 1, -1, 0],\r\n\r\n\t[0, -1, 0, 1, 1, 0],\r\n\t[0, -1, 0, -1, 1, 0],\r\n\t[0, -1, 0, 1, -1, 0]\r\n]\r\n\r\n\r\nfunction Error2D (regl, options) {\r\n\tif (typeof regl === 'function') {\r\n\t\tif (!options) options = {}\r\n\t\toptions.regl = regl\r\n\t}\r\n\telse {\r\n\t\toptions = regl\r\n\t}\r\n\tif (options.length) options.positions = options\r\n\tregl = options.regl\r\n\r\n\tif (!regl.hasExtension('ANGLE_instanced_arrays')) {\r\n\t\tthrow Error('regl-error2d: `ANGLE_instanced_arrays` extension should be enabled');\r\n\t}\r\n\r\n\t// persistent variables\r\n\tlet gl = regl._gl, drawErrors, positionBuffer, positionFractBuffer, colorBuffer, errorBuffer, meshBuffer,\r\n\t\t\tdefaults = {\r\n\t\t\t\tcolor: 'black',\r\n\t\t\t\tcapSize: 5,\r\n\t\t\t\tlineWidth: 1,\r\n\t\t\t\topacity: 1,\r\n\t\t\t\tviewport: null,\r\n\t\t\t\trange: null,\r\n\t\t\t\toffset: 0,\r\n\t\t\t\tcount: 0,\r\n\t\t\t\tbounds: null,\r\n\t\t\t\tpositions: [],\r\n\t\t\t\terrors: []\r\n\t\t\t}, groups = []\r\n\r\n\t//color per-point\r\n\tcolorBuffer = regl.buffer({\r\n\t\tusage: 'dynamic',\r\n\t\ttype: 'uint8',\r\n\t\tdata: new Uint8Array(0)\r\n\t})\r\n\t//xy-position per-point\r\n\tpositionBuffer = regl.buffer({\r\n\t\tusage: 'dynamic',\r\n\t\ttype: 'float',\r\n\t\tdata: new Uint8Array(0)\r\n\t})\r\n\t//xy-position float32-fraction\r\n\tpositionFractBuffer = regl.buffer({\r\n\t\tusage: 'dynamic',\r\n\t\ttype: 'float',\r\n\t\tdata: new Uint8Array(0)\r\n\t})\r\n\t//4 errors per-point\r\n\terrorBuffer = regl.buffer({\r\n\t\tusage: 'dynamic',\r\n\t\ttype: 'float',\r\n\t\tdata: new Uint8Array(0)\r\n\t})\r\n\t//error bar mesh\r\n\tmeshBuffer = regl.buffer({\r\n\t\tusage: 'static',\r\n\t\ttype: 'float',\r\n\t\tdata: WEIGHTS\r\n\t})\r\n\r\n\tupdate(options)\r\n\r\n\t//drawing method\r\n\tdrawErrors = regl({\r\n\t\tvert: `\r\n\t\tprecision highp float;\r\n\r\n\t\tattribute vec2 position, positionFract;\r\n\t\tattribute vec4 error;\r\n\t\tattribute vec4 color;\r\n\r\n\t\tattribute vec2 direction, lineOffset, capOffset;\r\n\r\n\t\tuniform vec4 viewport;\r\n\t\tuniform float lineWidth, capSize;\r\n\t\tuniform vec2 scale, scaleFract, translate, translateFract;\r\n\r\n\t\tvarying vec4 fragColor;\r\n\r\n\t\tvoid main() {\r\n\t\t\tfragColor = color / 255.;\r\n\r\n\t\t\tvec2 pixelOffset = lineWidth * lineOffset + (capSize + lineWidth) * capOffset;\r\n\r\n\t\t\tvec2 dxy = -step(.5, direction.xy) * error.xz + step(direction.xy, vec2(-.5)) * error.yw;\r\n\r\n\t\t\tvec2 position = position + dxy;\r\n\r\n\t\t\tvec2 pos = (position + translate) * scale\r\n\t\t\t\t+ (positionFract + translateFract) * scale\r\n\t\t\t\t+ (position + translate) * scaleFract\r\n\t\t\t\t+ (positionFract + translateFract) * scaleFract;\r\n\r\n\t\t\tpos += pixelOffset / viewport.zw;\r\n\r\n\t\t\tgl_Position = vec4(pos * 2. - 1., 0, 1);\r\n\t\t}\r\n\t\t`,\r\n\r\n\t\tfrag: `\r\n\t\tprecision mediump float;\r\n\r\n\t\tvarying vec4 fragColor;\r\n\r\n\t\tuniform float opacity;\r\n\r\n\t\tvoid main() {\r\n\t\t\tgl_FragColor = fragColor;\r\n\t\t\tgl_FragColor.a *= opacity;\r\n\t\t}\r\n\t\t`,\r\n\r\n\t\tuniforms: {\r\n\t\t\trange: regl.prop('range'),\r\n\t\t\tlineWidth: regl.prop('lineWidth'),\r\n\t\t\tcapSize: regl.prop('capSize'),\r\n\t\t\topacity: regl.prop('opacity'),\r\n\t\t\tscale: regl.prop('scale'),\r\n\t\t\ttranslate: regl.prop('translate'),\r\n\t\t\tscaleFract: regl.prop('scaleFract'),\r\n\t\t\ttranslateFract: regl.prop('translateFract'),\r\n\t\t\tviewport: (ctx, prop) => [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight]\r\n\t\t},\r\n\r\n\t\tattributes: {\r\n\t\t\t//dynamic attributes\r\n\t\t\tcolor: {\r\n\t\t\t\tbuffer: colorBuffer,\r\n\t\t\t\toffset: (ctx, prop) => prop.offset * 4,\r\n\t\t\t\tdivisor: 1,\r\n\t\t\t},\r\n\t\t\tposition: {\r\n\t\t\t\tbuffer: positionBuffer,\r\n\t\t\t\toffset: (ctx, prop) => prop.offset * 8,\r\n\t\t\t\tdivisor: 1\r\n\t\t\t},\r\n\t\t\tpositionFract: {\r\n\t\t\t\tbuffer: positionFractBuffer,\r\n\t\t\t\toffset: (ctx, prop) => prop.offset * 8,\r\n\t\t\t\tdivisor: 1\r\n\t\t\t},\r\n\t\t\terror: {\r\n\t\t\t\tbuffer: errorBuffer,\r\n\t\t\t\toffset: (ctx, prop) => prop.offset * 16,\r\n\t\t\t\tdivisor: 1\r\n\t\t\t},\r\n\r\n\t\t\t//static attributes\r\n\t\t\tdirection: {\r\n\t\t\t\tbuffer: meshBuffer,\r\n\t\t\t\tstride: 24,\r\n\t\t\t\toffset: 0\r\n\t\t\t},\r\n\t\t\tlineOffset: {\r\n\t\t\t\tbuffer: meshBuffer,\r\n\t\t\t\tstride: 24,\r\n\t\t\t\toffset: 8\r\n\t\t\t},\r\n\t\t\tcapOffset: {\r\n\t\t\t\tbuffer: meshBuffer,\r\n\t\t\t\tstride: 24,\r\n\t\t\t\toffset: 16\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tprimitive: 'triangles',\r\n\r\n\t\tblend: {\r\n\t\t\tenable: true,\r\n\t\t\tcolor: [0,0,0,0],\r\n\t\t\tequation: {\r\n\t\t\t\trgb: 'add',\r\n\t\t\t\talpha: 'add'\r\n\t\t\t},\r\n\t\t\tfunc: {\r\n\t\t\t\tsrcRGB: 'src alpha',\r\n\t\t\t\tdstRGB: 'one minus src alpha',\r\n\t\t\t\tsrcAlpha: 'one minus dst alpha',\r\n\t\t\t\tdstAlpha: 'one'\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdepth: {\r\n\t\t\tenable: false\r\n\t\t},\r\n\r\n\t\tscissor: {\r\n\t\t\tenable: true,\r\n\t\t\tbox: regl.prop('viewport')\r\n\t\t},\r\n\t\tviewport: regl.prop('viewport'),\r\n\t\tstencil: false,\r\n\r\n\t\tinstances: regl.prop('count'),\r\n\t\tcount: WEIGHTS.length\r\n\t})\r\n\r\n\t//expose API\r\n\textend(error2d, {\r\n\t\tupdate: update,\r\n\t\tdraw: draw,\r\n\t\tdestroy: destroy,\r\n\t\tregl: regl,\r\n\t\tgl: gl,\r\n\t\tcanvas: gl.canvas,\r\n\t\tgroups: groups\r\n\t})\r\n\r\n\treturn error2d\r\n\r\n\tfunction error2d (opts) {\r\n\t\t//update\r\n\t\tif (opts) {\r\n\t\t\tupdate(opts)\r\n\t\t}\r\n\r\n\t\t//destroy\r\n\t\telse if (opts === null) {\r\n\t\t\tdestroy()\r\n\t\t}\r\n\r\n\t\tdraw()\r\n\t}\r\n\r\n\r\n\t//main draw method\r\n\tfunction draw (options) {\r\n\t\tif (typeof options === 'number') return drawGroup(options)\r\n\r\n\t\t//make options a batch\r\n\t\tif (options && !Array.isArray(options)) options = [options]\r\n\r\n\r\n\t\tregl._refresh()\r\n\r\n\t\t//render multiple polylines via regl batch\r\n\t\tgroups.forEach((s, i) => {\r\n\t\t\tif (!s) return\r\n\r\n\t\t\tif (options) {\r\n\t\t\t\tif (!options[i]) s.draw = false\r\n\t\t\t\telse s.draw = true\r\n\t\t\t}\r\n\r\n\t\t\t//ignore draw flag for one pass\r\n\t\t\tif (!s.draw) {\r\n\t\t\t\ts.draw = true;\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tdrawGroup(i)\r\n\t\t})\r\n\t}\r\n\r\n\t//draw single error group by id\r\n\tfunction drawGroup (s) {\r\n\t\tif (typeof s === 'number') s = groups[s]\r\n\t\tif (s == null) return\r\n\r\n\t\tif (!(s && s.count && s.color && s.opacity && s.positions && s.positions.length > 1)) return\r\n\r\n\t\ts.scaleRatio = [\r\n\t\t\ts.scale[0] * s.viewport.width,\r\n\t\t\ts.scale[1] * s.viewport.height\r\n\t\t]\r\n\r\n\t\tdrawErrors(s)\r\n\r\n\t\tif (s.after) s.after(s)\r\n\t}\r\n\r\n\tfunction update (options) {\r\n\t\tif (!options) return\r\n\r\n\t\t//direct points argument\r\n\t\tif (options.length != null) {\r\n\t\t\tif (typeof options[0] === 'number') options = [{positions: options}]\r\n\t\t}\r\n\r\n\t\t//make options a batch\r\n\t\telse if (!Array.isArray(options)) options = [options]\r\n\r\n\t\t//global count of points\r\n\t\tlet pointCount = 0, errorCount = 0\r\n\r\n\t\terror2d.groups = groups = options.map((options, i) => {\r\n\t\t\tlet group = groups[i]\r\n\r\n\t\t\tif (!options) return group\r\n\t\t\telse if (typeof options === 'function') options = {after: options}\r\n\t\t\telse if (typeof options[0] === 'number') options = {positions: options}\r\n\r\n\t\t\t//copy options to avoid mutation & handle aliases\r\n\t\t\toptions = pick(options, {\r\n\t\t\t\tcolor: 'color colors fill',\r\n\t\t\t\tcapSize: 'capSize cap capsize cap-size',\r\n\t\t\t\tlineWidth: 'lineWidth line-width width line thickness',\r\n\t\t\t\topacity: 'opacity alpha',\r\n\t\t\t\trange: 'range dataBox',\r\n\t\t\t\tviewport: 'viewport viewBox',\r\n\t\t\t\terrors: 'errors error',\r\n\t\t\t\tpositions: 'positions position data points'\r\n\t\t\t})\r\n\r\n\t\t\tif (!group) {\r\n\t\t\t\tgroups[i] = group = {\r\n\t\t\t\t\tid: i,\r\n\t\t\t\t\tscale: null,\r\n\t\t\t\t\ttranslate: null,\r\n\t\t\t\t\tscaleFract: null,\r\n\t\t\t\t\ttranslateFract: null,\r\n\t\t\t\t\tdraw: true\r\n\t\t\t\t}\r\n\t\t\t\toptions = extend({}, defaults, options)\r\n\t\t\t}\r\n\r\n\t\t\tupdateDiff(group, options, [{\r\n\t\t\t\tlineWidth: v => +v * .5,\r\n\t\t\t\tcapSize: v => +v * .5,\r\n\t\t\t\topacity: parseFloat,\r\n\t\t\t\terrors: errors => {\r\n\t\t\t\t\terrors = flatten(errors)\r\n\r\n\t\t\t\t\terrorCount += errors.length\r\n\t\t\t\t\treturn errors\r\n\t\t\t\t},\r\n\t\t\t\tpositions: (positions, state) => {\r\n\t\t\t\t\tpositions = flatten(positions, 'float64')\r\n\t\t\t\t\tstate.count = Math.floor(positions.length / 2)\r\n\t\t\t\t\tstate.bounds = getBounds(positions, 2)\r\n\t\t\t\t\tstate.offset = pointCount\r\n\r\n\t\t\t\t\tpointCount += state.count\r\n\r\n\t\t\t\t\treturn positions\r\n\t\t\t\t}\r\n\t\t\t}, {\r\n\t\t\t\tcolor: (colors, state) => {\r\n\t\t\t\t\tlet count = state.count\r\n\r\n\t\t\t\t\tif (!colors) colors = 'transparent'\r\n\r\n\t\t\t\t\t// 'black' or [0,0,0,0] case\r\n\t\t\t\t\tif (!Array.isArray(colors) || typeof colors[0] === 'number') {\r\n\t\t\t\t\t\tlet color = colors\r\n\t\t\t\t\t\tcolors = Array(count)\r\n\t\t\t\t\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\t\t\t\t\tcolors[i] = color\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (colors.length < count) throw Error('Not enough colors')\r\n\r\n\t\t\t\t\tlet colorData = new Uint8Array(count * 4)\r\n\r\n\t\t\t\t\t//convert colors to float arrays\r\n\t\t\t\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\t\t\t\tlet c = rgba(colors[i], 'uint8')\r\n\t\t\t\t\t\tcolorData.set(c, i * 4)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn colorData\r\n\t\t\t\t},\r\n\r\n\t\t\t\trange: (range, state, options) => {\r\n\t\t\t\t\tlet bounds = state.bounds\r\n\t\t\t\t\tif (!range) range = bounds\r\n\r\n\t\t\t\t\tstate.scale = [1 / (range[2] - range[0]), 1 / (range[3] - range[1])]\r\n\t\t\t\t\tstate.translate = [-range[0], -range[1]]\r\n\r\n\t\t\t\t\tstate.scaleFract = fract32(state.scale)\r\n\t\t\t\t\tstate.translateFract = fract32(state.translate)\r\n\r\n\t\t\t\t\treturn range\r\n\t\t\t\t},\r\n\r\n\t\t\t\tviewport: vp => {\r\n\t\t\t\t\tlet viewport\r\n\r\n\t\t\t\t\tif (Array.isArray(vp)) {\r\n\t\t\t\t\t\tviewport = {\r\n\t\t\t\t\t\t\tx: vp[0],\r\n\t\t\t\t\t\t\ty: vp[1],\r\n\t\t\t\t\t\t\twidth: vp[2] - vp[0],\r\n\t\t\t\t\t\t\theight: vp[3] - vp[1]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (vp) {\r\n\t\t\t\t\t\tviewport = {\r\n\t\t\t\t\t\t\tx: vp.x || vp.left || 0,\r\n\t\t\t\t\t\t\ty: vp.y || vp.top || 0\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (vp.right) viewport.width = vp.right - viewport.x\r\n\t\t\t\t\t\telse viewport.width = vp.w || vp.width || 0\r\n\r\n\t\t\t\t\t\tif (vp.bottom) viewport.height = vp.bottom - viewport.y\r\n\t\t\t\t\t\telse viewport.height = vp.h || vp.height || 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tviewport = {\r\n\t\t\t\t\t\t\tx: 0, y: 0,\r\n\t\t\t\t\t\t\twidth: gl.drawingBufferWidth,\r\n\t\t\t\t\t\t\theight: gl.drawingBufferHeight\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn viewport\r\n\t\t\t\t}\r\n\t\t\t}])\r\n\r\n\t\t\treturn group\r\n\t\t})\r\n\r\n\t\tif (pointCount || errorCount) {\r\n\t\t\tlet len = groups.reduce((acc, group, i) => {\r\n\t\t\t\treturn acc + (group ? group.count : 0)\r\n\t\t\t}, 0)\r\n\r\n\t\t\tlet positionData = new Float64Array(len * 2)\r\n\t\t\tlet colorData = new Uint8Array(len * 4)\r\n\t\t\tlet errorData = new Float32Array(len * 4)\r\n\r\n\t\t\tgroups.forEach((group, i) => {\r\n\t\t\t\tif (!group) return\r\n\t\t\t\tlet {positions, count, offset, color, errors} = group\r\n\t\t\t\tif (!count) return\r\n\r\n\t\t\t\tcolorData.set(color, offset * 4)\r\n\t\t\t\terrorData.set(errors, offset * 4)\r\n\t\t\t\tpositionData.set(positions, offset * 2)\r\n\t\t\t})\r\n\r\n\t\t\tpositionBuffer(float32(positionData))\r\n\t\t\tpositionFractBuffer(fract32(positionData))\r\n\t\t\tcolorBuffer(colorData)\r\n\t\t\terrorBuffer(errorData)\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction destroy () {\r\n\t\tpositionBuffer.destroy()\r\n\t\tpositionFractBuffer.destroy()\r\n\t\tcolorBuffer.destroy()\r\n\t\terrorBuffer.destroy()\r\n\t\tmeshBuffer.destroy()\r\n\t}\r\n}\r\n",null]}