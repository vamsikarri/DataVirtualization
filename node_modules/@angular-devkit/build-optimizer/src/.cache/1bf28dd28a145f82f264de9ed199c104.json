{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/bar/sieve.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/bar/sieve.js","mtime":1529418310701},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = Sieve;\n\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\n/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n * @param {Array}   traces\n *                  Array of calculated traces\n * @param {boolean} [separateNegativeValues]\n *                  If true, then split data at the same position into a bar\n *                  for positive values and another for negative values\n * @param {boolean} [dontMergeOverlappingData]\n *                  If true, then don't merge overlapping bars into a single bar\n */\nfunction Sieve(traces, separateNegativeValues, dontMergeOverlappingData) {\n    this.traces = traces;\n    this.separateNegativeValues = separateNegativeValues;\n    this.dontMergeOverlappingData = dontMergeOverlappingData;\n\n    // for single-bin histograms - see histogram/calc\n    var width1 = Infinity;\n\n    var positions = [];\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j];\n            if(bar.p !== BADNUM) positions.push(bar.p);\n        }\n        if(trace[0] && trace[0].width1) {\n            width1 = Math.min(trace[0].width1, width1);\n        }\n    }\n    this.positions = positions;\n\n    var dv = Lib.distinctVals(positions);\n    this.distinctPositions = dv.vals;\n    if(dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;\n    else this.minDiff = Math.min(dv.minDiff, width1);\n\n    this.binWidth = this.minDiff;\n\n    this.bins = {};\n}\n\n/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */\nSieve.prototype.put = function put(position, value) {\n    var label = this.getLabel(position, value),\n        oldValue = this.bins[label] || 0;\n\n    this.bins[label] = oldValue + value;\n\n    return oldValue;\n};\n\n/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.separateNegativeValues is true)\n * @returns {number} Current bin value\n */\nSieve.prototype.get = function put(position, value) {\n    var label = this.getLabel(position, value);\n    return this.bins[label] || 0;\n};\n\n/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.separateNegativeValues is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.separateNegativeValues is\n * true; otherwise prefixed with '^')\n */\nSieve.prototype.getLabel = function getLabel(position, value) {\n    var prefix = (value < 0 && this.separateNegativeValues) ? 'v' : '^',\n        label = (this.dontMergeOverlappingData) ?\n            position :\n            Math.round(position / this.binWidth);\n    return prefix + label;\n};\n",null]}