{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/ohlc/hover.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/ohlc/hover.js","mtime":1529418310725},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Fx = require('../../components/fx');\nvar Color = require('../../components/color');\nvar fillHoverText = require('../scatter/fill_hover_text');\n\nvar DIRSYMBOL = {\n    increasing: '▲',\n    decreasing: '▼'\n};\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n\n    var type = trace.type;\n    var minAttr = type === 'ohlc' ? 'l' : 'min';\n    var maxAttr = type === 'ohlc' ? 'h' : 'max';\n\n    // potentially shift xval for grouped candlesticks\n    var centerShift = t.bPos || 0;\n    var x0 = xval - centerShift;\n\n    // ohlc and candlestick call displayHalfWidth different things...\n    var displayHalfWidth = t.bdPos || t.tickLen;\n    var hoverHalfWidth = t.wHover;\n\n    // if two items are overlaying, let the narrowest one win\n    var pseudoDistance = Math.min(1, displayHalfWidth / Math.abs(xa.r2c(xa.range[1]) - xa.r2c(xa.range[0])));\n    var hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n    var spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n\n    function dx(di) {\n        var pos = di.pos - x0;\n        return Fx.inbox(pos - hoverHalfWidth, pos + hoverHalfWidth, hoverPseudoDistance);\n    }\n\n    function dy(di) {\n        return Fx.inbox(di[minAttr] - yval, di[maxAttr] - yval, hoverPseudoDistance);\n    }\n\n    function dxy(di) { return (dx(di) + dy(di)) / 2; }\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if(pointData.index === false) return [];\n\n    // we don't make a calcdata point if we're missing any piece (x/o/h/l/c)\n    // so we need to fix the index here to point to the data arrays\n    var cdIndex = pointData.index;\n    var di = cd[cdIndex];\n    var i = pointData.index = di.i;\n\n    var dir = di.dir;\n    var container = trace[dir];\n    var lc = container.line.color;\n\n    if(Color.opacity(lc) && container.line.width) pointData.color = lc;\n    else pointData.color = container.fillcolor;\n\n    pointData.x0 = xa.c2p(di.pos + centerShift - displayHalfWidth, true);\n    pointData.x1 = xa.c2p(di.pos + centerShift + displayHalfWidth, true);\n\n    pointData.xLabelVal = di.pos;\n\n    pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n    pointData.xSpike = xa.c2p(di.pos, true);\n\n    function getLabelLine(attr) {\n        return t.labels[attr] + Axes.hoverLabelText(ya, trace[attr][i]);\n    }\n\n    var hoverinfo = trace.hoverinfo;\n    var hoverParts = hoverinfo.split('+');\n    var isAll = hoverinfo === 'all';\n    var hasY = isAll || hoverParts.indexOf('y') !== -1;\n    var hasText = isAll || hoverParts.indexOf('text') !== -1;\n\n    var textParts = hasY ? [\n        getLabelLine('open'),\n        getLabelLine('high'),\n        getLabelLine('low'),\n        getLabelLine('close') + '  ' + DIRSYMBOL[dir]\n    ] : [];\n    if(hasText) fillHoverText(di, trace, textParts);\n\n    // don't make .yLabelVal or .text, since we're managing hoverinfo\n    // put it all in .extraText\n    pointData.extraText = textParts.join('<br>');\n\n    // this puts the label *and the spike* at the midpoint of the box, ie\n    // halfway between open and close, not between high and low.\n    pointData.y0 = pointData.y1 = ya.c2p(di.yc, true);\n\n    return [pointData];\n};\n",null]}