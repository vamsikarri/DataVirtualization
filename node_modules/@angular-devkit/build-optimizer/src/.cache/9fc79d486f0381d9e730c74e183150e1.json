{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-axes3d/axes.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-axes3d/axes.js","mtime":1529418308590},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\r\n\r\nmodule.exports = createAxes\r\n\r\nvar createText        = require('./lib/text.js')\r\nvar createLines       = require('./lib/lines.js')\r\nvar createBackground  = require('./lib/background.js')\r\nvar getCubeProperties = require('./lib/cube.js')\r\nvar Ticks             = require('./lib/ticks.js')\r\n\r\nvar identity = new Float32Array([\r\n  1, 0, 0, 0,\r\n  0, 1, 0, 0,\r\n  0, 0, 1, 0,\r\n  0, 0, 0, 1])\r\n\r\nfunction copyVec3(a, b) {\r\n  a[0] = b[0]\r\n  a[1] = b[1]\r\n  a[2] = b[2]\r\n  return a\r\n}\r\n\r\nfunction Axes(gl) {\r\n  this.gl             = gl\r\n\r\n  this.pixelRatio     = 1\r\n\r\n  this.bounds         = [ [-10, -10, -10],\r\n                          [ 10,  10,  10] ]\r\n  this.ticks          = [ [], [], [] ]\r\n  this.autoTicks      = true\r\n  this.tickSpacing    = [ 1, 1, 1 ]\r\n\r\n  this.tickEnable     = [ true, true, true ]\r\n  this.tickFont       = [ 'sans-serif', 'sans-serif', 'sans-serif' ]\r\n  this.tickSize       = [ 12, 12, 12 ]\r\n  this.tickAngle      = [ 0, 0, 0 ]\r\n  this.tickColor      = [ [0,0,0,1], [0,0,0,1], [0,0,0,1] ]\r\n  this.tickPad        = [ 10, 10, 10 ]\r\n\r\n  this.lastCubeProps  = {\r\n    cubeEdges: [0,0,0],\r\n    axis:      [0,0,0]\r\n  }\r\n\r\n  this.labels         = [ 'x', 'y', 'z' ]\r\n  this.labelEnable    = [ true, true, true ]\r\n  this.labelFont      = 'sans-serif'\r\n  this.labelSize      = [ 20, 20, 20 ]\r\n  this.labelAngle     = [ 0, 0, 0 ]\r\n  this.labelColor     = [ [0,0,0,1], [0,0,0,1], [0,0,0,1] ]\r\n  this.labelPad       = [ 10, 10, 10 ]\r\n\r\n  this.lineEnable     = [ true, true, true ]\r\n  this.lineMirror     = [ false, false, false ]\r\n  this.lineWidth      = [ 1, 1, 1 ]\r\n  this.lineColor      = [ [0,0,0,1], [0,0,0,1], [0,0,0,1] ]\r\n\r\n  this.lineTickEnable = [ true, true, true ]\r\n  this.lineTickMirror = [ false, false, false ]\r\n  this.lineTickLength = [ 0, 0, 0 ]\r\n  this.lineTickWidth  = [ 1, 1, 1 ]\r\n  this.lineTickColor  = [ [0,0,0,1], [0,0,0,1], [0,0,0,1] ]\r\n\r\n  this.gridEnable     = [ true, true, true ]\r\n  this.gridWidth      = [ 1, 1, 1 ]\r\n  this.gridColor      = [ [0,0,0,1], [0,0,0,1], [0,0,0,1] ]\r\n\r\n  this.zeroEnable     = [ true, true, true ]\r\n  this.zeroLineColor  = [ [0,0,0,1], [0,0,0,1], [0,0,0,1] ]\r\n  this.zeroLineWidth  = [ 2, 2, 2 ]\r\n\r\n  this.backgroundEnable = [ false, false, false ]\r\n  this.backgroundColor  = [ [0.8, 0.8, 0.8, 0.5],\r\n                            [0.8, 0.8, 0.8, 0.5],\r\n                            [0.8, 0.8, 0.8, 0.5] ]\r\n\r\n  this._firstInit = true\r\n  this._text  = null\r\n  this._lines = null\r\n  this._background = createBackground(gl)\r\n}\r\n\r\nvar proto = Axes.prototype\r\n\r\nproto.update = function(options) {\r\n  options = options || {}\r\n\r\n  //Option parsing helper functions\r\n  function parseOption(nest, cons, name) {\r\n    if(name in options) {\r\n      var opt = options[name]\r\n      var prev = this[name]\r\n      var next\r\n      if(nest ? (Array.isArray(opt) && Array.isArray(opt[0])) :\r\n                 Array.isArray(opt) ) {\r\n        this[name] = next = [ cons(opt[0]), cons(opt[1]), cons(opt[2]) ]\r\n      } else {\r\n        this[name] = next = [ cons(opt), cons(opt), cons(opt) ]\r\n      }\r\n      for(var i=0; i<3; ++i) {\r\n        if(next[i] !== prev[i]) {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  var NUMBER  = parseOption.bind(this, false, Number)\r\n  var BOOLEAN = parseOption.bind(this, false, Boolean)\r\n  var STRING  = parseOption.bind(this, false, String)\r\n  var COLOR   = parseOption.bind(this, true, function(v) {\r\n    if(Array.isArray(v)) {\r\n      if(v.length === 3) {\r\n        return [ +v[0], +v[1], +v[2], 1.0 ]\r\n      } else if(v.length === 4) {\r\n        return [ +v[0], +v[1], +v[2], +v[3] ]\r\n      }\r\n    }\r\n    return [ 0, 0, 0, 1 ]\r\n  })\r\n\r\n  //Tick marks and bounds\r\n  var nextTicks\r\n  var ticksUpdate   = false\r\n  var boundsChanged = false\r\n  if('bounds' in options) {\r\n    var bounds = options.bounds\r\ni_loop:\r\n    for(var i=0; i<2; ++i) {\r\n      for(var j=0; j<3; ++j) {\r\n        if(bounds[i][j] !== this.bounds[i][j]) {\r\n          boundsChanged = true\r\n        }\r\n        this.bounds[i][j] = bounds[i][j]\r\n      }\r\n    }\r\n  }\r\n  if('ticks' in options) {\r\n    nextTicks      = options.ticks\r\n    ticksUpdate    = true\r\n    this.autoTicks = false\r\n    for(var i=0; i<3; ++i) {\r\n      this.tickSpacing[i] = 0.0\r\n    }\r\n  } else if(NUMBER('tickSpacing')) {\r\n    this.autoTicks  = true\r\n    boundsChanged   = true\r\n  }\r\n\r\n  if(this._firstInit) {\r\n    if(!('ticks' in options || 'tickSpacing' in options)) {\r\n      this.autoTicks = true\r\n    }\r\n\r\n    //Force tick recomputation on first update\r\n    boundsChanged   = true\r\n    ticksUpdate     = true\r\n    this._firstInit = false\r\n  }\r\n\r\n  if(boundsChanged && this.autoTicks) {\r\n    nextTicks = Ticks.create(this.bounds, this.tickSpacing)\r\n    ticksUpdate = true\r\n  }\r\n\r\n  //Compare next ticks to previous ticks, only update if needed\r\n  if(ticksUpdate) {\r\n    for(var i=0; i<3; ++i) {\r\n      nextTicks[i].sort(function(a,b) {\r\n        return a.x-b.x\r\n      })\r\n    }\r\n    if(Ticks.equal(nextTicks, this.ticks)) {\r\n      ticksUpdate = false\r\n    } else {\r\n      this.ticks = nextTicks\r\n    }\r\n  }\r\n\r\n  //Parse tick properties\r\n  BOOLEAN('tickEnable')\r\n  if(STRING('tickFont')) {\r\n    ticksUpdate = true  //If font changes, must rebuild vbo\r\n  }\r\n  NUMBER('tickSize')\r\n  NUMBER('tickAngle')\r\n  NUMBER('tickPad')\r\n  COLOR('tickColor')\r\n\r\n  //Axis labels\r\n  var labelUpdate = STRING('labels')\r\n  if(STRING('labelFont')) {\r\n    labelUpdate = true\r\n  }\r\n  BOOLEAN('labelEnable')\r\n  NUMBER('labelSize')\r\n  NUMBER('labelPad')\r\n  COLOR('labelColor')\r\n\r\n  //Axis lines\r\n  BOOLEAN('lineEnable')\r\n  BOOLEAN('lineMirror')\r\n  NUMBER('lineWidth')\r\n  COLOR('lineColor')\r\n\r\n  //Axis line ticks\r\n  BOOLEAN('lineTickEnable')\r\n  BOOLEAN('lineTickMirror')\r\n  NUMBER('lineTickLength')\r\n  NUMBER('lineTickWidth')\r\n  COLOR('lineTickColor')\r\n\r\n  //Grid lines\r\n  BOOLEAN('gridEnable')\r\n  NUMBER('gridWidth')\r\n  COLOR('gridColor')\r\n\r\n  //Zero line\r\n  BOOLEAN('zeroEnable')\r\n  COLOR('zeroLineColor')\r\n  NUMBER('zeroLineWidth')\r\n\r\n  //Background\r\n  BOOLEAN('backgroundEnable')\r\n  COLOR('backgroundColor')\r\n\r\n  //Update text if necessary\r\n  if(!this._text) {\r\n    this._text = createText(\r\n      this.gl,\r\n      this.bounds,\r\n      this.labels,\r\n      this.labelFont,\r\n      this.ticks,\r\n      this.tickFont)\r\n  } else if(this._text && (labelUpdate || ticksUpdate)) {\r\n    this._text.update(\r\n      this.bounds,\r\n      this.labels,\r\n      this.labelFont,\r\n      this.ticks,\r\n      this.tickFont)\r\n  }\r\n\r\n  //Update lines if necessary\r\n  if(this._lines && ticksUpdate) {\r\n    this._lines.dispose()\r\n    this._lines = null\r\n  }\r\n  if(!this._lines) {\r\n    this._lines = createLines(this.gl, this.bounds, this.ticks)\r\n  }\r\n}\r\n\r\nfunction OffsetInfo() {\r\n  this.primalOffset = [0,0,0]\r\n  this.primalMinor  = [0,0,0]\r\n  this.mirrorOffset = [0,0,0]\r\n  this.mirrorMinor  = [0,0,0]\r\n}\r\n\r\nvar LINE_OFFSET = [ new OffsetInfo(), new OffsetInfo(), new OffsetInfo() ]\r\n\r\nfunction computeLineOffset(result, i, bounds, cubeEdges, cubeAxis) {\r\n  var primalOffset = result.primalOffset\r\n  var primalMinor  = result.primalMinor\r\n  var dualOffset   = result.mirrorOffset\r\n  var dualMinor    = result.mirrorMinor\r\n  var e = cubeEdges[i]\r\n\r\n  //Calculate offsets\r\n  for(var j=0; j<3; ++j) {\r\n    if(i === j) {\r\n      continue\r\n    }\r\n    var a = primalOffset,\r\n        b = dualOffset,\r\n        c = primalMinor,\r\n        d = dualMinor\r\n    if(e & (1<<j)) {\r\n      a = dualOffset\r\n      b = primalOffset\r\n      c = dualMinor\r\n      d = primalMinor\r\n    }\r\n    a[j] = bounds[0][j]\r\n    b[j] = bounds[1][j]\r\n    if(cubeAxis[j] > 0) {\r\n      c[j] = -1\r\n      d[j] = 0\r\n    } else {\r\n      c[j] = 0\r\n      d[j] = +1\r\n    }\r\n  }\r\n}\r\n\r\nvar CUBE_ENABLE = [0,0,0]\r\nvar DEFAULT_PARAMS = {\r\n  model:      identity,\r\n  view:       identity,\r\n  projection: identity\r\n}\r\n\r\nproto.isOpaque = function() {\r\n  return true\r\n}\r\n\r\nproto.isTransparent = function() {\r\n  return false\r\n}\r\n\r\nproto.drawTransparent = function(params) {}\r\n\r\n\r\nvar PRIMAL_MINOR  = [0,0,0]\r\nvar MIRROR_MINOR  = [0,0,0]\r\nvar PRIMAL_OFFSET = [0,0,0]\r\n\r\nproto.draw = function(params) {\r\n  params = params || DEFAULT_PARAMS\r\n\r\n  var gl = this.gl\r\n\r\n  //Geometry for camera and axes\r\n  var model       = params.model || identity\r\n  var view        = params.view || identity\r\n  var projection  = params.projection || identity\r\n  var bounds      = this.bounds\r\n\r\n  //Unpack axis info\r\n  var cubeParams  = getCubeProperties(model, view, projection, bounds)\r\n  var cubeEdges   = cubeParams.cubeEdges\r\n  var cubeAxis    = cubeParams.axis\r\n\r\n  var cx = view[12]\r\n  var cy = view[13]\r\n  var cz = view[14]\r\n  var cw = view[15]\r\n\r\n  var pixelScaleF = this.pixelRatio * (projection[3]*cx + projection[7]*cy + projection[11]*cz + projection[15]*cw) / gl.drawingBufferHeight\r\n\r\n  for(var i=0; i<3; ++i) {\r\n    this.lastCubeProps.cubeEdges[i] = cubeEdges[i]\r\n    this.lastCubeProps.axis[i] = cubeAxis[i]\r\n  }\r\n\r\n  //Compute axis info\r\n  var lineOffset  = LINE_OFFSET\r\n  for(var i=0; i<3; ++i) {\r\n    computeLineOffset(\r\n      LINE_OFFSET[i],\r\n      i,\r\n      this.bounds,\r\n      cubeEdges,\r\n      cubeAxis)\r\n  }\r\n\r\n  //Set up state parameters\r\n  var gl = this.gl\r\n\r\n  //Draw background first\r\n  var cubeEnable = CUBE_ENABLE\r\n  for(var i=0; i<3; ++i) {\r\n    if(this.backgroundEnable[i]) {\r\n      cubeEnable[i] = cubeAxis[i]\r\n    } else {\r\n      cubeEnable[i] = 0\r\n    }\r\n  }\r\n\r\n  this._background.draw(\r\n    model,\r\n    view,\r\n    projection,\r\n    bounds,\r\n    cubeEnable,\r\n    this.backgroundColor)\r\n\r\n  //Draw lines\r\n  this._lines.bind(\r\n    model,\r\n    view,\r\n    projection,\r\n    this)\r\n\r\n  //First draw grid lines and zero lines\r\n  for(var i=0; i<3; ++i) {\r\n    var x = [0,0,0]\r\n    if(cubeAxis[i] > 0) {\r\n      x[i] = bounds[1][i]\r\n    } else {\r\n      x[i] = bounds[0][i]\r\n    }\r\n\r\n    //Draw grid lines\r\n    for(var j=0; j<2; ++j) {\r\n      var u = (i + 1 + j) % 3\r\n      var v = (i + 1 + (j^1)) % 3\r\n      if(this.gridEnable[u]) {\r\n        this._lines.drawGrid(u, v, this.bounds, x, this.gridColor[u], this.gridWidth[u]*this.pixelRatio)\r\n      }\r\n    }\r\n\r\n    //Draw zero lines (need to do this AFTER all grid lines are drawn)\r\n    for(var j=0; j<2; ++j) {\r\n      var u = (i + 1 + j) % 3\r\n      var v = (i + 1 + (j^1)) % 3\r\n      if(this.zeroEnable[v]) {\r\n        //Check if zero line in bounds\r\n        if(bounds[0][v] <= 0 && bounds[1][v] >= 0) {\r\n          this._lines.drawZero(u, v, this.bounds, x, this.zeroLineColor[v], this.zeroLineWidth[v]*this.pixelRatio)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  //Then draw axis lines and tick marks\r\n  for(var i=0; i<3; ++i) {\r\n\r\n    //Draw axis lines\r\n    if(this.lineEnable[i]) {\r\n      this._lines.drawAxisLine(i, this.bounds, lineOffset[i].primalOffset, this.lineColor[i], this.lineWidth[i]*this.pixelRatio)\r\n    }\r\n    if(this.lineMirror[i]) {\r\n      this._lines.drawAxisLine(i, this.bounds, lineOffset[i].mirrorOffset, this.lineColor[i], this.lineWidth[i]*this.pixelRatio)\r\n    }\r\n\r\n    //Compute minor axes\r\n    var primalMinor = copyVec3(PRIMAL_MINOR, lineOffset[i].primalMinor)\r\n    var mirrorMinor = copyVec3(MIRROR_MINOR, lineOffset[i].mirrorMinor)\r\n    var tickLength  = this.lineTickLength\r\n    var op = 0\r\n    for(var j=0; j<3; ++j) {\r\n      var scaleFactor = pixelScaleF / model[5*j]\r\n      primalMinor[j] *= tickLength[j] * scaleFactor\r\n      mirrorMinor[j] *= tickLength[j] * scaleFactor\r\n    }\r\n\r\n    //Draw axis line ticks\r\n    if(this.lineTickEnable[i]) {\r\n      this._lines.drawAxisTicks(i, lineOffset[i].primalOffset, primalMinor, this.lineTickColor[i], this.lineTickWidth[i]*this.pixelRatio)\r\n    }\r\n    if(this.lineTickMirror[i]) {\r\n      this._lines.drawAxisTicks(i, lineOffset[i].mirrorOffset, mirrorMinor, this.lineTickColor[i], this.lineTickWidth[i]*this.pixelRatio)\r\n    }\r\n  }\r\n  this._lines.unbind()\r\n\r\n  //Draw text sprites\r\n  this._text.bind(\r\n    model,\r\n    view,\r\n    projection,\r\n    this.pixelRatio)\r\n\r\n  for(var i=0; i<3; ++i) {\r\n\r\n    var minor      = lineOffset[i].primalMinor\r\n    var offset     = copyVec3(PRIMAL_OFFSET, lineOffset[i].primalOffset)\r\n\r\n    for(var j=0; j<3; ++j) {\r\n      if(this.lineTickEnable[i]) {\r\n        offset[j] += pixelScaleF * minor[j] * Math.max(this.lineTickLength[j], 0)  / model[5*j]\r\n      }\r\n    }\r\n\r\n    //Draw tick text\r\n    if(this.tickEnable[i]) {\r\n\r\n      //Add tick padding\r\n      for(var j=0; j<3; ++j) {\r\n        offset[j] += pixelScaleF * minor[j] * this.tickPad[j] / model[5*j]\r\n      }\r\n\r\n      //Draw axis\r\n      this._text.drawTicks(\r\n        i,\r\n        this.tickSize[i],\r\n        this.tickAngle[i],\r\n        offset,\r\n        this.tickColor[i])\r\n    }\r\n\r\n    //Draw labels\r\n    if(this.labelEnable[i]) {\r\n\r\n      //Add label padding\r\n      for(var j=0; j<3; ++j) {\r\n        offset[j] += pixelScaleF * minor[j] * this.labelPad[j] / model[5*j]\r\n      }\r\n      offset[i] += 0.5 * (bounds[0][i] + bounds[1][i])\r\n\r\n      //Draw axis\r\n      this._text.drawLabel(\r\n        i,\r\n        this.labelSize[i],\r\n        this.labelAngle[i],\r\n        offset,\r\n        this.labelColor[i])\r\n    }\r\n  }\r\n\r\n  this._text.unbind()\r\n}\r\n\r\nproto.dispose = function() {\r\n  this._text.dispose()\r\n  this._lines.dispose()\r\n  this._background.dispose()\r\n  this._lines = null\r\n  this._text = null\r\n  this._background = null\r\n  this.gl = null\r\n}\r\n\r\nfunction createAxes(gl, options) {\r\n  var axes = new Axes(gl)\r\n  axes.update(options)\r\n  return axes\r\n}\r\n",null]}