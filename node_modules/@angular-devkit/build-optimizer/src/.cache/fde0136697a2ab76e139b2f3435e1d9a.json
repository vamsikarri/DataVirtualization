{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/svg-path-bounds/node_modules/normalize-svg-path/index.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/svg-path-bounds/node_modules/normalize-svg-path/index.js","mtime":1529418312168},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\r\n\r\nmodule.exports = normalize\r\n\r\nvar arcToCurve = require('svg-arc-to-cubic-bezier')\r\n\r\nfunction normalize(path){\r\n  // init state\r\n  var prev\r\n  var result = []\r\n  var bezierX = 0\r\n  var bezierY = 0\r\n  var startX = 0\r\n  var startY = 0\r\n  var quadX = null\r\n  var quadY = null\r\n  var x = 0\r\n  var y = 0\r\n\r\n  for (var i = 0, len = path.length; i < len; i++) {\r\n    var seg = path[i]\r\n    var command = seg[0]\r\n\r\n    switch (command) {\r\n      case 'M':\r\n        startX = seg[1]\r\n        startY = seg[2]\r\n        break\r\n      case 'A':\r\n        var curves = arcToCurve({\r\n          px: x,\r\n          py: y,\r\n          cx: seg[6],\r\n          cy:  seg[7],\r\n          rx: seg[1],\r\n          ry: seg[2],\r\n          xAxisRotation: seg[3],\r\n          largeArcFlag: seg[4],\r\n          sweepFlag: seg[5]\r\n        })\r\n\r\n        // null-curves\r\n        if (!curves.length) continue\r\n\r\n        for (var j = 0, c; j < curves.length; j++) {\r\n          c = curves[j]\r\n          seg = ['C', c.x1, c.y1, c.x2, c.y2, c.x, c.y]\r\n          if (j < curves.length - 1) result.push(seg)\r\n        }\r\n\r\n        break\r\n      case 'S':\r\n        // default control point\r\n        var cx = x\r\n        var cy = y\r\n        if (prev == 'C' || prev == 'S') {\r\n          cx += cx - bezierX // reflect the previous command's control\r\n          cy += cy - bezierY // point relative to the current point\r\n        }\r\n        seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]]\r\n        break\r\n      case 'T':\r\n        if (prev == 'Q' || prev == 'T') {\r\n          quadX = x * 2 - quadX // as with 'S' reflect previous control point\r\n          quadY = y * 2 - quadY\r\n        } else {\r\n          quadX = x\r\n          quadY = y\r\n        }\r\n        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2])\r\n        break\r\n      case 'Q':\r\n        quadX = seg[1]\r\n        quadY = seg[2]\r\n        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4])\r\n        break\r\n      case 'L':\r\n        seg = line(x, y, seg[1], seg[2])\r\n        break\r\n      case 'H':\r\n        seg = line(x, y, seg[1], y)\r\n        break\r\n      case 'V':\r\n        seg = line(x, y, x, seg[1])\r\n        break\r\n      case 'Z':\r\n        seg = line(x, y, startX, startY)\r\n        break\r\n    }\r\n\r\n    // update state\r\n    prev = command\r\n    x = seg[seg.length - 2]\r\n    y = seg[seg.length - 1]\r\n    if (seg.length > 4) {\r\n      bezierX = seg[seg.length - 4]\r\n      bezierY = seg[seg.length - 3]\r\n    } else {\r\n      bezierX = x\r\n      bezierY = y\r\n    }\r\n    result.push(seg)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nfunction line(x1, y1, x2, y2){\r\n  return ['C', x1, y1, x2, y2, x2, y2]\r\n}\r\n\r\nfunction quadratic(x1, y1, cx, cy, x2, y2){\r\n  return [\r\n    'C',\r\n    x1/3 + (2/3) * cx,\r\n    y1/3 + (2/3) * cy,\r\n    x2/3 + (2/3) * cx,\r\n    y2/3 + (2/3) * cy,\r\n    x2,\r\n    y2\r\n  ]\r\n}\r\n",null]}