{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/components/updatemenus/scrollbox.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/components/updatemenus/scrollbox.js","mtime":1529418310666},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = ScrollBox;\n\nvar d3 = require('d3');\n\nvar Color = require('../color');\nvar Drawing = require('../drawing');\n\nvar Lib = require('../../lib');\n\n/**\n * Helper class to setup a scroll box\n *\n * @class\n * @param           gd          Plotly's graph div\n * @param           container   Container to be scroll-boxed (as a D3 selection)\n * @param {string}  id          Id for the clip path to implement the scroll box\n */\nfunction ScrollBox(gd, container, id) {\n    this.gd = gd;\n    this.container = container;\n    this.id = id;\n\n    // See ScrollBox.prototype.enable for further definition\n    this.position = null;  // scrollbox position\n    this.translateX = null;  // scrollbox horizontal translation\n    this.translateY = null;  // scrollbox vertical translation\n    this.hbar = null;  // horizontal scrollbar D3 selection\n    this.vbar = null;  // vertical scrollbar D3 selection\n\n    // <rect> element to capture pointer events\n    this.bg = this.container.selectAll('rect.scrollbox-bg').data([0]);\n\n    this.bg.exit()\n        .on('.drag', null)\n        .on('wheel', null)\n        .remove();\n\n    this.bg.enter().append('rect')\n        .classed('scrollbox-bg', true)\n        .style('pointer-events', 'all')\n        .attr({\n            opacity: 0,\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        });\n}\n\n// scroll bar dimensions\nScrollBox.barWidth = 2;\nScrollBox.barLength = 20;\nScrollBox.barRadius = 2;\nScrollBox.barPad = 1;\nScrollBox.barColor = '#808BA4';\n\n/**\n * If needed, setup a clip path and scrollbars\n *\n * @method\n * @param {Object}  position\n * @param {number}  position.l  Left side position (in pixels)\n * @param {number}  position.t  Top side (in pixels)\n * @param {number}  position.w  Width (in pixels)\n * @param {number}  position.h  Height (in pixels)\n * @param {string}  [position.direction='down']\n *                  Either 'down', 'left', 'right' or 'up'\n * @param {number}  [translateX=0]  Horizontal offset (in pixels)\n * @param {number}  [translateY=0]  Vertical offset (in pixels)\n */\nScrollBox.prototype.enable = function enable(position, translateX, translateY) {\n    var fullLayout = this.gd._fullLayout,\n        fullWidth = fullLayout.width,\n        fullHeight = fullLayout.height;\n\n    // compute position of scrollbox\n    this.position = position;\n\n    var l = this.position.l,\n        w = this.position.w,\n        t = this.position.t,\n        h = this.position.h,\n        direction = this.position.direction,\n        isDown = (direction === 'down'),\n        isLeft = (direction === 'left'),\n        isRight = (direction === 'right'),\n        isUp = (direction === 'up'),\n        boxW = w,\n        boxH = h,\n        boxL, boxR,\n        boxT, boxB;\n\n    if(!isDown && !isLeft && !isRight && !isUp) {\n        this.position.direction = 'down';\n        isDown = true;\n    }\n\n    var isVertical = isDown || isUp;\n    if(isVertical) {\n        boxL = l;\n        boxR = boxL + boxW;\n\n        if(isDown) {\n            // anchor to top side\n            boxT = t;\n            boxB = Math.min(boxT + boxH, fullHeight);\n            boxH = boxB - boxT;\n        }\n        else {\n            // anchor to bottom side\n            boxB = t + boxH;\n            boxT = Math.max(boxB - boxH, 0);\n            boxH = boxB - boxT;\n        }\n    }\n    else {\n        boxT = t;\n        boxB = boxT + boxH;\n\n        if(isLeft) {\n            // anchor to right side\n            boxR = l + boxW;\n            boxL = Math.max(boxR - boxW, 0);\n            boxW = boxR - boxL;\n        }\n        else {\n            // anchor to left side\n            boxL = l;\n            boxR = Math.min(boxL + boxW, fullWidth);\n            boxW = boxR - boxL;\n        }\n    }\n\n    this._box = {\n        l: boxL,\n        t: boxT,\n        w: boxW,\n        h: boxH\n    };\n\n    // compute position of horizontal scroll bar\n    var needsHorizontalScrollBar = (w > boxW),\n        hbarW = ScrollBox.barLength + 2 * ScrollBox.barPad,\n        hbarH = ScrollBox.barWidth + 2 * ScrollBox.barPad,\n        // draw horizontal scrollbar on the bottom side\n        hbarL = l,\n        hbarT = t + h;\n\n    if(hbarT + hbarH > fullHeight) hbarT = fullHeight - hbarH;\n\n    var hbar = this.container.selectAll('rect.scrollbar-horizontal').data(\n            (needsHorizontalScrollBar) ? [0] : []);\n\n    hbar.exit()\n        .on('.drag', null)\n        .remove();\n\n    hbar.enter().append('rect')\n        .classed('scrollbar-horizontal', true)\n        .call(Color.fill, ScrollBox.barColor);\n\n    if(needsHorizontalScrollBar) {\n        this.hbar = hbar.attr({\n            'rx': ScrollBox.barRadius,\n            'ry': ScrollBox.barRadius,\n            'x': hbarL,\n            'y': hbarT,\n            'width': hbarW,\n            'height': hbarH\n        });\n\n        // hbar center moves between hbarXMin and hbarXMin + hbarTranslateMax\n        this._hbarXMin = hbarL + hbarW / 2;\n        this._hbarTranslateMax = boxW - hbarW;\n    }\n    else {\n        delete this.hbar;\n        delete this._hbarXMin;\n        delete this._hbarTranslateMax;\n    }\n\n    // compute position of vertical scroll bar\n    var needsVerticalScrollBar = (h > boxH),\n        vbarW = ScrollBox.barWidth + 2 * ScrollBox.barPad,\n        vbarH = ScrollBox.barLength + 2 * ScrollBox.barPad,\n        // draw vertical scrollbar on the right side\n        vbarL = l + w,\n        vbarT = t;\n\n    if(vbarL + vbarW > fullWidth) vbarL = fullWidth - vbarW;\n\n    var vbar = this.container.selectAll('rect.scrollbar-vertical').data(\n            (needsVerticalScrollBar) ? [0] : []);\n\n    vbar.exit()\n        .on('.drag', null)\n        .remove();\n\n    vbar.enter().append('rect')\n        .classed('scrollbar-vertical', true)\n        .call(Color.fill, ScrollBox.barColor);\n\n    if(needsVerticalScrollBar) {\n        this.vbar = vbar.attr({\n            'rx': ScrollBox.barRadius,\n            'ry': ScrollBox.barRadius,\n            'x': vbarL,\n            'y': vbarT,\n            'width': vbarW,\n            'height': vbarH\n        });\n\n        // vbar center moves between vbarYMin and vbarYMin + vbarTranslateMax\n        this._vbarYMin = vbarT + vbarH / 2;\n        this._vbarTranslateMax = boxH - vbarH;\n    }\n    else {\n        delete this.vbar;\n        delete this._vbarYMin;\n        delete this._vbarTranslateMax;\n    }\n\n    // setup a clip path (if scroll bars are needed)\n    var clipId = this.id,\n        clipL = boxL - 0.5,\n        clipR = (needsVerticalScrollBar) ? boxR + vbarW + 0.5 : boxR + 0.5,\n        clipT = boxT - 0.5,\n        clipB = (needsHorizontalScrollBar) ? boxB + hbarH + 0.5 : boxB + 0.5;\n\n    var clipPath = fullLayout._topdefs.selectAll('#' + clipId)\n        .data((needsHorizontalScrollBar || needsVerticalScrollBar) ? [0] : []);\n\n    clipPath.exit().remove();\n\n    clipPath.enter()\n        .append('clipPath').attr('id', clipId)\n        .append('rect');\n\n    if(needsHorizontalScrollBar || needsVerticalScrollBar) {\n        this._clipRect = clipPath.select('rect').attr({\n            x: Math.floor(clipL),\n            y: Math.floor(clipT),\n            width: Math.ceil(clipR) - Math.floor(clipL),\n            height: Math.ceil(clipB) - Math.floor(clipT)\n        });\n\n        this.container.call(Drawing.setClipUrl, clipId);\n\n        this.bg.attr({\n            x: l,\n            y: t,\n            width: w,\n            height: h\n        });\n    }\n    else {\n        this.bg.attr({\n            width: 0,\n            height: 0\n        });\n        this.container\n            .on('wheel', null)\n            .on('.drag', null)\n            .call(Drawing.setClipUrl, null);\n        delete this._clipRect;\n    }\n\n    // set up drag listeners (if scroll bars are needed)\n    if(needsHorizontalScrollBar || needsVerticalScrollBar) {\n        var onBoxDrag = d3.behavior.drag()\n            .on('dragstart', function() {\n                d3.event.sourceEvent.preventDefault();\n            })\n            .on('drag', this._onBoxDrag.bind(this));\n\n        this.container\n            .on('wheel', null)\n            .on('wheel', this._onBoxWheel.bind(this))\n            .on('.drag', null)\n            .call(onBoxDrag);\n\n        var onBarDrag = d3.behavior.drag()\n            .on('dragstart', function() {\n                d3.event.sourceEvent.preventDefault();\n                d3.event.sourceEvent.stopPropagation();\n            })\n            .on('drag', this._onBarDrag.bind(this));\n\n        if(needsHorizontalScrollBar) {\n            this.hbar\n                .on('.drag', null)\n                .call(onBarDrag);\n        }\n\n        if(needsVerticalScrollBar) {\n            this.vbar\n                .on('.drag', null)\n                .call(onBarDrag);\n        }\n    }\n\n    // set scrollbox translation\n    this.setTranslate(translateX, translateY);\n};\n\n/**\n * If present, remove clip-path and scrollbars\n *\n * @method\n */\nScrollBox.prototype.disable = function disable() {\n    if(this.hbar || this.vbar) {\n        this.bg.attr({\n            width: 0,\n            height: 0\n        });\n        this.container\n            .on('wheel', null)\n            .on('.drag', null)\n            .call(Drawing.setClipUrl, null);\n        delete this._clipRect;\n    }\n\n    if(this.hbar) {\n        this.hbar.on('.drag', null);\n        this.hbar.remove();\n        delete this.hbar;\n        delete this._hbarXMin;\n        delete this._hbarTranslateMax;\n    }\n\n    if(this.vbar) {\n        this.vbar.on('.drag', null);\n        this.vbar.remove();\n        delete this.vbar;\n        delete this._vbarYMin;\n        delete this._vbarTranslateMax;\n    }\n};\n\n/**\n * Handles scroll box drag events\n *\n * @method\n */\nScrollBox.prototype._onBoxDrag = function onBarDrag() {\n    var translateX = this.translateX,\n        translateY = this.translateY;\n\n    if(this.hbar) {\n        translateX -= d3.event.dx;\n    }\n\n    if(this.vbar) {\n        translateY -= d3.event.dy;\n    }\n\n    this.setTranslate(translateX, translateY);\n};\n\n/**\n * Handles scroll box wheel events\n *\n * @method\n */\nScrollBox.prototype._onBoxWheel = function onBarWheel() {\n    var translateX = this.translateX,\n        translateY = this.translateY;\n\n    if(this.hbar) {\n        translateX += d3.event.deltaY;\n    }\n\n    if(this.vbar) {\n        translateY += d3.event.deltaY;\n    }\n\n    this.setTranslate(translateX, translateY);\n};\n\n/**\n * Handles scroll bar drag events\n *\n * @method\n */\nScrollBox.prototype._onBarDrag = function onBarDrag() {\n    var translateX = this.translateX,\n        translateY = this.translateY;\n\n    if(this.hbar) {\n        var xMin = translateX + this._hbarXMin,\n            xMax = xMin + this._hbarTranslateMax,\n            x = Lib.constrain(d3.event.x, xMin, xMax),\n            xf = (x - xMin) / (xMax - xMin);\n\n        var translateXMax = this.position.w - this._box.w;\n\n        translateX = xf * translateXMax;\n    }\n\n    if(this.vbar) {\n        var yMin = translateY + this._vbarYMin,\n            yMax = yMin + this._vbarTranslateMax,\n            y = Lib.constrain(d3.event.y, yMin, yMax),\n            yf = (y - yMin) / (yMax - yMin);\n\n        var translateYMax = this.position.h - this._box.h;\n\n        translateY = yf * translateYMax;\n    }\n\n    this.setTranslate(translateX, translateY);\n};\n\n/**\n * Set clip path and scroll bar translate transform\n *\n * @method\n * @param {number}  [translateX=0]  Horizontal offset (in pixels)\n * @param {number}  [translateY=0]  Vertical offset (in pixels)\n */\nScrollBox.prototype.setTranslate = function setTranslate(translateX, translateY) {\n    // store translateX and translateY (needed by mouse event handlers)\n    var translateXMax = this.position.w - this._box.w,\n        translateYMax = this.position.h - this._box.h;\n\n    translateX = Lib.constrain(translateX || 0, 0, translateXMax);\n    translateY = Lib.constrain(translateY || 0, 0, translateYMax);\n\n    this.translateX = translateX;\n    this.translateY = translateY;\n\n    this.container.call(Drawing.setTranslate,\n        this._box.l - this.position.l - translateX,\n        this._box.t - this.position.t - translateY);\n\n    if(this._clipRect) {\n        this._clipRect.attr({\n            x: Math.floor(this.position.l + translateX - 0.5),\n            y: Math.floor(this.position.t + translateY - 0.5)\n        });\n    }\n\n    if(this.hbar) {\n        var xf = translateX / translateXMax;\n\n        this.hbar.call(Drawing.setTranslate,\n            translateX + xf * this._hbarTranslateMax,\n            translateY);\n    }\n\n    if(this.vbar) {\n        var yf = translateY / translateYMax;\n\n        this.vbar.call(Drawing.setTranslate,\n            translateX,\n            translateY + yf * this._vbarTranslateMax);\n    }\n};\n",null]}