{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scatterternary/defaults.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scatterternary/defaults.js","mtime":1529418310745},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar constants = require('../scatter/constants');\nvar subTypes = require('../scatter/subtypes');\nvar handleMarkerDefaults = require('../scatter/marker_defaults');\nvar handleLineDefaults = require('../scatter/line_defaults');\nvar handleLineShapeDefaults = require('../scatter/line_shape_defaults');\nvar handleTextDefaults = require('../scatter/text_defaults');\nvar handleFillColorDefaults = require('../scatter/fillcolor_defaults');\n\nvar attributes = require('./attributes');\n\n\nmodule.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n    }\n\n    var a = coerce('a'),\n        b = coerce('b'),\n        c = coerce('c'),\n        len;\n\n    // allow any one array to be missing, len is the minimum length of those\n    // present. Note that after coerce data_array's are either Arrays (which\n    // are truthy even if empty) or undefined. As in scatter, an empty array\n    // is different from undefined, because it can signify that this data is\n    // not known yet but expected in the future\n    if(a) {\n        len = a.length;\n        if(b) {\n            len = Math.min(len, b.length);\n            if(c) len = Math.min(len, c.length);\n        }\n        else if(c) len = Math.min(len, c.length);\n        else len = 0;\n    }\n    else if(b && c) {\n        len = Math.min(b.length, c.length);\n    }\n\n    if(!len) {\n        traceOut.visible = false;\n        return;\n    }\n\n    traceOut._length = len;\n\n    coerce('sum');\n\n    coerce('text');\n    coerce('hovertext');\n\n    var defaultMode = len < constants.PTS_LINESONLY ? 'lines+markers' : 'lines';\n    coerce('mode', defaultMode);\n\n    if(subTypes.hasLines(traceOut)) {\n        handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce);\n        handleLineShapeDefaults(traceIn, traceOut, coerce);\n        coerce('connectgaps');\n    }\n\n    if(subTypes.hasMarkers(traceOut)) {\n        handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, {gradient: true});\n    }\n\n    if(subTypes.hasText(traceOut)) {\n        handleTextDefaults(traceIn, traceOut, layout, coerce);\n    }\n\n    var dfltHoverOn = [];\n\n    if(subTypes.hasMarkers(traceOut) || subTypes.hasText(traceOut)) {\n        coerce('cliponaxis');\n        coerce('marker.maxdisplayed');\n        dfltHoverOn.push('points');\n    }\n\n    coerce('fill');\n    if(traceOut.fill !== 'none') {\n        handleFillColorDefaults(traceIn, traceOut, defaultColor, coerce);\n        if(!subTypes.hasLines(traceOut)) handleLineShapeDefaults(traceIn, traceOut, coerce);\n    }\n\n    if(traceOut.fill === 'tonext' || traceOut.fill === 'toself') {\n        dfltHoverOn.push('fills');\n    }\n    coerce('hoveron', dfltHoverOn.join('+') || 'points');\n\n    Lib.coerceSelectionMarkerOpacity(traceOut, coerce);\n};\n",null]}