{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/components/errorbars/compute_error.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/components/errorbars/compute_error.js","mtime":1529418310612},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\n/**\n * Error bar computing function generator\n *\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\n * entries result in undefined error magnitudes.\n *\n * @param {object} opts error bar attributes\n *\n * @return {function} :\n *      @param {numeric} dataPt data point from where to compute the error magnitude\n *      @param {number} index index of dataPt in its corresponding data array\n *      @return {array}\n *        - error[0] : error magnitude in the negative direction\n *        - error[1] : \" \" \" \" positive \"\n */\nmodule.exports = function makeComputeError(opts) {\n    var type = opts.type,\n        symmetric = opts.symmetric;\n\n    if(type === 'data') {\n        var array = opts.array || [];\n\n        if(symmetric) {\n            return function computeError(dataPt, index) {\n                var val = +(array[index]);\n                return [val, val];\n            };\n        }\n        else {\n            var arrayminus = opts.arrayminus || [];\n            return function computeError(dataPt, index) {\n                var val = +array[index];\n                var valMinus = +arrayminus[index];\n                // in case one is present and the other is missing, fill in 0\n                // so we still see the present one. Mostly useful during manual\n                // data entry.\n                if(!isNaN(val) || !isNaN(valMinus)) {\n                    return [valMinus || 0, val || 0];\n                }\n                return [NaN, NaN];\n            };\n        }\n    }\n    else {\n        var computeErrorValue = makeComputeErrorValue(type, opts.value),\n            computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);\n\n        if(symmetric || opts.valueminus === undefined) {\n            return function computeError(dataPt) {\n                var val = computeErrorValue(dataPt);\n                return [val, val];\n            };\n        }\n        else {\n            return function computeError(dataPt) {\n                return [\n                    computeErrorValueMinus(dataPt),\n                    computeErrorValue(dataPt)\n                ];\n            };\n        }\n    }\n};\n\n/**\n * Compute error bar magnitude (for all types except data)\n *\n * @param {string} type error bar type\n * @param {numeric} value error bar value\n *\n * @return {function} :\n *      @param {numeric} dataPt\n */\nfunction makeComputeErrorValue(type, value) {\n    if(type === 'percent') {\n        return function(dataPt) {\n            return Math.abs(dataPt * value / 100);\n        };\n    }\n    if(type === 'constant') {\n        return function() {\n            return Math.abs(value);\n        };\n    }\n    if(type === 'sqrt') {\n        return function(dataPt) {\n            return Math.sqrt(Math.abs(dataPt));\n        };\n    }\n}\n",null]}