{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-surface3d/surface.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/gl-surface3d/surface.js","mtime":1529418308697},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["'use strict'\r\n\r\nmodule.exports = createSurfacePlot\r\n\r\nvar bits = require('bit-twiddle')\r\nvar createBuffer = require('gl-buffer')\r\nvar createVAO = require('gl-vao')\r\nvar createTexture = require('gl-texture2d')\r\nvar pool = require('typedarray-pool')\r\nvar colormap = require('colormap')\r\nvar ops = require('ndarray-ops')\r\nvar pack = require('ndarray-pack')\r\nvar ndarray = require('ndarray')\r\nvar surfaceNets = require('surface-nets')\r\nvar multiply = require('gl-mat4/multiply')\r\nvar invert = require('gl-mat4/invert')\r\nvar bsearch = require('binary-search-bounds')\r\nvar gradient = require('ndarray-gradient')\r\nvar shaders = require('./lib/shaders')\r\n\r\nvar createShader = shaders.createShader\r\nvar createContourShader = shaders.createContourShader\r\nvar createPickShader = shaders.createPickShader\r\nvar createPickContourShader = shaders.createPickContourShader\r\n\r\nvar SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3)\r\n\r\nvar IDENTITY = [\r\n  1, 0, 0, 0,\r\n  0, 1, 0, 0,\r\n  0, 0, 1, 0,\r\n  0, 0, 0, 1 ]\r\n\r\nvar QUAD = [\r\n  [0, 0],\r\n  [0, 1],\r\n  [1, 0],\r\n  [1, 1],\r\n  [1, 0],\r\n  [0, 1]\r\n]\r\n\r\nvar PERMUTATIONS = [\r\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n]\r\n\r\n;(function () {\r\n  for (var i = 0; i < 3; ++i) {\r\n    var p = PERMUTATIONS[i]\r\n    var u = (i + 1) % 3\r\n    var v = (i + 2) % 3\r\n    p[u + 0] = 1\r\n    p[v + 3] = 1\r\n    p[i + 6] = 1\r\n  }\r\n})()\r\n\r\nfunction SurfacePickResult (position, index, uv, level, dataCoordinate) {\r\n  this.position = position\r\n  this.index = index\r\n  this.uv = uv\r\n  this.level = level\r\n  this.dataCoordinate = dataCoordinate\r\n}\r\n\r\nvar N_COLORS = 256\r\n\r\nfunction genColormap (name) {\r\n  var x = pack([colormap({\r\n    colormap: name,\r\n    nshades: N_COLORS,\r\n    format: 'rgba'\r\n  }).map(function (c) {\r\n    return [c[0], c[1], c[2], 255 * c[3]]\r\n  })])\r\n  ops.divseq(x, 255.0)\r\n  return x\r\n}\r\n\r\nfunction SurfacePlot (\r\n  gl,\r\n  shape,\r\n  bounds,\r\n  shader,\r\n  pickShader,\r\n  coordinates,\r\n  vao,\r\n  colorMap,\r\n  contourShader,\r\n  contourPickShader,\r\n  contourBuffer,\r\n  contourVAO,\r\n  dynamicBuffer,\r\n  dynamicVAO) {\r\n  this.gl = gl\r\n  this.shape = shape\r\n  this.bounds = bounds\r\n  this.intensityBounds = [];\r\n\r\n  this._shader = shader\r\n  this._pickShader = pickShader\r\n  this._coordinateBuffer = coordinates\r\n  this._vao = vao\r\n  this._colorMap = colorMap\r\n\r\n  this._contourShader = contourShader\r\n  this._contourPickShader = contourPickShader\r\n  this._contourBuffer = contourBuffer\r\n  this._contourVAO = contourVAO\r\n  this._contourOffsets = [[], [], []]\r\n  this._contourCounts = [[], [], []]\r\n  this._vertexCount = 0\r\n\r\n  this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0])\r\n\r\n  this._dynamicBuffer = dynamicBuffer\r\n  this._dynamicVAO = dynamicVAO\r\n  this._dynamicOffsets = [0, 0, 0]\r\n  this._dynamicCounts = [0, 0, 0]\r\n\r\n  this.contourWidth = [ 1, 1, 1 ]\r\n  this.contourLevels = [[1], [1], [1]]\r\n  this.contourTint = [0, 0, 0]\r\n  this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]]\r\n\r\n  this.showContour = true\r\n  this.showSurface = true\r\n\r\n  this.enableHighlight = [true, true, true]\r\n  this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]\r\n  this.highlightTint = [ 1, 1, 1 ]\r\n  this.highlightLevel = [-1, -1, -1]\r\n\r\n  // Dynamic contour options\r\n  this.enableDynamic = [ true, true, true ]\r\n  this.dynamicLevel = [ NaN, NaN, NaN ]\r\n  this.dynamicColor = [ [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1] ]\r\n  this.dynamicTint = [ 1, 1, 1 ]\r\n  this.dynamicWidth = [ 1, 1, 1 ]\r\n\r\n  this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]]\r\n  this.surfaceProject = [ false, false, false ]\r\n  this.contourProject = [[ false, false, false ],\r\n    [ false, false, false ],\r\n    [ false, false, false ]]\r\n\r\n  this.colorBounds = [ false, false ]\r\n\r\n  // Store xyz fields, need this for picking\r\n  this._field = [\r\n    ndarray(pool.mallocFloat(1024), [0, 0]),\r\n    ndarray(pool.mallocFloat(1024), [0, 0]),\r\n    ndarray(pool.mallocFloat(1024), [0, 0]) ]\r\n\r\n  this.pickId = 1\r\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]]\r\n\r\n  this.snapToData = false\r\n\r\n  this.opacity = 1.0\r\n\r\n  this.lightPosition = [10, 10000, 0]\r\n  this.ambientLight = 0.8\r\n  this.diffuseLight = 0.8\r\n  this.specularLight = 2.0\r\n  this.roughness = 0.5\r\n  this.fresnel = 1.5\r\n  this.vertexColor = 0;\r\n\r\n  this.dirty = true\r\n}\r\n\r\nvar proto = SurfacePlot.prototype\r\n\r\nproto.isTransparent = function () {\r\n  return this.opacity < 1\r\n}\r\n\r\nproto.isOpaque = function () {\r\n  if (this.opacity >= 1) {\r\n    return true\r\n  }\r\n  for (var i = 0; i < 3; ++i) {\r\n    if (this._contourCounts[i].length > 0 || this._dynamicCounts[i] > 0) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nproto.pickSlots = 1\r\n\r\nproto.setPickBase = function (id) {\r\n  this.pickId = id\r\n}\r\n\r\nvar ZERO_VEC = [0, 0, 0]\r\n\r\nvar PROJECT_DATA = {\r\n  showSurface: false,\r\n  showContour: false,\r\n  projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],\r\n  clipBounds: [\r\n    [[0, 0, 0], [0, 0, 0]],\r\n    [[0, 0, 0], [0, 0, 0]],\r\n    [[0, 0, 0], [0, 0, 0]]]\r\n}\r\n\r\nfunction computeProjectionData (camera, obj) {\r\n  var i, j, k\r\n\r\n  // Compute cube properties\r\n  var cubeAxis = (obj.axes && obj.axes.lastCubeProps.axis) || ZERO_VEC\r\n\r\n  var showSurface = obj.showSurface\r\n  var showContour = obj.showContour\r\n\r\n  for (i = 0; i < 3; ++i) {\r\n    showSurface = showSurface || obj.surfaceProject[i]\r\n    for (j = 0; j < 3; ++j) {\r\n      showContour = showContour || obj.contourProject[i][j]\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < 3; ++i) {\r\n    // Construct projection onto axis\r\n    var axisSquish = PROJECT_DATA.projections[i]\r\n    for (j = 0; j < 16; ++j) {\r\n      axisSquish[j] = 0\r\n    }\r\n    for (j = 0; j < 4; ++j) {\r\n      axisSquish[5 * j] = 1\r\n    }\r\n    axisSquish[5 * i] = 0\r\n    axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i]\r\n    multiply(axisSquish, camera.model, axisSquish)\r\n\r\n    var nclipBounds = PROJECT_DATA.clipBounds[i]\r\n    for (k = 0; k < 2; ++k) {\r\n      for (j = 0; j < 3; ++j) {\r\n        nclipBounds[k][j] = camera.clipBounds[k][j]\r\n      }\r\n    }\r\n    nclipBounds[0][i] = -1e8\r\n    nclipBounds[1][i] = 1e8\r\n  }\r\n\r\n  PROJECT_DATA.showSurface = showSurface\r\n  PROJECT_DATA.showContour = showContour\r\n\r\n  return PROJECT_DATA\r\n}\r\n\r\nvar UNIFORMS = {\r\n  model: IDENTITY,\r\n  view: IDENTITY,\r\n  projection: IDENTITY,\r\n  inverseModel: IDENTITY.slice(),\r\n  lowerBound: [0, 0, 0],\r\n  upperBound: [0, 0, 0],\r\n  colorMap: 0,\r\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\r\n  height: 0.0,\r\n  contourTint: 0,\r\n  contourColor: [0, 0, 0, 1],\r\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\r\n  zOffset: -1e-4,\r\n  kambient: 1,\r\n  kdiffuse: 1,\r\n  kspecular: 1,\r\n  lightPosition: [1000, 1000, 1000],\r\n  eyePosition: [0, 0, 0],\r\n  roughness: 1,\r\n  fresnel: 1,\r\n  opacity: 1,\r\n  vertexColor: 0\r\n}\r\n\r\nvar MATRIX_INVERSE = IDENTITY.slice()\r\nvar DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1]\r\n\r\nfunction drawCore (params, transparent) {\r\n  params = params || {}\r\n  var gl = this.gl\r\n\r\n  gl.disable(gl.CULL_FACE)\r\n\r\n  this._colorMap.bind(0)\r\n\r\n  var uniforms = UNIFORMS\r\n  uniforms.model = params.model || IDENTITY\r\n  uniforms.view = params.view || IDENTITY\r\n  uniforms.projection = params.projection || IDENTITY\r\n  uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]]\r\n  uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]]\r\n  uniforms.contourColor = this.contourColor[0]\r\n\r\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model)\r\n\r\n  for (var i = 0; i < 2; ++i) {\r\n    var clipClamped = uniforms.clipBounds[i]\r\n    for (var j = 0; j < 3; ++j) {\r\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8)\r\n    }\r\n  }\r\n\r\n  uniforms.kambient = this.ambientLight\r\n  uniforms.kdiffuse = this.diffuseLight\r\n  uniforms.kspecular = this.specularLight\r\n\r\n  uniforms.roughness = this.roughness\r\n  uniforms.fresnel = this.fresnel\r\n  uniforms.opacity = this.opacity\r\n\r\n  uniforms.height = 0.0\r\n  uniforms.permutation = DEFAULT_PERM\r\n\r\n  uniforms.vertexColor = this.vertexColor\r\n\r\n  // Compute camera matrix inverse\r\n  var invCameraMatrix = MATRIX_INVERSE\r\n  multiply(invCameraMatrix, uniforms.view, uniforms.model)\r\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix)\r\n  invert(invCameraMatrix, invCameraMatrix)\r\n\r\n  for (i = 0; i < 3; ++i) {\r\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15]\r\n  }\r\n\r\n  var w = invCameraMatrix[15]\r\n  for (i = 0; i < 3; ++i) {\r\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3]\r\n  }\r\n  for (i = 0; i < 3; ++i) {\r\n    var s = invCameraMatrix[12 + i]\r\n    for (j = 0; j < 3; ++j) {\r\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j]\r\n    }\r\n    uniforms.lightPosition[i] = s / w\r\n  }\r\n\r\n  var projectData = computeProjectionData(uniforms, this)\r\n\r\n  if (projectData.showSurface && (transparent === (this.opacity < 1))) {\r\n    // Set up uniforms\r\n    this._shader.bind()\r\n    this._shader.uniforms = uniforms\r\n\r\n    // Draw it\r\n    this._vao.bind()\r\n\r\n    if (this.showSurface && this._vertexCount) {\r\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\r\n    }\r\n\r\n    // Draw projections of surface\r\n    for (i = 0; i < 3; ++i) {\r\n      if (!this.surfaceProject[i] || !this.vertexCount) {\r\n        continue\r\n      }\r\n      this._shader.uniforms.model = projectData.projections[i]\r\n      this._shader.uniforms.clipBounds = projectData.clipBounds[i]\r\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\r\n    }\r\n\r\n    this._vao.unbind()\r\n  }\r\n\r\n  if (projectData.showContour && !transparent) {\r\n    var shader = this._contourShader\r\n\r\n    // Don't apply lighting to contours\r\n    uniforms.kambient = 1.0\r\n    uniforms.kdiffuse = 0.0\r\n    uniforms.kspecular = 0.0\r\n    uniforms.opacity = 1.0\r\n\r\n    shader.bind()\r\n    shader.uniforms = uniforms\r\n\r\n    // Draw contour lines\r\n    var vao = this._contourVAO\r\n    vao.bind()\r\n\r\n    // Draw contour levels\r\n    for (i = 0; i < 3; ++i) {\r\n      shader.uniforms.permutation = PERMUTATIONS[i]\r\n      gl.lineWidth(this.contourWidth[i])\r\n\r\n      for (j = 0; j < this.contourLevels[i].length; ++j) {\r\n        if (!this._contourCounts[i][j]) {\r\n          continue\r\n        }\r\n        if (j === this.highlightLevel[i]) {\r\n          shader.uniforms.contourColor = this.highlightColor[i]\r\n          shader.uniforms.contourTint = this.highlightTint[i]\r\n        } else if (j === 0 || (j - 1) === this.highlightLevel[i]) {\r\n          shader.uniforms.contourColor = this.contourColor[i]\r\n          shader.uniforms.contourTint = this.contourTint[i]\r\n        }\r\n        shader.uniforms.height = this.contourLevels[i][j]\r\n        vao.draw(gl.LINES, this._contourCounts[i][j], this._contourOffsets[i][j])\r\n      }\r\n    }\r\n\r\n    // Draw projections of surface\r\n    for (i = 0; i < 3; ++i) {\r\n      shader.uniforms.model = projectData.projections[i]\r\n      shader.uniforms.clipBounds = projectData.clipBounds[i]\r\n      for (j = 0; j < 3; ++j) {\r\n        if (!this.contourProject[i][j]) {\r\n          continue\r\n        }\r\n        shader.uniforms.permutation = PERMUTATIONS[j]\r\n        gl.lineWidth(this.contourWidth[j])\r\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\r\n          if (k === this.highlightLevel[j]) {\r\n            shader.uniforms.contourColor = this.highlightColor[j]\r\n            shader.uniforms.contourTint = this.highlightTint[j]\r\n          } else if (k === 0 || (k - 1) === this.highlightLevel[j]) {\r\n            shader.uniforms.contourColor = this.contourColor[j]\r\n            shader.uniforms.contourTint = this.contourTint[j]\r\n          }\r\n          shader.uniforms.height = this.contourLevels[j][k]\r\n          vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k])\r\n        }\r\n      }\r\n    }\r\n    vao.unbind()\r\n\r\n    // Draw dynamic contours\r\n    vao = this._dynamicVAO\r\n    vao.bind()\r\n\r\n    // Draw contour levels\r\n    for (i = 0; i < 3; ++i) {\r\n      if (this._dynamicCounts[i] === 0) {\r\n        continue\r\n      }\r\n\r\n      shader.uniforms.model = uniforms.model\r\n      shader.uniforms.clipBounds = uniforms.clipBounds\r\n      shader.uniforms.permutation = PERMUTATIONS[i]\r\n      gl.lineWidth(this.dynamicWidth[i])\r\n\r\n      shader.uniforms.contourColor = this.dynamicColor[i]\r\n      shader.uniforms.contourTint = this.dynamicTint[i]\r\n      shader.uniforms.height = this.dynamicLevel[i]\r\n      vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i])\r\n\r\n      for (j = 0; j < 3; ++j) {\r\n        if (!this.contourProject[j][i]) {\r\n          continue\r\n        }\r\n\r\n        shader.uniforms.model = projectData.projections[j]\r\n        shader.uniforms.clipBounds = projectData.clipBounds[j]\r\n        vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i])\r\n      }\r\n    }\r\n\r\n    vao.unbind()\r\n  }\r\n}\r\n\r\nproto.draw = function (params) {\r\n  return drawCore.call(this, params, false)\r\n}\r\n\r\nproto.drawTransparent = function (params) {\r\n  return drawCore.call(this, params, true)\r\n}\r\n\r\nvar PICK_UNIFORMS = {\r\n  model: IDENTITY,\r\n  view: IDENTITY,\r\n  projection: IDENTITY,\r\n  inverseModel: IDENTITY,\r\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\r\n  height: 0.0,\r\n  shape: [0, 0],\r\n  pickId: 0,\r\n  lowerBound: [0, 0, 0],\r\n  upperBound: [0, 0, 0],\r\n  zOffset: 0.0,\r\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\r\n  lightPosition: [0, 0, 0],\r\n  eyePosition: [0, 0, 0]\r\n}\r\n\r\nproto.drawPick = function (params) {\r\n  params = params || {}\r\n  var gl = this.gl\r\n  gl.disable(gl.CULL_FACE)\r\n\r\n  var uniforms = PICK_UNIFORMS\r\n  uniforms.model = params.model || IDENTITY\r\n  uniforms.view = params.view || IDENTITY\r\n  uniforms.projection = params.projection || IDENTITY\r\n  uniforms.shape = this._field[2].shape\r\n  uniforms.pickId = this.pickId / 255.0\r\n  uniforms.lowerBound = this.bounds[0]\r\n  uniforms.upperBound = this.bounds[1]\r\n  uniforms.permutation = DEFAULT_PERM\r\n\r\n  for (var i = 0; i < 2; ++i) {\r\n    var clipClamped = uniforms.clipBounds[i]\r\n    for (var j = 0; j < 3; ++j) {\r\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8)\r\n    }\r\n  }\r\n\r\n  var projectData = computeProjectionData(uniforms, this)\r\n\r\n  if (projectData.showSurface) {\r\n    // Set up uniforms\r\n    this._pickShader.bind()\r\n    this._pickShader.uniforms = uniforms\r\n\r\n    // Draw it\r\n    this._vao.bind()\r\n    this._vao.draw(gl.TRIANGLES, this._vertexCount)\r\n\r\n    // Draw projections of surface\r\n    for (i = 0; i < 3; ++i) {\r\n      if (!this.surfaceProject[i]) {\r\n        continue\r\n      }\r\n      this._pickShader.uniforms.model = projectData.projections[i]\r\n      this._pickShader.uniforms.clipBounds = projectData.clipBounds[i]\r\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\r\n    }\r\n\r\n    this._vao.unbind()\r\n  }\r\n\r\n  if (projectData.showContour) {\r\n    var shader = this._contourPickShader\r\n\r\n    shader.bind()\r\n    shader.uniforms = uniforms\r\n\r\n    var vao = this._contourVAO\r\n    vao.bind()\r\n\r\n    for (j = 0; j < 3; ++j) {\r\n      gl.lineWidth(this.contourWidth[j])\r\n      shader.uniforms.permutation = PERMUTATIONS[j]\r\n      for (i = 0; i < this.contourLevels[j].length; ++i) {\r\n        if (this._contourCounts[j][i]) {\r\n          shader.uniforms.height = this.contourLevels[j][i]\r\n          vao.draw(gl.LINES, this._contourCounts[j][i], this._contourOffsets[j][i])\r\n        }\r\n      }\r\n    }\r\n\r\n    // Draw projections of surface\r\n    for (i = 0; i < 3; ++i) {\r\n      shader.uniforms.model = projectData.projections[i]\r\n      shader.uniforms.clipBounds = projectData.clipBounds[i]\r\n\r\n      for (j = 0; j < 3; ++j) {\r\n        if (!this.contourProject[i][j]) {\r\n          continue\r\n        }\r\n\r\n        shader.uniforms.permutation = PERMUTATIONS[j]\r\n        gl.lineWidth(this.contourWidth[j])\r\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\r\n          if (this._contourCounts[j][k]) {\r\n            shader.uniforms.height = this.contourLevels[j][k]\r\n            vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k])\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    vao.unbind()\r\n  }\r\n}\r\n\r\nproto.pick = function (selection) {\r\n  if (!selection) {\r\n    return null\r\n  }\r\n\r\n  if (selection.id !== this.pickId) {\r\n    return null\r\n  }\r\n\r\n  var shape = this._field[2].shape\r\n\r\n  var result = this._pickResult\r\n\r\n  // Compute uv coordinate\r\n  var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16.0) / 255.0\r\n  var ix = Math.floor(x)\r\n  var fx = x - ix\r\n\r\n  var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16.0) / 255.0\r\n  var iy = Math.floor(y)\r\n  var fy = y - iy\r\n\r\n  ix += 1\r\n  iy += 1\r\n\r\n  // Compute xyz coordinate\r\n  var pos = result.position\r\n  pos[0] = pos[1] = pos[2] = 0\r\n  for (var dx = 0; dx < 2; ++dx) {\r\n    var s = dx ? fx : 1.0 - fx\r\n    for (var dy = 0; dy < 2; ++dy) {\r\n      var t = dy ? fy : 1.0 - fy\r\n\r\n      var r = ix + dx\r\n      var c = iy + dy\r\n      var w = s * t\r\n\r\n      for (var i = 0; i < 3; ++i) {\r\n        pos[i] += this._field[i].get(r, c) * w\r\n      }\r\n    }\r\n  }\r\n\r\n  // Find closest level\r\n  var levelIndex = this._pickResult.level\r\n  for (var j = 0; j < 3; ++j) {\r\n    levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j])\r\n    if (levelIndex[j] < 0) {\r\n      if (this.contourLevels[j].length > 0) {\r\n        levelIndex[j] = 0\r\n      }\r\n    } else if (levelIndex[j] < this.contourLevels[j].length - 1) {\r\n      var a = this.contourLevels[j][levelIndex[j]]\r\n      var b = this.contourLevels[j][levelIndex[j] + 1]\r\n      if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {\r\n        levelIndex[j] += 1\r\n      }\r\n    }\r\n  }\r\n\r\n  result.index[0] = fx < 0.5 ? ix : (ix + 1)\r\n  result.index[1] = fy < 0.5 ? iy : (iy + 1)\r\n\r\n  result.uv[0] = x / shape[0]\r\n  result.uv[1] = y / shape[1]\r\n\r\n  for (i = 0; i < 3; ++i) {\r\n    result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1])\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nfunction padField (nfield, field) {\r\n  var shape = field.shape.slice()\r\n  var nshape = nfield.shape.slice()\r\n\r\n  // Center\r\n  ops.assign(nfield.lo(1, 1).hi(shape[0], shape[1]), field)\r\n\r\n  // Edges\r\n  ops.assign(nfield.lo(1).hi(shape[0], 1),\r\n    field.hi(shape[0], 1))\r\n  ops.assign(nfield.lo(1, nshape[1] - 1).hi(shape[0], 1),\r\n    field.lo(0, shape[1] - 1).hi(shape[0], 1))\r\n  ops.assign(nfield.lo(0, 1).hi(1, shape[1]),\r\n    field.hi(1))\r\n  ops.assign(nfield.lo(nshape[0] - 1, 1).hi(1, shape[1]),\r\n    field.lo(shape[0] - 1))\r\n  // Corners\r\n  nfield.set(0, 0, field.get(0, 0))\r\n  nfield.set(0, nshape[1] - 1, field.get(0, shape[1] - 1))\r\n  nfield.set(nshape[0] - 1, 0, field.get(shape[0] - 1, 0))\r\n  nfield.set(nshape[0] - 1, nshape[1] - 1, field.get(shape[0] - 1, shape[1] - 1))\r\n}\r\n\r\nfunction handleArray (param, ctor) {\r\n  if (Array.isArray(param)) {\r\n    return [ ctor(param[0]), ctor(param[1]), ctor(param[2]) ]\r\n  }\r\n  return [ ctor(param), ctor(param), ctor(param) ]\r\n}\r\n\r\nfunction toColor (x) {\r\n  if (Array.isArray(x)) {\r\n    if (x.length === 3) {\r\n      return [x[0], x[1], x[2], 1]\r\n    }\r\n    return [x[0], x[1], x[2], x[3]]\r\n  }\r\n  return [0, 0, 0, 1]\r\n}\r\n\r\nfunction handleColor (param) {\r\n  if (Array.isArray(param)) {\r\n    if (Array.isArray(param)) {\r\n      return [\r\n        toColor(param[0]),\r\n        toColor(param[1]),\r\n        toColor(param[2]) ]\r\n    } else {\r\n      var c = toColor(param)\r\n      return [\r\n        c.slice(),\r\n        c.slice(),\r\n        c.slice() ]\r\n    }\r\n  }\r\n}\r\n\r\nproto.update = function (params) {\r\n  params = params || {}\r\n\r\n  this.dirty = true\r\n\r\n  if ('contourWidth' in params) {\r\n    this.contourWidth = handleArray(params.contourWidth, Number)\r\n  }\r\n  if ('showContour' in params) {\r\n    this.showContour = handleArray(params.showContour, Boolean)\r\n  }\r\n  if ('showSurface' in params) {\r\n    this.showSurface = !!params.showSurface\r\n  }\r\n  if ('contourTint' in params) {\r\n    this.contourTint = handleArray(params.contourTint, Boolean)\r\n  }\r\n  if ('contourColor' in params) {\r\n    this.contourColor = handleColor(params.contourColor)\r\n  }\r\n  if ('contourProject' in params) {\r\n    this.contourProject = handleArray(params.contourProject, function (x) {\r\n      return handleArray(x, Boolean)\r\n    })\r\n  }\r\n  if ('surfaceProject' in params) {\r\n    this.surfaceProject = params.surfaceProject\r\n  }\r\n  if ('dynamicColor' in params) {\r\n    this.dynamicColor = handleColor(params.dynamicColor)\r\n  }\r\n  if ('dynamicTint' in params) {\r\n    this.dynamicTint = handleArray(params.dynamicTint, Number)\r\n  }\r\n  if ('dynamicWidth' in params) {\r\n    this.dynamicWidth = handleArray(params.dynamicWidth, Number)\r\n  }\r\n  if ('opacity' in params) {\r\n    this.opacity = params.opacity\r\n  }\r\n  if ('colorBounds' in params) {\r\n    this.colorBounds = params.colorBounds\r\n  }\r\n  if ('vertexColor' in params) {\r\n    this.vertexColor = params.vertexColor ? 1 : 0;\r\n  }\r\n\r\n  var field = params.field || (params.coords && params.coords[2]) || null\r\n  var levelsChanged = false\r\n\r\n  if (!field) {\r\n    if (this._field[2].shape[0] || this._field[2].shape[2]) {\r\n      field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2)\r\n    } else {\r\n      field = this._field[2].hi(0, 0)\r\n    }\r\n  }\r\n\r\n  // Update field\r\n  if ('field' in params || 'coords' in params) {\r\n    var fsize = (field.shape[0] + 2) * (field.shape[1] + 2)\r\n\r\n    // Resize if necessary\r\n    if (fsize > this._field[2].data.length) {\r\n      pool.freeFloat(this._field[2].data)\r\n      this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize))\r\n    }\r\n\r\n    // Pad field\r\n    this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2])\r\n    padField(this._field[2], field)\r\n\r\n    // Save shape of field\r\n    this.shape = field.shape.slice()\r\n    var shape = this.shape\r\n\r\n    // Resize coordinate fields if necessary\r\n    for (var i = 0; i < 2; ++i) {\r\n      if (this._field[2].size > this._field[i].data.length) {\r\n        pool.freeFloat(this._field[i].data)\r\n        this._field[i].data = pool.mallocFloat(this._field[2].size)\r\n      }\r\n      this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2])\r\n    }\r\n\r\n    // Generate x/y coordinates\r\n    if (params.coords) {\r\n      var coords = params.coords\r\n      if (!Array.isArray(coords) || coords.length !== 3) {\r\n        throw new Error('gl-surface: invalid coordinates for x/y')\r\n      }\r\n      for (i = 0; i < 2; ++i) {\r\n        var coord = coords[i]\r\n        for (j = 0; j < 2; ++j) {\r\n          if (coord.shape[j] !== shape[j]) {\r\n            throw new Error('gl-surface: coords have incorrect shape')\r\n          }\r\n        }\r\n        padField(this._field[i], coord)\r\n      }\r\n    } else if (params.ticks) {\r\n      var ticks = params.ticks\r\n      if (!Array.isArray(ticks) || ticks.length !== 2) {\r\n        throw new Error('gl-surface: invalid ticks')\r\n      }\r\n      for (i = 0; i < 2; ++i) {\r\n        var tick = ticks[i]\r\n        if (Array.isArray(tick) || tick.length) {\r\n          tick = ndarray(tick)\r\n        }\r\n        if (tick.shape[0] !== shape[i]) {\r\n          throw new Error('gl-surface: invalid tick length')\r\n        }\r\n        // Make a copy view of the tick array\r\n        var tick2 = ndarray(tick.data, shape)\r\n        tick2.stride[i] = tick.stride[0]\r\n        tick2.stride[i ^ 1] = 0\r\n\r\n        // Fill in field array\r\n        padField(this._field[i], tick2)\r\n      }\r\n    } else {\r\n      for (i = 0; i < 2; ++i) {\r\n        var offset = [0, 0]\r\n        offset[i] = 1\r\n        this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0)\r\n      }\r\n      this._field[0].set(0, 0, 0)\r\n      for (var j = 0; j < shape[0]; ++j) {\r\n        this._field[0].set(j + 1, 0, j)\r\n      }\r\n      this._field[0].set(shape[0] + 1, 0, shape[0] - 1)\r\n      this._field[1].set(0, 0, 0)\r\n      for (j = 0; j < shape[1]; ++j) {\r\n        this._field[1].set(0, j + 1, j)\r\n      }\r\n      this._field[1].set(0, shape[1] + 1, shape[1] - 1)\r\n    }\r\n\r\n    // Save shape\r\n    var fields = this._field\r\n\r\n    // Compute surface normals\r\n    var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2])\r\n    for (i = 0; i < 3; ++i) {\r\n      gradient(dfields.pick(i), fields[i], 'mirror')\r\n    }\r\n    var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3])\r\n    for (i = 0; i < shape[0] + 2; ++i) {\r\n      for (j = 0; j < shape[1] + 2; ++j) {\r\n        var dxdu = dfields.get(0, i, j, 0)\r\n        var dxdv = dfields.get(0, i, j, 1)\r\n        var dydu = dfields.get(1, i, j, 0)\r\n        var dydv = dfields.get(1, i, j, 1)\r\n        var dzdu = dfields.get(2, i, j, 0)\r\n        var dzdv = dfields.get(2, i, j, 1)\r\n\r\n        var nx = dydu * dzdv - dydv * dzdu\r\n        var ny = dzdu * dxdv - dzdv * dxdu\r\n        var nz = dxdu * dydv - dxdv * dydu\r\n\r\n        var nl = Math.sqrt(nx * nx + ny * ny + nz * nz)\r\n        if (nl < 1e-8) {\r\n          nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz))\r\n          if (nl < 1e-8) {\r\n            nz = 1.0\r\n            ny = nx = 0.0\r\n            nl = 1.0\r\n          } else {\r\n            nl = 1.0 / nl\r\n          }\r\n        } else {\r\n          nl = 1.0 / Math.sqrt(nl)\r\n        }\r\n\r\n        normals.set(i, j, 0, nx * nl)\r\n        normals.set(i, j, 1, ny * nl)\r\n        normals.set(i, j, 2, nz * nl)\r\n      }\r\n    }\r\n    pool.free(dfields.data)\r\n\r\n    // Initialize surface\r\n    var lo = [ Infinity, Infinity, Infinity ]\r\n    var hi = [ -Infinity, -Infinity, -Infinity ]\r\n    var lo_intensity = Infinity\r\n    var hi_intensity = -Infinity\r\n    var count = (shape[0] - 1) * (shape[1] - 1) * 6\r\n    var tverts = pool.mallocFloat(bits.nextPow2(10 * count))\r\n    var tptr = 0\r\n    var vertexCount = 0\r\n    for (i = 0; i < shape[0] - 1; ++i) {\r\n      j_loop:\r\n      for (j = 0; j < shape[1] - 1; ++j) {\r\n        // Test for NaNs\r\n        for (var dx = 0; dx < 2; ++dx) {\r\n          for (var dy = 0; dy < 2; ++dy) {\r\n            for (var k = 0; k < 3; ++k) {\r\n              var f = this._field[k].get(1 + i + dx, 1 + j + dy)\r\n              if (isNaN(f) || !isFinite(f)) {\r\n                continue j_loop\r\n              }\r\n            }\r\n          }\r\n        }\r\n        for (k = 0; k < 6; ++k) {\r\n          var r = i + QUAD[k][0]\r\n          var c = j + QUAD[k][1]\r\n\r\n          var tx = this._field[0].get(r + 1, c + 1)\r\n          var ty = this._field[1].get(r + 1, c + 1)\r\n          f = this._field[2].get(r + 1, c + 1)\r\n          var vf = f\r\n          nx = normals.get(r + 1, c + 1, 0)\r\n          ny = normals.get(r + 1, c + 1, 1)\r\n          nz = normals.get(r + 1, c + 1, 2)\r\n\r\n          if (params.intensity) {\r\n            vf = params.intensity.get(r, c)\r\n          }\r\n\r\n          tverts[tptr++] = r\r\n          tverts[tptr++] = c\r\n          tverts[tptr++] = tx\r\n          tverts[tptr++] = ty\r\n          tverts[tptr++] = f\r\n          tverts[tptr++] = 0\r\n          tverts[tptr++] = vf\r\n          tverts[tptr++] = nx\r\n          tverts[tptr++] = ny\r\n          tverts[tptr++] = nz\r\n\r\n          lo[0] = Math.min(lo[0], tx)\r\n          lo[1] = Math.min(lo[1], ty)\r\n          lo[2] = Math.min(lo[2], f)\r\n          lo_intensity = Math.min(lo_intensity, vf)\r\n\r\n          hi[0] = Math.max(hi[0], tx)\r\n          hi[1] = Math.max(hi[1], ty)\r\n          hi[2] = Math.max(hi[2], f)\r\n          hi_intensity = Math.max(hi_intensity, vf)\r\n\r\n          vertexCount += 1\r\n        }\r\n      }\r\n    }\r\n\r\n    if (params.intensityBounds) {\r\n      lo_intensity = +params.intensityBounds[0]\r\n      hi_intensity = +params.intensityBounds[1]\r\n    }\r\n\r\n    // Scale all vertex intensities\r\n    for (i = 6; i < tptr; i += 10) {\r\n      tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity)\r\n    }\r\n\r\n    this._vertexCount = vertexCount\r\n    this._coordinateBuffer.update(tverts.subarray(0, tptr))\r\n    pool.freeFloat(tverts)\r\n    pool.free(normals.data)\r\n\r\n    // Update bounds\r\n    this.bounds = [lo, hi]\r\n\r\n    // Save intensity\r\n    this.intensity = params.intensity || this._field[2]\r\n\r\n    if(this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {\r\n        levelsChanged = true\r\n    }\r\n\r\n    // Save intensity bound\r\n    this.intensityBounds = [lo_intensity, hi_intensity]\r\n  }\r\n\r\n  // Update level crossings\r\n  if ('levels' in params) {\r\n    var levels = params.levels\r\n    if (!Array.isArray(levels[0])) {\r\n      levels = [ [], [], levels ]\r\n    } else {\r\n      levels = levels.slice()\r\n    }\r\n    for (i = 0; i < 3; ++i) {\r\n      levels[i] = levels[i].slice()\r\n      levels.sort(function (a, b) {\r\n        return a - b\r\n      })\r\n    }\r\n    change_test:\r\n    for (i = 0; i < 3; ++i) {\r\n      if (levels[i].length !== this.contourLevels[i].length) {\r\n        levelsChanged = true\r\n        break\r\n      }\r\n      for (j = 0; j < levels[i].length; ++j) {\r\n        if (levels[i][j] !== this.contourLevels[i][j]) {\r\n          levelsChanged = true\r\n          break change_test\r\n        }\r\n      }\r\n    }\r\n    this.contourLevels = levels\r\n  }\r\n\r\n  if (levelsChanged) {\r\n    fields = this._field\r\n    shape = this.shape\r\n\r\n    // Update contour lines\r\n    var contourVerts = []\r\n\r\n    for (var dim = 0; dim < 3; ++dim) {\r\n      levels = this.contourLevels[dim]\r\n      var levelOffsets = []\r\n      var levelCounts = []\r\n\r\n      var parts = [0, 0, 0]\r\n\r\n      for (i = 0; i < levels.length; ++i) {\r\n        var graph = surfaceNets(this._field[dim], levels[i])\r\n        levelOffsets.push((contourVerts.length / 5) | 0)\r\n        vertexCount = 0\r\n\r\n        edge_loop:\r\n        for (j = 0; j < graph.cells.length; ++j) {\r\n          var e = graph.cells[j]\r\n          for (k = 0; k < 2; ++k) {\r\n            var p = graph.positions[e[k]]\r\n\r\n            var x = p[0]\r\n            var ix = Math.floor(x) | 0\r\n            var fx = x - ix\r\n\r\n            var y = p[1]\r\n            var iy = Math.floor(y) | 0\r\n            var fy = y - iy\r\n\r\n            var hole = false\r\n            dd_loop:\r\n            for (var dd = 0; dd < 3; ++dd) {\r\n              parts[dd] = 0.0\r\n              var iu = (dim + dd + 1) % 3\r\n              for (dx = 0; dx < 2; ++dx) {\r\n                var s = dx ? fx : 1.0 - fx\r\n                r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0\r\n                for (dy = 0; dy < 2; ++dy) {\r\n                  var t = dy ? fy : 1.0 - fy\r\n                  c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0\r\n\r\n                  if (dd < 2) {\r\n                    f = this._field[iu].get(r, c)\r\n                  } else {\r\n                    f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0])\r\n                  }\r\n                  if (!isFinite(f) || isNaN(f)) {\r\n                    hole = true\r\n                    break dd_loop\r\n                  }\r\n\r\n                  var w = s * t\r\n                  parts[dd] += w * f\r\n                }\r\n              }\r\n            }\r\n\r\n            if (!hole) {\r\n              contourVerts.push(parts[0], parts[1], p[0], p[1], parts[2])\r\n              vertexCount += 1\r\n            } else {\r\n              if (k > 0) {\r\n                // If we already added first edge, pop off verts\r\n                for (var l = 0; l < 5; ++l) {\r\n                  contourVerts.pop()\r\n                }\r\n                vertexCount -= 1\r\n              }\r\n              continue edge_loop\r\n            }\r\n          }\r\n        }\r\n        levelCounts.push(vertexCount)\r\n      }\r\n\r\n      // Store results\r\n      this._contourOffsets[dim] = levelOffsets\r\n      this._contourCounts[dim] = levelCounts\r\n    }\r\n\r\n    var floatBuffer = pool.mallocFloat(contourVerts.length)\r\n    for (i = 0; i < contourVerts.length; ++i) {\r\n      floatBuffer[i] = contourVerts[i]\r\n    }\r\n    this._contourBuffer.update(floatBuffer)\r\n    pool.freeFloat(floatBuffer)\r\n  }\r\n\r\n  if (params.colormap) {\r\n    this._colorMap.setPixels(genColormap(params.colormap))\r\n  }\r\n}\r\n\r\nproto.dispose = function () {\r\n  this._shader.dispose()\r\n  this._vao.dispose()\r\n  this._coordinateBuffer.dispose()\r\n  this._colorMap.dispose()\r\n  this._contourBuffer.dispose()\r\n  this._contourVAO.dispose()\r\n  this._contourShader.dispose()\r\n  this._contourPickShader.dispose()\r\n  this._dynamicBuffer.dispose()\r\n  this._dynamicVAO.dispose()\r\n  for (var i = 0; i < 3; ++i) {\r\n    pool.freeFloat(this._field[i].data)\r\n  }\r\n}\r\n\r\nproto.highlight = function (selection) {\r\n  if (!selection) {\r\n    this._dynamicCounts = [0, 0, 0]\r\n    this.dyanamicLevel = [NaN, NaN, NaN]\r\n    this.highlightLevel = [-1, -1, -1]\r\n    return\r\n  }\r\n\r\n  for (var i = 0; i < 3; ++i) {\r\n    if (this.enableHighlight[i]) {\r\n      this.highlightLevel[i] = selection.level[i]\r\n    } else {\r\n      this.highlightLevel[i] = -1\r\n    }\r\n  }\r\n\r\n  var levels\r\n  if (this.snapToData) {\r\n    levels = selection.dataCoordinate\r\n  } else {\r\n    levels = selection.position\r\n  }\r\n  if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) &&\r\n    (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) &&\r\n    (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {\r\n    return\r\n  }\r\n\r\n  var vertexCount = 0\r\n  var shape = this.shape\r\n  var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1])\r\n\r\n  for (var d = 0; d < 3; ++d) {\r\n    if (!this.enableDynamic[d]) {\r\n      this.dynamicLevel[d] = NaN\r\n      this._dynamicCounts[d] = 0\r\n      continue\r\n    }\r\n\r\n    this.dynamicLevel[d] = levels[d]\r\n\r\n    var u = (d + 1) % 3\r\n    var v = (d + 2) % 3\r\n\r\n    var f = this._field[d]\r\n    var g = this._field[u]\r\n    var h = this._field[v]\r\n    var intensity = this.intensity\r\n\r\n    var graph = surfaceNets(f, levels[d])\r\n    var edges = graph.cells\r\n    var positions = graph.positions\r\n\r\n    this._dynamicOffsets[d] = vertexCount\r\n\r\n    for (i = 0; i < edges.length; ++i) {\r\n      var e = edges[i]\r\n      for (var j = 0; j < 2; ++j) {\r\n        var p = positions[e[j]]\r\n\r\n        var x = +p[0]\r\n        var ix = x | 0\r\n        var jx = Math.min(ix + 1, shape[0]) | 0\r\n        var fx = x - ix\r\n        var hx = 1.0 - fx\r\n\r\n        var y = +p[1]\r\n        var iy = y | 0\r\n        var jy = Math.min(iy + 1, shape[1]) | 0\r\n        var fy = y - iy\r\n        var hy = 1.0 - fy\r\n\r\n        var w00 = hx * hy\r\n        var w01 = hx * fy\r\n        var w10 = fx * hy\r\n        var w11 = fx * fy\r\n\r\n        var cu = w00 * g.get(ix, iy) +\r\n          w01 * g.get(ix, jy) +\r\n          w10 * g.get(jx, iy) +\r\n          w11 * g.get(jx, jy)\r\n\r\n        var cv = w00 * h.get(ix, iy) +\r\n          w01 * h.get(ix, jy) +\r\n          w10 * h.get(jx, iy) +\r\n          w11 * h.get(jx, jy)\r\n\r\n        if (isNaN(cu) || isNaN(cv)) {\r\n          if (j) {\r\n            vertexCount -= 1\r\n          }\r\n          break\r\n        }\r\n\r\n        scratchBuffer[2 * vertexCount + 0] = cu\r\n        scratchBuffer[2 * vertexCount + 1] = cv\r\n\r\n        vertexCount += 1\r\n      }\r\n    }\r\n\r\n    this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d]\r\n  }\r\n\r\n  this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount))\r\n  pool.freeFloat(scratchBuffer)\r\n}\r\n\r\nfunction createSurfacePlot (params) {\r\n  var gl = params.gl\r\n  var shader = createShader(gl)\r\n  var pickShader = createPickShader(gl)\r\n  var contourShader = createContourShader(gl)\r\n  var contourPickShader = createPickContourShader(gl)\r\n\r\n  var coordinateBuffer = createBuffer(gl)\r\n  var vao = createVAO(gl, [\r\n    { buffer: coordinateBuffer,\r\n      size: 4,\r\n      stride: SURFACE_VERTEX_SIZE,\r\n      offset: 0\r\n    },\r\n    { buffer: coordinateBuffer,\r\n      size: 3,\r\n      stride: SURFACE_VERTEX_SIZE,\r\n      offset: 16\r\n    },\r\n    {\r\n      buffer: coordinateBuffer,\r\n      size: 3,\r\n      stride: SURFACE_VERTEX_SIZE,\r\n      offset: 28\r\n    }\r\n  ])\r\n\r\n  var contourBuffer = createBuffer(gl)\r\n  var contourVAO = createVAO(gl, [\r\n    {\r\n      buffer: contourBuffer,\r\n      size: 4,\r\n      stride: 20,\r\n      offset: 0\r\n    },\r\n    {\r\n      buffer: contourBuffer,\r\n      size: 1,\r\n      stride: 20,\r\n      offset: 16\r\n    }\r\n  ])\r\n\r\n  var dynamicBuffer = createBuffer(gl)\r\n  var dynamicVAO = createVAO(gl, [\r\n    {\r\n      buffer: dynamicBuffer,\r\n      size: 2,\r\n      type: gl.FLOAT\r\n    }])\r\n\r\n  var cmap = createTexture(gl, 1, N_COLORS, gl.RGBA, gl.UNSIGNED_BYTE)\r\n  cmap.minFilter = gl.LINEAR\r\n  cmap.magFilter = gl.LINEAR\r\n\r\n  var surface = new SurfacePlot(\r\n    gl,\r\n    [0, 0],\r\n    [[0, 0, 0], [0, 0, 0]],\r\n    shader,\r\n    pickShader,\r\n    coordinateBuffer,\r\n    vao,\r\n    cmap,\r\n    contourShader,\r\n    contourPickShader,\r\n    contourBuffer,\r\n    contourVAO,\r\n    dynamicBuffer,\r\n    dynamicVAO\r\n  )\r\n\r\n  var nparams = {\r\n    levels: [[], [], []]\r\n  }\r\n  for (var id in params) {\r\n    nparams[id] = params[id]\r\n  }\r\n  nparams.colormap = nparams.colormap || 'jet'\r\n\r\n  surface.update(nparams)\r\n\r\n  return surface\r\n}\r\n",null]}