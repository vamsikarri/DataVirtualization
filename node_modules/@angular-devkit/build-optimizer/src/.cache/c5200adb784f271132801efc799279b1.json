{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/cartesian/select.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/plots/cartesian/select.js","mtime":1529418310685},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar polybool = require('polybooljs');\n\nvar Registry = require('../../registry');\nvar Color = require('../../components/color');\nvar Fx = require('../../components/fx');\n\nvar polygon = require('../../lib/polygon');\nvar throttle = require('../../lib/throttle');\nvar makeEventData = require('../../components/fx/helpers').makeEventData;\nvar getFromId = require('./axis_ids').getFromId;\nvar sortModules = require('../sort_modules').sortModules;\n\nvar constants = require('./constants');\nvar MINSELECT = constants.MINSELECT;\n\nvar filteredPolygon = polygon.filter;\nvar polygonTester = polygon.tester;\nvar multipolygonTester = polygon.multitester;\n\nfunction getAxId(ax) { return ax._id; }\n\nfunction prepSelect(e, startX, startY, dragOptions, mode) {\n    var gd = dragOptions.gd;\n    var fullLayout = gd._fullLayout;\n    var zoomLayer = fullLayout._zoomlayer;\n    var dragBBox = dragOptions.element.getBoundingClientRect();\n    var plotinfo = dragOptions.plotinfo;\n    var xs = plotinfo.xaxis._offset;\n    var ys = plotinfo.yaxis._offset;\n    var x0 = startX - dragBBox.left;\n    var y0 = startY - dragBBox.top;\n    var x1 = x0;\n    var y1 = y0;\n    var path0 = 'M' + x0 + ',' + y0;\n    var pw = dragOptions.xaxes[0]._length;\n    var ph = dragOptions.yaxes[0]._length;\n    var xAxisIds = dragOptions.xaxes.map(getAxId);\n    var yAxisIds = dragOptions.yaxes.map(getAxId);\n    var allAxes = dragOptions.xaxes.concat(dragOptions.yaxes);\n    var subtract = e.altKey;\n\n    var filterPoly, testPoly, mergedPolygons, currentPolygon;\n    var i, cd, trace, searchInfo, eventData;\n\n    var selectingOnSameSubplot = (\n        fullLayout._lastSelectedSubplot &&\n        fullLayout._lastSelectedSubplot === plotinfo.id\n    );\n\n    if(\n        selectingOnSameSubplot &&\n        (e.shiftKey || e.altKey) &&\n        (plotinfo.selection && plotinfo.selection.polygons) &&\n        !dragOptions.polygons\n    ) {\n        // take over selection polygons from prev mode, if any\n        dragOptions.polygons = plotinfo.selection.polygons;\n        dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n    } else if(\n        (!e.shiftKey && !e.altKey) ||\n        ((e.shiftKey || e.altKey) && !plotinfo.selection)\n    ) {\n        // create new polygons, if shift mode or selecting across different subplots\n        plotinfo.selection = {};\n        plotinfo.selection.polygons = dragOptions.polygons = [];\n        plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n    }\n\n    // clear selection outline when selecting a different subplot\n    if(!selectingOnSameSubplot) {\n        clearSelect(zoomLayer);\n        fullLayout._lastSelectedSubplot = plotinfo.id;\n    }\n\n    if(mode === 'lasso') {\n        filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n    }\n\n    var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data([1, 2]);\n\n    outlines.enter()\n        .append('path')\n        .attr('class', function(d) { return 'select-outline select-outline-' + d + ' select-outline-' + plotinfo.id; })\n        .attr('transform', 'translate(' + xs + ', ' + ys + ')')\n        .attr('d', path0 + 'Z');\n\n    var corners = zoomLayer.append('path')\n        .attr('class', 'zoombox-corners')\n        .style({\n            fill: Color.background,\n            stroke: Color.defaultLine,\n            'stroke-width': 1\n        })\n        .attr('transform', 'translate(' + xs + ', ' + ys + ')')\n        .attr('d', 'M0,0Z');\n\n\n    // find the traces to search for selection points\n    var searchTraces = [];\n    var throttleID = fullLayout._uid + constants.SELECTID;\n    var selection = [];\n\n    for(i = 0; i < gd.calcdata.length; i++) {\n        cd = gd.calcdata[i];\n        trace = cd[0].trace;\n\n        if(trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n\n        if(dragOptions.subplot) {\n            if(\n                trace.subplot === dragOptions.subplot ||\n                trace.geo === dragOptions.subplot\n            ) {\n                searchTraces.push({\n                    _module: trace._module,\n                    cd: cd,\n                    xaxis: dragOptions.xaxes[0],\n                    yaxis: dragOptions.yaxes[0]\n                });\n            }\n        } else if(\n            trace.type === 'splom' &&\n            // FIXME: make sure we don't have more than single axis for splom\n            trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]\n        ) {\n            searchTraces.push({\n                _module: trace._module,\n                cd: cd,\n                xaxis: dragOptions.xaxes[0],\n                yaxis: dragOptions.yaxes[0]\n            });\n        } else {\n            if(xAxisIds.indexOf(trace.xaxis) === -1) continue;\n            if(yAxisIds.indexOf(trace.yaxis) === -1) continue;\n\n            searchTraces.push({\n                _module: trace._module,\n                cd: cd,\n                xaxis: getFromId(gd, trace.xaxis),\n                yaxis: getFromId(gd, trace.yaxis)\n            });\n        }\n    }\n\n    function axValue(ax) {\n        var index = (ax._id.charAt(0) === 'y') ? 1 : 0;\n        return function(v) { return ax.p2d(v[index]); };\n    }\n\n    function ascending(a, b) { return a - b; }\n\n    // allow subplots to override fillRangeItems routine\n    var fillRangeItems;\n\n    if(plotinfo.fillRangeItems) {\n        fillRangeItems = plotinfo.fillRangeItems;\n    } else {\n        if(mode === 'select') {\n            fillRangeItems = function(eventData, poly) {\n                var ranges = eventData.range = {};\n\n                for(i = 0; i < allAxes.length; i++) {\n                    var ax = allAxes[i];\n                    var axLetter = ax._id.charAt(0);\n\n                    ranges[ax._id] = [\n                        ax.p2d(poly[axLetter + 'min']),\n                        ax.p2d(poly[axLetter + 'max'])\n                    ].sort(ascending);\n                }\n            };\n        } else {\n            fillRangeItems = function(eventData, poly, filterPoly) {\n                var dataPts = eventData.lassoPoints = {};\n\n                for(i = 0; i < allAxes.length; i++) {\n                    var ax = allAxes[i];\n                    dataPts[ax._id] = filterPoly.filtered.map(axValue(ax));\n                }\n            };\n        }\n    }\n\n    dragOptions.moveFn = function(dx0, dy0) {\n        x1 = Math.max(0, Math.min(pw, dx0 + x0));\n        y1 = Math.max(0, Math.min(ph, dy0 + y0));\n\n        var dx = Math.abs(x1 - x0),\n            dy = Math.abs(y1 - y0);\n\n        if(mode === 'select') {\n            var direction = fullLayout.selectdirection;\n\n            if(fullLayout.selectdirection === 'any') {\n                if(dy < Math.min(dx * 0.6, MINSELECT)) direction = 'h';\n                else if(dx < Math.min(dy * 0.6, MINSELECT)) direction = 'v';\n                else direction = 'd';\n            }\n            else {\n                direction = fullLayout.selectdirection;\n            }\n\n            if(direction === 'h') {\n                // horizontal motion: make a vertical box\n                currentPolygon = [[x0, 0], [x0, ph], [x1, ph], [x1, 0]];\n                currentPolygon.xmin = Math.min(x0, x1);\n                currentPolygon.xmax = Math.max(x0, x1);\n                currentPolygon.ymin = Math.min(0, ph);\n                currentPolygon.ymax = Math.max(0, ph);\n                // extras to guide users in keeping a straight selection\n                corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) +\n                    'h-4v' + (2 * MINSELECT) + 'h4Z' +\n                    'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) +\n                    'h4v' + (2 * MINSELECT) + 'h-4Z');\n\n            }\n            else if(direction === 'v') {\n                // vertical motion: make a horizontal box\n                currentPolygon = [[0, y0], [0, y1], [pw, y1], [pw, y0]];\n                currentPolygon.xmin = Math.min(0, pw);\n                currentPolygon.xmax = Math.max(0, pw);\n                currentPolygon.ymin = Math.min(y0, y1);\n                currentPolygon.ymax = Math.max(y0, y1);\n                corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin +\n                    'v-4h' + (2 * MINSELECT) + 'v4Z' +\n                    'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) +\n                    'v4h' + (2 * MINSELECT) + 'v-4Z');\n            }\n            else if(direction === 'd') {\n                // diagonal motion\n                currentPolygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n                currentPolygon.xmin = Math.min(x0, x1);\n                currentPolygon.xmax = Math.max(x0, x1);\n                currentPolygon.ymin = Math.min(y0, y1);\n                currentPolygon.ymax = Math.max(y0, y1);\n                corners.attr('d', 'M0,0Z');\n            }\n        }\n        else if(mode === 'lasso') {\n            filterPoly.addPt([x1, y1]);\n            currentPolygon = filterPoly.filtered;\n        }\n\n        // create outline & tester\n        if(dragOptions.polygons && dragOptions.polygons.length) {\n            mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n            currentPolygon.subtract = subtract;\n            testPoly = multipolygonTester(dragOptions.polygons.concat([currentPolygon]));\n        }\n        else {\n            mergedPolygons = [currentPolygon];\n            testPoly = polygonTester(currentPolygon);\n        }\n\n        // draw selection\n        var paths = [];\n        for(i = 0; i < mergedPolygons.length; i++) {\n            var ppts = mergedPolygons[i];\n            paths.push(ppts.join('L') + 'L' + ppts[0]);\n        }\n        outlines\n            .attr('d', 'M' + paths.join('M') + 'Z');\n\n        throttle.throttle(\n            throttleID,\n            constants.SELECTDELAY,\n            function() {\n                selection = [];\n\n                var thisSelection, traceSelections = [], traceSelection;\n                for(i = 0; i < searchTraces.length; i++) {\n                    searchInfo = searchTraces[i];\n\n                    traceSelection = searchInfo._module.selectPoints(searchInfo, testPoly);\n                    traceSelections.push(traceSelection);\n\n                    thisSelection = fillSelectionItem(traceSelection, searchInfo);\n\n                    if(selection.length) {\n                        for(var j = 0; j < thisSelection.length; j++) {\n                            selection.push(thisSelection[j]);\n                        }\n                    }\n                    else selection = thisSelection;\n                }\n\n                eventData = {points: selection};\n                updateSelectedState(gd, searchTraces, eventData);\n                fillRangeItems(eventData, currentPolygon, filterPoly);\n                dragOptions.gd.emit('plotly_selecting', eventData);\n            }\n        );\n    };\n\n    dragOptions.clickFn = function(numClicks, evt) {\n        corners.remove();\n\n        throttle.done(throttleID).then(function() {\n            throttle.clear(throttleID);\n            if(numClicks === 2) {\n                // clear selection on doubleclick\n                outlines.remove();\n                for(i = 0; i < searchTraces.length; i++) {\n                    searchInfo = searchTraces[i];\n                    searchInfo._module.selectPoints(searchInfo, false);\n                }\n\n                updateSelectedState(gd, searchTraces);\n                gd.emit('plotly_deselect', null);\n            }\n            else {\n                // TODO: remove in v2 - this was probably never intended to work as it does,\n                // but in case anyone depends on it we don't want to break it now.\n                gd.emit('plotly_selected', undefined);\n            }\n\n            Fx.click(gd, evt);\n        });\n    };\n\n    dragOptions.doneFn = function() {\n        corners.remove();\n\n        throttle.done(throttleID).then(function() {\n            throttle.clear(throttleID);\n            dragOptions.gd.emit('plotly_selected', eventData);\n\n            if(currentPolygon && dragOptions.polygons) {\n                // save last polygons\n                currentPolygon.subtract = subtract;\n                dragOptions.polygons.push(currentPolygon);\n\n                // we have to keep reference to arrays container\n                dragOptions.mergedPolygons.length = 0;\n                [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n            }\n        });\n    };\n}\n\nfunction updateSelectedState(gd, searchTraces, eventData) {\n    var i, j, searchInfo, trace;\n\n    if(eventData) {\n        var pts = eventData.points || [];\n\n        for(i = 0; i < searchTraces.length; i++) {\n            trace = searchTraces[i].cd[0].trace;\n            trace.selectedpoints = [];\n            trace._input.selectedpoints = [];\n        }\n\n        for(i = 0; i < pts.length; i++) {\n            var pt = pts[i];\n            var data = pt.data;\n            var fullData = pt.fullData;\n\n            if(pt.pointIndices) {\n                [].push.apply(data.selectedpoints, pt.pointIndices);\n                [].push.apply(fullData.selectedpoints, pt.pointIndices);\n            } else {\n                data.selectedpoints.push(pt.pointIndex);\n                fullData.selectedpoints.push(pt.pointIndex);\n            }\n        }\n    }\n    else {\n        for(i = 0; i < searchTraces.length; i++) {\n            trace = searchTraces[i].cd[0].trace;\n            delete trace.selectedpoints;\n            delete trace._input.selectedpoints;\n        }\n    }\n\n    // group searchInfo traces by trace modules\n    var lookup = {};\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n\n        var name = searchInfo._module.name;\n        if(lookup[name]) {\n            lookup[name].push(searchInfo);\n        } else {\n            lookup[name] = [searchInfo];\n        }\n    }\n\n    var keys = Object.keys(lookup).sort(sortModules);\n\n    for(i = 0; i < keys.length; i++) {\n        var items = lookup[keys[i]];\n        var len = items.length;\n        var item0 = items[0];\n        var trace0 = item0.cd[0].trace;\n        var _module = item0._module;\n        var styleSelection = _module.styleOnSelect || _module.style;\n\n        if(Registry.traceIs(trace0, 'regl')) {\n            // plot regl traces per module\n            var cds = new Array(len);\n            for(j = 0; j < len; j++) {\n                cds[j] = items[j].cd;\n            }\n            styleSelection(gd, cds);\n        } else {\n            // plot svg trace per trace\n            for(j = 0; j < len; j++) {\n                styleSelection(gd, items[j].cd);\n            }\n        }\n    }\n}\n\nfunction mergePolygons(list, poly, subtract) {\n    var res;\n\n    if(subtract) {\n        res = polybool.difference({\n            regions: list,\n            inverted: false\n        }, {\n            regions: [poly],\n            inverted: false\n        });\n\n        return res.regions;\n    }\n\n    res = polybool.union({\n        regions: list,\n        inverted: false\n    }, {\n        regions: [poly],\n        inverted: false\n    });\n\n    return res.regions;\n}\n\nfunction fillSelectionItem(selection, searchInfo) {\n    if(Array.isArray(selection)) {\n        var cd = searchInfo.cd;\n        var trace = searchInfo.cd[0].trace;\n\n        for(var i = 0; i < selection.length; i++) {\n            selection[i] = makeEventData(selection[i], trace, cd);\n        }\n    }\n\n    return selection;\n}\n\nfunction clearSelect(zoomlayer) {\n    // until we get around to persistent selections, remove the outline\n    // here. The selection itself will be removed when the plot redraws\n    // at the end.\n    zoomlayer.selectAll('.select-outline').remove();\n}\n\nmodule.exports = {\n    prepSelect: prepSelect,\n    clearSelect: clearSelect\n};\n",null]}