{"remainingRequest":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scatterpolargl/index.js","dependencies":[{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/plotly.js/src/traces/scatterpolargl/index.js","mtime":1529418310744},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/cache-loader/dist/cjs.js","mtime":1529418306962},{"path":"/Users/vamsikarri/Desktop/Gathi/Angular/FederatedQuery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529418304772}],"contextDependencies":[],"result":["/**\n* Copyright 2012-2018, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar cluster = require('point-cluster');\nvar isNumeric = require('fast-isnumeric');\n\nvar ScatterGl = require('../scattergl');\nvar calcColorscales = require('../scatter/colorscale_calc');\nvar Axes = require('../../plots/cartesian/axes');\nvar makeHoverPointText = require('../scatterpolar/hover').makeHoverPointText;\nvar subTypes = require('../scatter/subtypes');\n\nvar TOO_MANY_POINTS = require('../scattergl/constants').TOO_MANY_POINTS;\n\nfunction calc(container, trace) {\n    var layout = container._fullLayout;\n    var subplotId = trace.subplot;\n    var radialAxis = layout[subplotId].radialaxis;\n    var angularAxis = layout[subplotId].angularaxis;\n    var rArray = radialAxis.makeCalcdata(trace, 'r');\n    var thetaArray = angularAxis.makeCalcdata(trace, 'theta');\n    var stash = {};\n\n    if(trace._length < rArray.length) rArray = rArray.slice(0, trace._length);\n    if(trace._length < thetaArray.length) thetaArray = thetaArray.slice(0, trace._length);\n\n    calcColorscales(trace);\n\n    stash.r = rArray;\n    stash.theta = thetaArray;\n\n    Axes.expand(radialAxis, rArray, {tozero: true});\n\n    if(angularAxis.type !== 'linear') {\n        angularAxis.autorange = true;\n        Axes.expand(angularAxis, thetaArray);\n        delete angularAxis.autorange;\n    }\n\n    return [{x: false, y: false, t: stash, trace: trace}];\n}\n\nfunction plot(container, subplot, cdata) {\n    var radialAxis = subplot.radialAxis;\n    var angularAxis = subplot.angularAxis;\n    var rRange = radialAxis.range;\n\n    var scene = ScatterGl.sceneUpdate(container, subplot);\n    scene.clear();\n\n    cdata.forEach(function(cdscatter, traceIndex) {\n        if(!cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n        var cd = cdscatter[0];\n        var trace = cd.trace;\n        var stash = cd.t;\n        var rArray = stash.r;\n        var thetaArray = stash.theta;\n        var i, r, rr, theta, rad;\n\n        var subRArray = rArray.slice();\n        var subThetaArray = thetaArray.slice();\n\n        // filter out by range\n        for(i = 0; i < rArray.length; i++) {\n            r = rArray[i], theta = thetaArray[i];\n            rad = angularAxis.c2rad(theta, trace.thetaunit);\n\n            if(!subplot.isPtWithinSector({r: r, rad: rad})) {\n                subRArray[i] = NaN;\n                subThetaArray[i] = NaN;\n            }\n        }\n\n        var count = rArray.length;\n        var positions = new Array(count * 2), x = Array(count), y = Array(count);\n\n        function c2rad(v) {\n            return angularAxis.c2rad(v, trace.thetaunit);\n        }\n\n        for(i = 0; i < count; i++) {\n            r = subRArray[i];\n            theta = subThetaArray[i];\n\n            if(isNumeric(r) && isNumeric(theta) && r >= 0) {\n                rr = radialAxis.c2r(r) - rRange[0];\n                rad = c2rad(theta);\n\n                x[i] = positions[i * 2] = rr * Math.cos(rad);\n                y[i] = positions[i * 2 + 1] = rr * Math.sin(rad);\n            } else {\n                x[i] = y[i] = positions[i * 2] = positions[i * 2 + 1] = NaN;\n            }\n        }\n\n        var options = ScatterGl.sceneOptions(container, subplot, trace, positions);\n\n        // set flags to create scene renderers\n        if(options.fill && !scene.fill2d) scene.fill2d = true;\n        if(options.marker && !scene.scatter2d) scene.scatter2d = true;\n        if(options.line && !scene.line2d) scene.line2d = true;\n        if((options.errorX || options.errorY) && !scene.error2d) scene.error2d = true;\n\n        stash.tree = cluster(positions);\n\n        // FIXME: see scattergl.js#109\n        if(options.marker && count >= TOO_MANY_POINTS) {\n            options.marker.cluster = stash.tree;\n        }\n\n        // bring positions to selected/unselected options\n        if(subTypes.hasMarkers(trace)) {\n            options.selected.positions = options.unselected.positions = options.marker.positions;\n        }\n\n        // save scene options batch\n        scene.lineOptions.push(options.line);\n        scene.errorXOptions.push(options.errorX);\n        scene.errorYOptions.push(options.errorY);\n        scene.fillOptions.push(options.fill);\n        scene.markerOptions.push(options.marker);\n        scene.selectedOptions.push(options.selected);\n        scene.unselectedOptions.push(options.unselected);\n        scene.count = cdata.length;\n\n        // stash scene ref\n        stash._scene = scene;\n        stash.index = traceIndex;\n        stash.x = x;\n        stash.y = y;\n        stash.rawx = x;\n        stash.rawy = y;\n        stash.r = rArray;\n        stash.theta = thetaArray;\n        stash.positions = positions;\n        stash.count = count;\n    });\n\n    return ScatterGl.plot(container, subplot, cdata);\n}\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var stash = cd[0].t;\n    var rArray = stash.r;\n    var thetaArray = stash.theta;\n\n    var scatterPointData = ScatterGl.hoverPoints(pointData, xval, yval, hovermode);\n    if(!scatterPointData || scatterPointData[0].index === false) return;\n\n    var newPointData = scatterPointData[0];\n\n    if(newPointData.index === undefined) {\n        return scatterPointData;\n    }\n\n    var subplot = pointData.subplot;\n    var angularAxis = subplot.angularAxis;\n    var cdi = newPointData.cd[newPointData.index];\n    var trace = newPointData.trace;\n\n    // augment pointData with r/theta param\n    cdi.r = rArray[newPointData.index];\n    cdi.theta = thetaArray[newPointData.index];\n    cdi.rad = angularAxis.c2rad(cdi.theta, trace.thetaunit);\n\n    if(!subplot.isPtWithinSector(cdi)) return;\n\n    newPointData.xLabelVal = undefined;\n    newPointData.yLabelVal = undefined;\n    newPointData.extraText = makeHoverPointText(cdi, trace, subplot);\n\n    return scatterPointData;\n}\n\nmodule.exports = {\n    moduleType: 'trace',\n    name: 'scatterpolargl',\n    basePlotModule: require('../../plots/polar'),\n    categories: ['gl', 'regl', 'polar', 'symbols', 'markerColorscale', 'showLegend', 'scatter-like'],\n\n    attributes: require('./attributes'),\n    supplyDefaults: require('./defaults'),\n\n    calc: calc,\n    plot: plot,\n    hoverPoints: hoverPoints,\n    style: ScatterGl.style,\n    selectPoints: ScatterGl.selectPoints,\n\n    meta: {\n        hrName: 'scatter_polar_gl',\n        description: [\n            'The scatterpolargl trace type encompasses line charts, scatter charts, and bubble charts',\n            'in polar coordinates using the WebGL plotting engine.',\n            'The data visualized as scatter point or lines is set in',\n            '`r` (radial) and `theta` (angular) coordinates',\n            'Bubble charts are achieved by setting `marker.size` and/or `marker.color`',\n            'to numerical arrays.'\n        ].join(' ')\n    }\n};\n",null]}